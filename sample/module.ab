### definition of a module
module A {
	x: 0
}

# access by qualified identifier
puts(A::x)
A::x = 1
puts(A::x)

# access by import
module B {
    import A
    puts(x)
}

# re-opening of the module
module A {
    x = 2
}

### module local syntax
module A {
    infixl Define "is" 19

    y is x
    puts(y)

    module C {
        # you can use the syntax in innner module
        z is 0
        puts(z)
    }
}
# you can't use the syntax in outer module
# z is 0 (invalid)

module B {
    # the new definitions in A is visible in B  
    puts(y)
    z is y
    puts(z)
}

### anonymous scope 
# you can import some module to anonymous scope
f(): {
    a : 1
    b : 2
    return a + b
}
puts(f())
