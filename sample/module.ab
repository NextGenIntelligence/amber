### definition of a module
module A {
	x: 0
}

# access to module-local variable using qualified identifier
puts(A::x)
A::x = 1
puts(A::x)

# access to module-local variable using open
module B {
    open A
    puts(x)
}

# re-opening of the module
module A {
    x = 2
}
puts(A::x)

### module local syntax
module A {
    statement ::= symbol "is" expr
        { `(!node0 : !node2) }

    y is x
    puts(y)
    module C {
        # you can use the syntax in innner modules
        z is 0
        puts(z)
    }
}

module B {
    # the new definitions in A is visible in its super modules
    puts(y)
    z is y
    puts(z)
}

### scope local open
# modules can be opened in anonymous scopes locally
f(): (A){
    a is 1
    b is 2
    return a + b
}
puts(f())
