;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-packrat.rlc 2012-10-02 20:27:24 nineties $
;

; TODO:
; parse_statement and `scoped' syntax elements may have side-effects.
; Further validation is required.

(import "rlvm-compile")
(import "rowl1-types")

; character groups
(var CH_EOS        0) ; "\0"
(var CH_SPACES     1) ; "\t\r\n "
(var CH_0          2) ; "0"
(var CH_1          3) ; "1"
(var CH_2_7        4) ; "234567"
(var CH_8_9        5) ; "89"
(var CH_af         6) ; "af"
(var CH_b          7) ; "b"
(var CH_e          8) ; "e"
(var CH_HEX        9) ; "ABCDEFcd"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_OTHER     14) ; "GHIJKLMNOPQRSTUVWXYZcdghijklmpqsuwuz_"
(var CH_SHARP     15) ; "#"
(var CH_INVALID   16)

; fixed-length integers are 31-bits because of boxing
(var INTEGER_MAX  (- (<< 1 30) 1))

; end of file
(var EOF -2)

(define CHGRP (c) `(array_get char chgroup @c))
(define PARSED (p) `(== (field_get @p 1) true))
(define TOKEN (p) `(field_get @p 2))

(define MEMOIZE (sym)
    `(export fun @(s++ `parse_ sym) (p) (
        (var s (to_sym @(++ "parse_" sym "_")))
        (var tbl (field_get (field_get p 3) 2))
        (var pos (field_get p 5))
        (var v (memotable_find tbl s pos))
        (if v (do
            (set_parser_state_all p (field_get v 1))
            return
            ))
        (@(s++ `parse_ sym '_') p)
        (var state (copy_parser_state p))
        (memotable_add tbl s pos (struct 2 @(TOKEN p) state @FALSE @FALSE))
    )))

(define OR (p ps) (do
    (var end_lbl (mklabel))
   `(do
        (var state (copy_parser_state @p))
        (var v 0)
        (var error (alloc_error_state @p))
        (do . @(map (lambda (f) 
            `(do
              (@(s++ `parse_ f) @p)
              (if @(PARSED p) (goto @end_lbl))
              (join_error_state error p)
              (set_parser_state_all @p state)
             )) ps))
        (set_error_state @p error)
        (label @end_lbl)
    )))
(define CHECK (p)
    `(if (! @(PARSED p)) return)
    )

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-module")
(import "rowl1-error")

(array char chgroup (
     0 16 16 16 16 16 16 16 16  1  1 16 16  1 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
     1 16 16 15 16 16 16 16 16 16 16 16 16 16 16 16
     2  3  4  4  4  4  4  4  5  5 16 16 16 16 16 16
    16  9  9  9  9  9  9 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 16 16 16 16 14
    16  6  7  9  9  8  6 14 14 14 14 14 14 14 13 10
    14 14 11 14 11 14 11 14 12 14 14 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    ))

; hashtable for memoization
; key:   (non-terminal symbol, position (integer))
; value: (node, parser state)
;
; structure of tables
;   0 : bucket (vector)
;   1 : entries (vector)
;   
; structure of entries
;   0 : symbol
;   1 : expr
;   2 : pointer to the next entry
;   3 : position value
;   4 : hash value

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

(fun make_memotable (hint) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (struct 2 (make_vector size) (make_vector 0)))
    ))

(fun memotable_clear (table) (
    (vector_clear (field_get table 0))
    (vector_resize (field_get table 1) 0)
    ))

(fun hash (sym pos) (
    (var h (field_get sym @SymbolIndex))
    (= h (+ (* 7 h) pos))
    (return h)
    ))

(fun rehash (table) (
    (var old_size (vector_size (field_get table 0)))
    (var num_ent  (vector_size (field_get table 1)))
    (if (>= num_ent old_size) (do
        (var new_size (array_get int prime_numbers (bsr num_ent)))
        (if (! new_size) (error "rehash: too many entries"))
        (var bucket (make_vector new_size))
        (var entries (field_get table 1))
        (for i 0 (vector_size entries) (do
            (var entry (vector_at entries i))
            (if (! entry) continue)
            (var h (umod (field_get entry 4) new_size))
            (field_set entry 2 (vector_at bucket h))
            (vector_put bucket h entry)
            ))
        (field_set table 0 bucket)
        ))
    ))

(fun memotable_add (table sym pos obj) (
    (rehash table)

    (var bucket (field_get table 0))
    (var entries (field_get table 1))
    (var size (vector_size bucket))
    (var h (hash sym pos))

    (var ent (struct 3 sym obj 0 pos h))
    (= h (umod h size))

    (vector_pushback entries ent)

    (field_set ent 2 (vector_at bucket h))
    (vector_put bucket h ent)
    ))

(fun memotable_find (table sym pos) (
    (var bucket (field_get table 0))
    (var size (vector_size bucket))
    (var h (hash sym pos))
    (= h (umod h size))
    (var entry (vector_at bucket h))
    (while entry (do
        (var e_sym (field_get entry 0))
        (var e_pos (field_get entry 3))
        (if (&& (== e_sym sym) (== e_pos pos))
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return 0)
    ))

(var space_sensitive_p @FALSE)
(var multiline_p @FALSE)
(var shell_mode_p @FALSE)
(var may_parse @FALSE)
(var left_rec (string "Left Recursion Detected"))

(extern object current_mod)
(extern fun set_current_module)

(fun trace (obj) (
    (return (block (list2
        (apply (to_sym "print") (list2 (to_sym "stderr") obj))
        (apply (to_sym "print") (list2 (to_sym "stderr") (string "\n")))
        )))
    ))

(export fun set_shell_mode () (
    (= shell_mode_p @TRUE)
    ))

(export fun unset_shell_mode () (
    (= shell_mode_p @FALSE)
    ))

(export fun in_shell_mode () (
    (return shell_mode_p)
    ))

(export fun parse (name p) (
    (return (byterun (lookup_func current_mod (to_sym name)) p))
    ))

(export fun parse_success (p) (
    (return @(PARSED p))
    ))
(export fun parsed_token (p) (
    (return @(TOKEN p))
    ))
(export fun parser_error (p) (
    (return @(TOKEN p))
    ))

(fun parsed (p val) (
    (field_set p 1 true)
    (field_set p 2 val)
    ))

(fun noparse (p msg) (
    (field_set p 1 false)
    (field_set p 2 (string msg))
    ))

(fun mayparse (p msg) (
    (= may_parse @TRUE)
    (field_set p 1 false)
    (field_set p 2 (string msg))
    ))

(fun alloc_error_state (p) (
    (return (struct 2 0 (field_get p 4) 0 0)) ; msg, file, line, pos
    ))

(fun join_error_state (err p) (
    (var pos (field_get p 5))
    (if (<= (field_get err 3) pos) (do
        (field_set err 0 (field_get p 2))
        (field_set err 1 (field_get p 4))
        (field_set err 2 (field_get p 6))
        (field_set err 3 pos)
        ))
    ))
    
(fun set_error_state (p err) (
    (field_set p 1 false)
    (field_set p 2 (field_get err 0)) 
    (field_set p 4 (field_get err 1))
    (field_set p 5 (field_get err 3))
    (field_set p 6 (field_get err 2))
    ))

(fun negate (p) (
    (if @(PARSED p)
        (do
            (field_set p 1 false)
            (field_set p 2 (string "unexpected token"))
        )
        (do
            (field_set p 1 true)
            (field_set p 2 nil)
        ))
    ))

(fun apply_located (p) (
    (field_set p 2 (located (get_loc p) (field_get p 2)))
    ))

(fun integer_overflow (p) (
    (return (noparse p "integer literal is too large"))
    ))

(fun junk_letter (p) (
    (return (noparse p "junk letter(s) at the end of integer literal"))
    ))

; structure of parser
;   0: head (ParserE)
;   1: parsed=true, noparse=false
;   2: parsed token or error message
;   3: (character buffer, input channel, table for memoization)
;   4: filename
;   5: current position in the character buffer
;   6: line number
;   7: column number
;   8: indentation

(export fun init_parser (file ichan) (
    ; character buffer
    (var cbuf (make_cvector 0))
    ; current position in cbuf
    (var pos 0)
    ; offset + pos is the number of total characters from the beginning of parsing

    ; table for memoization
    (var memo (make_memotable 1000))
    (var buf (struct 3 cbuf ichan memo))

    (return (variant @ParserE 4 0 0 buf (string file) pos 1 1 1))
    ))

(export fun flush_parser (p force) (
    (var buf (field_get p 3))
    (var cbuf (field_get buf 0))
    (var bufsz (cvector_size cbuf))
    (var pos (field_get p 5))

    ; XXX: Not good implementation.
    ; Ring buffer is better.
    (if (|| (>= pos bufsz) force) (do
        (cvector_resize cbuf 0)
        (field_set p 5 0)
        ))

    (memotable_clear (field_get buf 2))
    (if shell_mode_p (field_set p 6 (+ (field_get p 6) 1)))
    ))

(fun copy_parser_state (p) (
    (var copy (variant @ParserE 4 0 0 0 0 0 0 0 0))
    (memcpy copy p (* 9 @WORD_SIZE))
    (return copy)
    ))

(fun set_parser_state_all (dst src) (
    ; NB: indent-level must not be copied.
    (memcpy dst src (* 8 @WORD_SIZE))
    ))

(fun set_parser_state (dst src) (
    ; NB: token info and indent-level must not be copied.
    (memcpy (+ dst (* 3 @WORD_SIZE)) (+ src (* 3 @WORD_SIZE)) (* 5 @WORD_SIZE))
    ))

(fun clear_parser_state (p state) (
    (var buf (field_get p 3))
    (set_parser_state_all p state)
    (memotable_clear (field_get buf 2))
    ))

(fun extract_string (p begin end) (
    (var len (- end begin))
    (var vec (field_get (field_get p 3) 0))
    (return (strndup (+ (cvector_raw vec) begin) len))
    ))

; boxed version
(fun extract_string_ (p begin end) (
    (return (extract_string p (unbox begin) (unbox end)))
    ))

(export fun get_pos (p) (
    (return (box (field_get p 5)))
    ))

(export fun get_loc (p) (
    (var line (field_get p 6))
    (var clmn (field_get p 7))
    (return (make_loc (field_get p 4) line clmn line clmn))
    ))

(fun get_column (p) (
    (return (box (field_get p 7)))
    ))

(fun get_indent (p) (
    (return (box (field_get p 8)))
    ))

; set new indentation-level and return current indentation-level
(fun set_indent (p c) (
    (var current_indent (field_get p 8))
    (field_set p 8 (unbox c))
    (return (box current_indent))
    ))

(fun reserve (p) (
    (var buf (field_get p 3))
    (var vec (field_get buf 0))
    (var ichan (field_get buf 1))
    (var line 0)
    (var c 0)
    (while (>= (input_char (address c) ichan) 0) (do
        (cvector_pushback vec c)
        (if (|| (== c '\n') (== c '\0')) (return 0))
        ))
    (return -1)
    ))

(fun lookahead (p) (
    (var buf (field_get p 3))
    (var vec (field_get buf 0))
    (var idx (field_get p 5))
    (if (>= idx (cvector_size vec)) (do
        (if (&& (! shell_mode_p) (< (reserve p) 0))
            (return @EOF)
            )
        ))
    (if (>= idx (cvector_size vec))
        (return -1)
        )
    (return (cvector_at vec idx))
    ))

(fun getc (p) (
    (var c (lookahead p))
    (if (< c 0) (return c))
    ; update source location
    (if (== c '\n') (do
        (if (! shell_mode_p)
            (field_set p 6 (+ (field_get p 6) 1))
            )
        (field_set p 7 0)
        ))
    (field_set p 5 (+ (field_get p 5) 1))
    (field_set p 7 (+ (field_get p 7) 1))
    (return c)
    ))

; utilities
(fun is_spaces (c) (
    (return (== @(CHGRP c) @CH_SPACES))
    ))
(fun is_01 (c) (
    (= c @(CHGRP c))
    (return (|| (== c @CH_0) (== c @CH_1)))
    ))
(fun is_0_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_8_9)))
    ))
(fun is_1_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_1 c) (<= c @CH_8_9)))
    ))
(fun is_0_7 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_2_7)))
    ))
(fun is_hexdigit (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_HEX)))
    ))
(export fun is_letter (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_af c) (<= c @CH_OTHER)))
    ))
(export fun is_identchar (c) (
    (if (< c 0) (return @FALSE))
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_OTHER)))
    ))
(var escape_chars "'\"\\abfnrtv0")
(fun is_escape_char (c) (
    (for i 0 (strlen escape_chars) (do
        (if (== c (array_get char escape_chars i))
            (return @TRUE)
        )))
    (return @FALSE)
    ))
(fun is_end_of_token (p) (
    (var c (lookahead p))
    (if (< c 0) (return @TRUE))
    (= c @(CHGRP c))
    (return (|| (< c @CH_0) (> c @CH_OTHER)))
    ))

(fun parse_char (p c) (
    (var v (getc p))
    (if (< v 0)
        (return (mayparse p (strcat "expect " (escape_char c))))
        )
    (if (== v c) (do
        (return (parsed p (ctos c)))
        ))
    (return (noparse p 
        (strcat "expect " 
        (strcat (escape_char c)
        (strcat " but got " (escape_char v))))))
    ))

(fun parse_any_char (p) (
    (var c (getc p))
    (if (< c 0)
        (return (mayparse p "end of input stream"))
        (return (parsed p (ctos c)))
        )
    ))

(fun parse_text (p str) (
    (var i 0)
    (var len (strlen str))
    (for i 0 len (do
        (var c (array_get uchar str i))
        (var v (getc p))
        (if (< v 0) (return (mayparse p (strcat "expect " str))))
        (if (!= c v) (return (noparse p (strcat "expect " str))))
        ))
    (return (parsed p (string str)))
    ))

; parse_integers
; multi-precision integer is not supported for now
(fun parse_decimal_ (p) (
    (var v (getc p))
    (var sign 1)

    (if (< v 0) (return (mayparse p "expect a number")))
        
    (if (== v '-') (do
        (= sign -1)
        (= v (getc p))
        ))

    (if (&& (== v '0') (is_end_of_token p))
        (return (parsed p (box 0)))
        )
    (if (! (is_1_9 v)) (return (noparse p "expect 1-9")))
    (var value (- v '0'))
    (while (is_0_9 (lookahead p)) (do
        (= v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 10))
            (return (integer_overflow p))
            )
        (= value (+ (* value 10) v))
        ))
    (if (is_end_of_token p)
        (return (parsed p (box (* sign value))))
        )
    (if (== (lookahead p) 'e') (do
        (getc p)
        (parse_decimal p)
        @(CHECK p)
        (var exp (unbox @(TOKEN p)))
        (while (> exp 0) (do
            (if (> value (/ @INTEGER_MAX 10))
                (return (integer_overflow p))
                )
            (*= value 10)
            (-= exp 1)
            ))
        (return (parsed p (box (* sign value))))
        ))
    (return (junk_letter p))
    ))
@(MEMOIZE decimal)

(fun parse_binary_ (p) (
    (parse_text p "0b")
    @(CHECK p)
    (if (! (is_01 (lookahead p))) (return (noparse p "expect 0 or 1")))
    (var value 0)
    (while (is_01 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 2))
            (return (integer_overflow p))
            )
        (= value (| (<< value 1) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter p))
        )
    (return (parsed p (box value)))
    ))
@(MEMOIZE binary)

(fun parse_octal_ (p) (
    (parse_text p "0o")
    @(CHECK p)
    (if (! (is_0_7 (lookahead p))) (return (noparse p "expect 0-7")))
    (var value 0)
    (while (is_0_7 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (>> (- @INTEGER_MAX v) 3))
            (return (integer_overflow p))
            )
        (= value (+ (<< value 3) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter p))
        )
    (return (parsed p (box value)))
    ))
@(MEMOIZE octal)

(fun parse_hex_ (p) (
    (parse_text p "0x")
    @(CHECK p)
    (if (! (is_hexdigit (lookahead p))) (return (noparse p "expect hex digit")))
    (var value 0)
    (while (is_hexdigit (lookahead p)) (do
        (var v (getc p))
        (if (<= 'a' v)
            (= v (+ (- v 'a') 10))
        (if (<= 'A' v)
            (= v (+ (- v 'A') 10))
            (= v (- v '0'))
            ))
        (if (> value (>> (- @INTEGER_MAX v) 4))
            (return (integer_overflow p))
            )
        (= value (+ (<< value 4) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter p))
        )
    (return (parsed p (box value)))
    ))
@(MEMOIZE hex)

(fun parse_integer_ (p) (
    @(OR p `(decimal hex octal binary))
    ))
@(MEMOIZE integer)

(extern fun float_from_s)
(fun parse_float_ (p) (
    (var begin (field_get p 5))
    (parse_decimal p)
    @(CHECK p)
    (if (!= (lookahead p) '.') (return (noparse p "expect '.'")))
    (getc p)
    (while (is_0_9 (lookahead p)) (getc p))
    (if (== (lookahead p) 'e') (do
        (getc p)
        (if (== (lookahead p) '-') (getc p))
        (if (! (is_0_9 (lookahead p))) (return (noparse p "expect a number")))
        (getc p)
        (while (is_0_9 (lookahead p)) (getc p))
        ))
    (return (parsed p (float_from_s (extract_string p begin (field_get p 5)))))
    ))
@(MEMOIZE float)

(fun parse_blank_ (p) (
    (var c (getc p))
    (if (< c 0) (return (mayparse p "end of input stream")))
    (if (&& (is_spaces c) (!= c '\n')) (return (parsed p (ctos c))))
    (return (noparse p "expect a blank character"))
    ))
@(MEMOIZE blank)

(fun parse_blanks_ (p) (
    (var code (lookup_func current_mod (to_sym "parse_blank")))
    (var state (copy_parser_state p))
    (while @TRUE (do
        (set_parser_state_all state p)
        (byterun code p)
        (if @(PARSED p) continue)
        (set_parser_state_all p state)
        break
        ))
    (return (parsed p nil))
    ))
@(MEMOIZE blanks)

(fun parse_spaces_ (p) (
    (var code (lookup_func current_mod (to_sym "parse_blank")))
    (var state (copy_parser_state p))
    (while @TRUE (do
        (set_parser_state_all state p)
        (byterun code p)
        (if @(PARSED p) continue)
        (set_parser_state_all p state)
        (parse_char p '\n')
        (if @(PARSED p) continue)
        (set_parser_state_all p state)
        break
        ))
    (if (<= (get_column p) (get_indent p)) (do
        (return (noparse p "invalid indentation"))
        ))
    (return (parsed p nil))
    ))
@(MEMOIZE spaces)

(fun parse_shell_style_comment_ (p) (
    (var v (getc p))
    (if (< v 0) (return (mayparse p (string "expect '#'"))))
    (if (!= v '#') (return (noparse p (string "expect '#'"))))
    (while @TRUE (do
        (var c (getc p))
        (if (|| (== c '\n') (< c 0)) break)
        ))
    (return (parsed p nil))
    ))
@(MEMOIZE shell_style_comment)

(fun parse_symbol_ (p) (
    (var c (lookahead p))
    (if (< c 0) (return (mayparse p "expect a symbol")))
    (if (! (is_letter c)) (return (noparse p "expect a symbol")))
    (var begin (field_get p 5))
    (while (is_identchar (lookahead p)) (do
        (getc p)
        ))
    (var s (to_sym (extract_string p begin (field_get p 5))))
    (return (parsed p s))
    ))
@(MEMOIZE symbol)

; single-quoted string literal
;   Only escape sequence \' is interpreted.
(fun parse_string_s_ (p) (
    (var v (getc p))
    (if (< v 0) (return (mayparse p "expect '")))
    (if (!= v ''') (return (noparse p "expect '")))
    (var begin (field_get p 5))
    (while (!= (lookahead p) ''') (do
        (var c (getc p))
        (if (== c '\\') (getc p))
        ))
    (var end (field_get p 5))

    (= v (getc p))
    (if (< v 0) (return (mayparse p "expect '")))
    (if (!= v ''') (return (noparse p "expect '")))

    (var str (extract_string p begin end))
    (unescape_string_s str)
    (return (parsed p str))
    ))
@(MEMOIZE string_s)

; double-quoted string literal
(fun parse_string_d_ (p) (
    (var v (getc p))
    (if (< v 0) (return (mayparse p "expect \"")))
    (if (!= v '"') (return (noparse p "expect \"")))
    (var begin (field_get p 5))
    (while (!= (lookahead p) '"') (do
        (var c (getc p))
        (if (< c 0) (return (mayparse p "expect character")))

        (if (== c '\\') (do
            (if (! (is_escape_char (getc p)))
                (return (noparse p "invalid escape sequence"))
                )
            ))
        ))
    (var end (field_get p 5))
    (= v (getc p))
    (if (< v 0) (return (mayparse p "expect \"")))
    (if (!= v '"') (return (noparse p "expect \"")))
    (var str (extract_string p begin end))
    (unescape_string_d str)
    (return (parsed p str))
    ))
@(MEMOIZE string_d)

(fun parse_string_ (p) (
    @(OR p `(string_d string_s))
    (if (! @(PARSED p))
        (return (noparse p "expect string literal"))
        )
    ))
@(MEMOIZE string)

(fun parse_node_ (p) (
    (parse_symbol p)
    (if (! @(PARSED p))
        (return (noparse p "expect a head symbol"))
        )
    (var hd @(TOKEN p))

    (parse_spaces p)
    (parse_char p '{')
    @(CHECK p)
    (parse_spaces p)

    (var args 0)
    (if (!= (lookahead p) '}') (do
        (while (> (lookahead p) 0) (do
            (parse "parse_expr" p)
            @(CHECK p)
            (= args (cons @(TOKEN p) args))
            (parse_spaces p)

            (if (== (lookahead p) '}') break)
            (parse_char p ',')
            @(CHECK p)
            (parse_spaces p)
            ))
        ))
    (parse_char p '}')
    @(CHECK p)

    (parsed p (make_expr_user hd (list_reverse args)))
    ))
@(MEMOIZE node)

(fun parse_atom_ (p) (
    @(OR p `(
        symbol
        float
        integer
        string
    ))
    ))
@(MEMOIZE atom)

(fun parse_expr_ (p) (
    @(OR p `(
        node
        atom
    ))
    ))
@(MEMOIZE expr)

(fun parse_statement_ (p) (
    (parse "parse_expr" p)
    @(CHECK p)

    (eval_parser_command p)
    (var loc (get_loc p))
    (return (parsed p (located loc @(TOKEN p))))
    ))
@(MEMOIZE statement)

(export fun parse_statements (p) (
    (parsed p 0)
    (if (== (lookahead p) @EOF) return)
    (var stmts 0)
    (while @TRUE (do
        (if (== (lookahead p) @EOF) break)
        (set_indent p (box 0))
        (parse_spaces p)

        (if (== (lookahead p) '\n') (do
            (getc p)
            continue
            ))
        (if (== (lookahead p) @EOF) break)

        (set_indent p (get_column p))
        (parse "parse_statement" p)
        @(CHECK p)
        (var stmt @(TOKEN p))
        (var loc (get_loc p))
        (parse_blanks p)

        (if (== (lookahead p) @EOF) break)

        (parse_char p '\n')
        @(CHECK p)

        (if (!= (expr_head stmt) Located) (do
            (output_error stderr loc)
            (output_string stderr "parse_statement must returns Located{ ... }\n")
            (exit 1)
            ))

        (= stmts (cons stmt stmts))

        ; stop continue parsing when the stmt has side-effects for parsing.
        (var hd (expr_head (expr_arg stmt 1)))
        (if (|| (== hd BeginModule)
            (|| (== hd EndModule)
            (|| (== hd Include)
            (== hd DefSyntax))))
            break
            )
        ))
    (parsed p (list_reverse stmts))
    ))

(fun print_prompt (p sign) (
    (var line (field_get p 6))
    (output_string stdout "amber:")
    (output_int stdout line)
    (output_string stdout sign)
    (flush stdout)
    ))

(export fun parse_shell_statement (p) (
    (print_prompt p "> ")
    (reserve p)
    (var state (copy_parser_state p))
    (while @TRUE (do
        (= may_parse @FALSE)
        (set_indent p (box 0))
        (parse_spaces p)

        (set_indent p (get_column p))
        (parse "parse_statement" p)
        (if (! @(PARSED p)) (if may_parse (goto retry) return))
        (var e @(TOKEN p))
        (var loc (get_loc p))

        (parse_spaces p)
        (parse_char p ';')
        (if (! @(PARSED p)) (if may_parse (goto retry) return))
        (parse_char p '\n')
        (if (! @(PARSED p)) (if may_parse (goto retry) return))

        (if (!= (expr_head e) Located) (do
            (output_error stderr loc)
            (output_string stderr "parse_statement must returns Located{ ... }\n")
            (exit 1)
            ))
        (parsed p e)
        return

        (label retry)
        (clear_parser_state p state)
        (print_prompt p "~ ")
        (reserve p)
        ))
    ))

(fun eval_parser_command (p) (
    (if (! @(PARSED p)) (return nil))
    (var expr @(TOKEN p))
    (var ty (expr_head expr))
    (if (== ty Import) (do
        (import_module (get_loc p) current_mod (expr_arg expr 0))
        ))
    ))

(fun add_parser (mod sym func) (
    (add_builtin_function1 mod sym (domainP Parser) func 0)
    ))

(fun to_parse (sym) (
    (return (to_sym (strcat "parse_" (symbol_name sym))))
    ))

(fun to_parse_ (sym) (
    (return (to_sym (strcat "parse_" (strcat (symbol_name sym) "_"))))
    ))

(var PVar (to_sym "%Parser")) ; internal use
(fun make_nodevar (idx) (
    (return (to_sym (strcat "node" (itos idx))))
    ))

(fun gen_at (node idx) (
    (return (make_expr ExprAt (list2 node (box idx))))
    ))
(fun gen_copy_parser_state (v) (
    (return (apply (to_sym "%copy_parser_state") (list1 v)))
    ))
(fun gen_set_parser_state (dst src) (
    (return (apply (to_sym "%set_parser_state") (list2 dst src)))
    ))
(fun gen_set_parser_state_all (dst src) (
    (return (apply (to_sym "%set_parser_state_all") (list2 dst src)))
    ))

(fun set_parsed (v) (
    (return (block (list2
        (make_expr Assign (list2 (make_expr FieldRef (list2 PVar (box 1))) true))
        (make_expr Assign (list2 (make_expr FieldRef (list2 PVar (box 2))) v))
        )))
    ))

(fun set_noparse (v) (
    (return (block (list2
        (make_expr Assign (list2 (make_expr FieldRef (list2 PVar (box 1))) false))
        (make_expr Assign (list2 (make_expr FieldRef (list2 PVar (box 2))) v))
        )))
    ))

(fun get_token () (
    (return (make_expr FieldRef (list2 PVar (box 2))))
    ))

(fun test_parsed () (
    (return (make_expr FieldRef (list2 PVar (box 1))))
    ))

(fun test_noparse () (
    (return (make_expr Not (list1 (test_parsed))))
    ))

(fun gen_getloc () (
    (return (apply (to_sym "%get_loc") (list1 PVar)))
    ))

(fun gen_parse_spaces (cont) (
    (if space_sensitive_p (return cont))
    (= cont (cons (apply (to_sym "%parse_spaces") (list1 PVar)) cont))
    (if (! multiline_p)
        (= cont (cons (mkif (test_noparse) (mkreturn nil)) cont))
        )
    (return cont)
    ))

(fun gen_parse_spaces_break (cont) (
    (if space_sensitive_p (return cont))
    (= cont (cons (apply (to_sym "%parse_spaces") (list1 PVar)) cont))
    (if (! multiline_p)
        (= cont (cons (mkif (test_noparse) (make_expr Break 0)) cont))
        )
    (return cont)
    ))

(extern object current_loc)
(fun compile_parser_element (pat) (
    (var hd (expr_head pat))
    (if (== hd Symbol)
        (return (apply (dynamic (to_parse pat))
            (list1 PVar))))
    (if (== hd String)
        (return (apply (dynamic (to_sym "parse_text"))
            (list2 PVar pat))))
    (if (== hd List)
        (return (compile_seq pat))
        )
    (if (== hd Choice)
        (return (compile_choice (expr_args pat)))
        )
    (var len (list_len (expr_args pat)))
    (if (== hd Delimited) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 0))
        ))
    (if (== hd Delimited1) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 1))
        ))
    (if (== hd Delimited2) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 2))
        ))
    (if (== hd Scoped) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_scoped (expr_arg pat 0) (expr_arg pat 1)))
        ))
    (if (!= len 1) (goto compile_error))
    (if (== hd OneOf)
        (return (compile_oneof (expr_arg pat 0)))
        )
    (if (== hd NoneOf)
        (return (compile_noneof (expr_arg pat 0)))
        )
    (if (== hd Many)
        (return (compile_many (expr_arg pat 0)))
        )
    (if (== hd Many1)
        (return (compile_many1 (expr_arg pat 0)))
        )
    (if (== hd Option)
        (return (compile_option (expr_arg pat 0)))
        )
    (if (== hd And)
        (return (compile_and (expr_arg pat 0)))
        )
    (if (== hd Not)
        (return (compile_not (expr_arg pat 0)))
        )
    (if (== hd Aligned)
        (return (compile_aligned (expr_arg pat 0)))
        )
    (label compile_error)
    (throw (exception current_loc (list2 (string "invalid syntax element") pat)))
    ))

(fun oneof (p tbl str) (
    (var c (getc p))
    (if (< c 0)
        (return (mayparse p (strcat "expect one of " str)))
        )
    (if (array_get char tbl c)
        (return (parsed p (ctos c)))
        )
    (return (noparse p
        (strcat "expect one of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun noneof (p tbl str) (
    (var c (getc p))
    (if (< c 0)
        (return (mayparse p (strcat "expect none of " str)))
        )
    (if (! (array_get char tbl c))
        (return (parsed p (ctos c)))
        )
    (return (noparse p
        (strcat "expect none of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun compile_character_set (str) (
    (var tbl (allocate_string 128))
    (var len (strlen str))
    (var i 0)
    (while (< i len) (do
        (var c (array_get char str i))
        (if (== c '\\') (do ; escaped char
            (+= i 1)
            (if (== i len) (goto error))
            (= c (array_get char str i))
            (if (== c 'a') (array_set char tbl '\a' 1)
            (if (== c 'b') (array_set char tbl '\b' 1)
            (if (== c 'f') (array_set char tbl '\f' 1)
            (if (== c 'n') (array_set char tbl '\n' 1)
            (if (== c 'r') (array_set char tbl '\r' 1)
            (if (== c 't') (array_set char tbl '\t' 1)
            (if (== c 'v') (array_set char tbl '\v' 1)
            (if (== c '0') (array_set char tbl '\0' 1)
                (array_set char tbl c 1)
                ))))))))
            (+= i 1)
            continue
            ))
        (if (== (array_get char str (+ i 1)) '-') (do
            (if (>= (+ i 2) len) (goto error))
            (var d (array_get char str (+ i 2)))
            (if (> c d) (goto error))
            (while (<= c d) (do
                (array_set char tbl c 1)
                (+= c 1)
                ))
            (+= i 3)
            continue
            ))
        (array_set char tbl c 1)
        (+= i 1)
        ))
    (return tbl)
    (label error)
    (throw (invalid_argument current_loc 
        (string "invalid character-set")
        str
        ))
    ))

(fun compile_oneof (str) (
    (var tbl (compile_character_set str))
    (return (apply (to_sym "%oneof") (list3 PVar tbl str)))
    ))

(fun compile_noneof (str) (
    (var tbl (compile_character_set str))
    (return (apply (to_sym "%noneof") (list3 PVar tbl str)))
    ))

; List{ p1, p2, ...} is translated to
;
; elems = []
; v = p1
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; parse_spaces()
; v = p2
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; ...
; return Parsed{merge{loc(p1), loc(pn)}, reverse(elems)}

(fun compile_seq (elems) (
    (var body 0)
    (var ret (unique_sym))

    (= body (cons (defvar ret 0) body))
    (while elems (do
        (= body (cons (compile_parser_element (car elems)) body))
        (= body (cons (mkif (test_noparse) (mkreturn nil)) body))
        (= body (cons (assign ret (apply (to_sym "cons") (list2 (get_token) ret))) body))
        (= elems (cdr elems))
        (if elems 
            (= body (gen_parse_spaces body))
            )
        ))
    (= body (cons (set_parsed (apply (to_sym "reverse") (list1 ret))) body))
    (return (apply
        (lambda PVar (block (list_reverse body)))
        (list1 PVar)))
    ))

; Choice{ p1, p2, .. } is translated to
;
; lambda() {
;     error = 0
;     state = copy_parser_state(parser)
;     v = p1
;     if (head(v) == Parsed) (return v)
;     error = join_error_state(error, v)
;     set_parser_state_all(parser, state)
;     v = p2
;     ...
; }(p)

(fun compile_choice (ps) (
    (if (< (list_len ps) 2) (do
        (output_error stderr current_loc)
        (output_string stderr "Choice must have more than 1 argument.\n")
        (exit 1)
        ))

    (var body 0)
    (var state (unique_sym))
    (var error (unique_sym))

    (= body (cons (defvar error (apply (to_sym "%alloc_error_state") (list1 PVar))) body))
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))

    (while ps (do
        (= body (cons (compile_parser_element (car ps)) body))
        (= body (cons (mkif (test_parsed) (mkreturn nil)) body))
        (= body (cons (apply (to_sym "%join_error_state") (list2 error PVar)) body))
        (= body (cons (gen_set_parser_state_all PVar state) body))
        (= ps (cdr ps))
        ))
    (= body (cons (apply (to_sym "%set_error_state") (list2 PVar error)) body))

    (return (apply
        (lambda PVar (block (list_reverse body)))
        (list1 PVar)
        ))
    ))

; Many{ p } is translated to
;
; elems = []
; state = copy_parser_state(..)
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state_all(state, p)
;     parse_spaces()
; }
; set_parser_state_all(state)
; Parsed{loc, reverse(elems)}

(fun compile_many (elem) (
    (var state (unique_sym))
    (var elems (unique_sym))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons p loop_body))
    (= loop_body (cons (mkif (test_noparse) (make_expr Break 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state_all state PVar) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))
    (= body (cons (make_expr While (list2 true
            (block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state_all PVar state) body))
    (= body (cons (set_parsed (apply (to_sym "reverse") (list1 elems))) body))
    (return (block (list_reverse body)))
    ))

; Many1{ p } is translated to
;
; elems = []
; v = p
; if (head(v) == NoParse) return v
; elems = cons(val(v), elems)
; state = copy_parser_state(..)
; while true {
;     parse_spaces()
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state_all(state, p)
; }
; set_parser_state_all(state)
; Parsed{loc, reverse(elems)}

(fun compile_many1 (elem) (
    (var state (unique_sym))
    (var elems (unique_sym))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (gen_parse_spaces_break loop_body))
    (= loop_body (cons p loop_body))
    (= loop_body (cons (mkif (test_noparse) (make_expr Break 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state_all state PVar) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons p body))
    (= body (cons (mkif (test_noparse) (mkreturn nil)) body))
    (= body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) body))
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))
    (= body (cons (make_expr While (list2 true
            (block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state_all PVar state) body))
    (= body (cons (set_parsed (apply (to_sym "reverse") (list1 elems))) body))
    (return (block (list_reverse body)))
    ))

; Aligned{ p } is translated to
;
; elems = []
; state = copy_parser_state(..)
; column = get_column(p)
; set_indent(p, column)
; v = p
; if (head(v) == NoParse) {
;     set_parser_state_all(state)
;     reset_indent(p)
;     return Parsed{loc, []}
; }
; elems = cons(val(v), elems)
; set_parser_state_all(state, p)
; parse_spaces()
; while true {
;     if (get_column(p) != column) break
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state_all(state, p)
;     parse_spaces()
; }
; set_parser_state_all(state)
; reset_indent(p)
; Parsed{loc, reverse(elems)}

(fun compile_aligned (elem) (
    (var state (unique_sym))
    (var elems (unique_sym))
    (var clmn  (unique_sym))
    (var indent_save (unique_sym))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (mkif 
            (make_expr NotEqual (list2 
                (apply (to_sym "%get_column") (list1 PVar))
                clmn
                ))
            (make_expr Break 0)) loop_body))
    (= loop_body (cons p loop_body))
    (= loop_body (cons (mkif (test_noparse) (make_expr Break 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state_all state PVar) loop_body))
    (if (! space_sensitive_p)
        (= loop_body (cons (apply
            (to_sym "%parse_spaces") (list1 PVar)) loop_body))
        )

    (var body 0)
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))
    (= body (cons (defvar clmn (apply (to_sym "%get_column") (list1 PVar))) body))
    (= body (cons (defvar indent_save (apply (to_sym "%set_indent") (list2 PVar clmn))) body))
    (= body (cons (defvar elems 0) body))
    (= body (cons p body))
    (= body (cons (mkif (test_noparse)
            (block (list3
                (gen_set_parser_state_all PVar state)
                (apply (to_sym "%set_indent") (list2 PVar indent_save))
                (mkreturn (set_parsed 0))
            )))
        body))
    (= body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) body))
    (= body (cons (gen_set_parser_state_all state PVar) body))
    (if (! space_sensitive_p)
        (= body (cons (apply
            (to_sym "%parse_spaces") (list1 PVar)) body))
        )
    (= body (cons (make_expr While (list2 true
            (block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state_all PVar state) body))
    (= body (cons (apply (to_sym "%set_indent") (list2 PVar indent_save)) body))
    (= body (cons (set_parsed (apply (to_sym "reverse") (list1 elems))) body))
    (return (apply
        (lambda (make_expr Domain (list2 PVar Parser))
            (block (list_reverse body))
        ) (list1 PVar)))
    ))

; Delimited{ p, delim } is translated to
;
; elems = []
; state = copy_parser_state(..)
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state_all(setate, p)
;     parse_spaces()
;     v = delim
;     if (head(v) == NoParse) break
;     parse_spaces()
; }
; set_parser_state_all(state)
; Parsed{loc, reverse(elems)}

(fun compile_delimited (p delim minlen) (
    (var state (unique_sym))
    (var elems (unique_sym))
    (= p (compile_parser_element p))
    (= delim (compile_parser_element delim))

    (var loop_body 0)
    (= loop_body (cons p loop_body))
    (= loop_body (cons (mkif (test_noparse) (make_expr Break 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state_all state PVar) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))
    (= loop_body (cons delim loop_body))
    (= loop_body (cons (mkif (test_noparse) (make_expr Break 0)) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))
    (= body (cons (make_expr While (list2 true
            (block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state_all PVar state) body))
    (if (> minlen 0)
        (= body (cons (mkif  
            (apply (to_sym "lt")
                (list2 (apply (to_sym "length") (list1 elems)))
                    (box minlen))
            (mkreturn (set_noparse (string "The number of elements is insufficient")))
            ) body))
        )

    (= body (cons (set_parsed (apply (to_sym "reverse") (list1 elems))) body))
    (return (block (list_reverse body)))
    ))

; scope{ p } is translated to
;
; module = new anonymous module
; enter module
; execute `pre`
; v = p
; execute `post`
; exit module
; v
(fun compile_scoped (mod elem) (
    (var p (compile_parser_element elem))
    (return (block (list3
        (apply (to_sym "%open_scope") (list1 (quote mod)))
        p
        (apply (to_sym "%close_scope") (list1 PVar))
        )))
    ))

; enter anonymous scope
(fun open_scope (extra) (
    (var module (make_module nil current_mod))
    (set_current_module module)
    (if (!= extra nil)
        (import_module current_loc module extra)
        )
    ))

; exit from anonymous scope
(fun close_scope (p) (
    (var ls (imported_modules current_mod))
    (var mod current_mod)
    (set_current_module (super_module current_mod))
    (if (&& @(PARSED p) ls)
        (parsed p (make_expr Scoped (list2 mod @(TOKEN p))))
        )
    ))

; Option{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; if (head(v) == NoParse) {
;   set_parser_state_all(parser, state)
;   nil
; } else
;   Parsed{loc(v), Some{val(v)}}
(fun compile_option (p) (
    (var state (unique_sym))
    (return (block (list3
        (defvar state (gen_copy_parser_state PVar))
        (compile_parser_element p)
        (ifelse
            (test_noparse)
            (block (list2
                (gen_set_parser_state_all PVar state)
                (set_parsed nil)
                ))
            (set_parsed (qquote (make_expr Some (list1 (unquote (get_token))))))
            ))))
    ))

; And{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; v
(fun compile_and (p) (
    (var state (unique_sym))
    (return (block (list3
        (defvar state (gen_copy_parser_state PVar))
        (compile_parser_element p)
        (gen_set_parser_state PVar state)
        )))
    ))

; Not{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; negate(v,p)
(fun compile_not (p) (
    (var state (unique_sym))
    (return (block (list4
        (defvar state (gen_copy_parser_state PVar))
        (compile_parser_element p)
        (gen_set_parser_state PVar state)
        (apply (to_sym "%negate") (list2 PVar))
        )))
    ))

(fun compile_parser_action (elems act) (
    (var prog elems)
    (if (!= (expr_head elems) List) (do
        (output_error stderr current_loc)
        (output_string stderr "syntax statement must be List{syntax element, ...}: ")
        (pretty_print stderr elems)
        (output_string stderr "\n")
        (exit 1)
        ))

    (var idx 0)
    (var body 0)
    (var bpos (unique_sym))

    (= body (cons (defvar bpos (apply (to_sym "%get_pos") (list1 PVar))) body))
    (while elems (do
        (var ndvar (make_nodevar idx))
        (= body (cons (compile_parser_element (car elems)) body))
        (= body (cons (mkif (test_noparse) (mkreturn nil)) body))
        (= body (cons (defvar ndvar (get_token)) body))
        (incr idx)
        (= elems (cdr elems))
        (if elems 
            (= body (gen_parse_spaces body))
            )
        ))

    (= body (cons (defvar (to_sym "GET_INPUT_TEXT")
        (lambda (make_expr Tuple 0)
            (apply (to_sym "%extract_string") (list3
                PVar
                bpos
                (apply (to_sym "%get_pos") (list1 PVar))
            ))))
        body))

    (= body (cons (set_parsed act) body))
    (= body (block (list_reverse body)))
    (return (apply (lambda (make_expr Domain (list2 PVar Parser)) body) (list1 PVar)))
    ))

(var space_sensitive (to_sym "space_sensitive"))
(var multiline (to_sym "multiline"))
(fun setup_options (opts) (
    (if (!= (expr_head opts) List)
        (= opts (list1 opts))
        )
    (while opts (do
        (var opt (car opts))
        (if (== opt space_sensitive)
            (= space_sensitive_p @TRUE)
        (if (== opt multiline)
            (= multiline_p @TRUE)
            (throw (unexpected_error current_loc
                (string "unknown parser option") opt))
            ))
        (= opts (cdr opts))
        ))
    ))
(fun clear_options () (
    (= space_sensitive_p @FALSE)
    (= multiline_p @FALSE)
    ))

(fun compile_parser (sym elems) (
    (if (!= (expr_head elems) List)
        (throw (exception current_loc (string "invalid syntax declaration")))
        )

    (var body 0)
    (var state (unique_sym))
    (var error (unique_sym))

    ; if sym == parse_statement
    ; modify parsed expression to Located{...}
    (var return_stmt 0)
    (if (== sym (to_sym "parse_statement_"))
        (= return_stmt (block (list2
            (apply (to_sym "%eval_parser_command") (list1 PVar))
            (mkreturn (apply (to_sym "%apply_located") (list1 PVar)))
            )))
        (= return_stmt (mkreturn nil))
        )

    (= body (cons (defvar error (apply (to_sym "%alloc_error_state") (list1 PVar))) body))
    (= body (cons (defvar state (gen_copy_parser_state PVar)) body))
    (while elems (do
        (var t (car elems))
        (var size (expr_size t))
        (if (|| (!= (expr_head t) Tuple) (|| (< size 2) (> size 3))) (do
            (output_error stderr current_loc)
            (output_string stderr "parser element must be form of Tuple{parser, action, [options]}:")
            (pretty_print stderr t)
            (output_string stderr "\n")
            (exit 1)
            ))
        (if (== size 3)
            (setup_options (expr_arg t 2))
            )

        (var act (compile_parser_action (expr_arg t 0) (expr_arg t 1)))
        (= body (cons act body))
        (= body (cons (mkif (test_parsed) return_stmt) body))
        (= body (cons (apply (to_sym "%join_error_state") (list2 error PVar)) body))
        (= body (cons (gen_set_parser_state_all PVar state) body))
        (= elems (cdr elems))
        (clear_options)
        ))
    (= body (cons (apply (to_sym "%set_error_state") (list2 PVar error)) body))
    (return (block (list_reverse body)))
    ))

(extern fun compile_matching)
(fun call_parser (p sym new) (
    (var tbl (field_get (field_get p 3) 2))
    (var pos (field_get p 5))
    (var v (memotable_find tbl sym pos))
    (if v (do
        (if (== (field_get v 0) left_rec) (do
            ; detected left-recursion
            (field_set v 1 (copy_parser_state (field_get v 1)))
            (field_set v 2 @TRUE)
            ))
        (set_parser_state_all p (field_get v 1))
        return
        ))
    (var loc (get_loc p))
    (var state (copy_parser_state p))
    (noparse state left_rec)

    ; token,state,left-rec detected,parsed
    (var ent (struct 2 left_rec state @FALSE @FALSE))
    (memotable_add tbl sym pos ent)
    (label retry_lbl)
    (byterun (compile_matching loc sym new) p)

    (if (field_get ent 2)
        (if (&& @(PARSED p)
                (> (field_get p 5) (field_get (field_get ent 1) 5)))
            (do
                (field_set ent 0 @(TOKEN p))
                (set_parser_state_all (field_get ent 1) p)
                (set_parser_state_all p state)
                (field_set ent 3 @TRUE)
                (goto retry_lbl)
            )
            (do
                (if (field_get ent 3)
                    (set_parser_state_all p (field_get ent 1))
                    (set_parser_state p (field_get ent 1))
                    )
                return
            )))
    ; not left-recursive
    (field_set ent 0 @(TOKEN p))
    (field_set ent 3 @TRUE)
    (set_parser_state_all (field_get ent 1) p)
    ))

(fun bind_parser (old_parser new_parser) (
    (var state (unique_sym))
    (return (block (list5
        (defvar state (gen_copy_parser_state PVar))
        new_parser
        (mkif (test_parsed) (mkreturn nil))
        (gen_set_parser_state_all PVar state)
        (apply old_parser (list1 PVar))
        )))
    ))

(fun compile_parser_driver (sym sym_) (
    (return (make_expr DefineFunction (list2 sym
        (lambda (make_expr Domain (list2 PVar Parser))
        (apply (to_sym "%call_parser") (list3 PVar (quote sym) sym_))
        ))))
    ))

(export fun compile_define_syntax (sym elems) (
    (var parser_sym (to_parse sym))
    (var parser_sym_ (to_parse_ sym))
    (if (lookup_effective_symbol current_mod parser_sym)
        (do
            (var copy_sym   (unique_sym))
            (var new_parser (compile_parser parser_sym_ elems))
            (var stmts (list3
                ; save existing parser
                (make_expr DefineFunction (list2 copy_sym parser_sym_))
                (make_expr DefineFunction (list2 parser_sym_
                    (make_expr Lambda (list2
                        (make_expr Domain (list2 PVar Parser))
                        (bind_parser copy_sym new_parser)))
                    ))
                (compile_parser_driver parser_sym parser_sym_)
                ))
            (return stmts)
        )
        (do
            (var new_parser (compile_parser parser_sym_ elems))
            (var stmts (list2
                (make_expr DefineFunction (list2 parser_sym_
                    (make_expr Lambda (list2
                        (make_expr Domain (list2 PVar Parser))
                        new_parser))
                    ))
                (compile_parser_driver parser_sym parser_sym_)
                ))
            (return stmts)
        ))
    ))

(export fun init_parser_funcs (mod) (
    (add_builtin_function1 mod (to_sym "%get_loc") (domainP Parser) get_loc 0)
    (add_builtin_function1 mod (to_sym "%get_column") (domainP Parser) get_column 0)
    (add_builtin_function2 mod (to_sym "%set_indent") (domainP Parser) (domainP Int) set_indent 0)
    (add_builtin_function1 mod (to_sym "%alloc_error_state") (domainP Parser) alloc_error_state 0)
    (add_builtin_function2 mod (to_sym "%set_error_state") (domainP Parser) DontCare set_error_state 0)
    (add_builtin_function2 mod (to_sym "%join_error_state") DontCare DontCare join_error_state 0)
    (add_builtin_function1 mod (to_sym "%copy_parser_state") (domainP Parser) copy_parser_state 0)
    (add_builtin_function2 mod (to_sym "%set_parser_state") (domainP Parser) (domainP Parser) set_parser_state 0)
    (add_builtin_function2 mod (to_sym "%set_parser_state_all") (domainP Parser) (domainP Parser) set_parser_state_all 0)
    (add_builtin_function3 mod (to_sym "%call_parser") (domainP Parser) (domainP Symbol) (domainP Function) call_parser 0)

    (add_builtin_function2 mod (to_sym "%negate") (domainP Parser) DontCare negate 0)
    (add_builtin_function3 mod (to_sym "%oneof") (domainP Parser) stringT stringT oneof 0)
    (add_builtin_function3 mod (to_sym "%noneof") (domainP Parser) stringT stringT noneof 0)
    (add_builtin_function1 mod (to_sym "%apply_located") DontCare apply_located 0)
    (add_builtin_function1 mod (to_sym "%eval_parser_command") DontCare eval_parser_command 0)
    (add_builtin_function1 mod (to_sym "%open_scope") DontCare open_scope 0)
    (add_builtin_function1 mod (to_sym "%close_scope") DontCare close_scope 0)
    (add_builtin_function1 mod (to_sym "%get_pos") (domainP Parser) get_pos 0)
    (add_builtin_function3 mod (to_sym "%extract_string")
        (domainP Parser) (domainP Int) (domainP Int) extract_string_ 0)

    (add_parser mod (to_sym "%parse_spaces") parse_spaces)

    (add_builtin_function2 mod (to_sym "parse_text") (domainP Parser) stringT parse_text 0)
    (add_parser mod (to_sym "parse_any_") parse_any_char)
    (add_parser mod (to_sym "parse_blank_") parse_blank_)
    (add_parser mod (to_sym "parse_shell_style_comment_") parse_shell_style_comment_)
    (add_parser mod (to_sym "parse_decimal_") parse_decimal_)
    (add_parser mod (to_sym "parse_binary_") parse_binary_)
    (add_parser mod (to_sym "parse_octal_") parse_octal_)
    (add_parser mod (to_sym "parse_hex_") parse_hex_)
    (add_parser mod (to_sym "parse_integer_") parse_integer_)
    (add_parser mod (to_sym "parse_float_") parse_float_)
    (add_parser mod (to_sym "parse_string_") parse_string_)
    (add_parser mod (to_sym "parse_symbol_") parse_symbol_)
    (add_parser mod (to_sym "parse_atom_") parse_atom_)
    (add_parser mod (to_sym "parse_node_") parse_node_)
    (add_parser mod (to_sym "parse_expr_") parse_expr_)
    (add_parser mod (to_sym "parse_statement_") parse_statement_)

    (add_parser mod (to_sym "parse_any") parse_any_char)
    (add_parser mod (to_sym "parse_blank") parse_blank)
    (add_parser mod (to_sym "parse_shell_style_comment") parse_shell_style_comment)
    (add_parser mod (to_sym "parse_decimal") parse_decimal)
    (add_parser mod (to_sym "parse_binary") parse_binary)
    (add_parser mod (to_sym "parse_octal") parse_octal)
    (add_parser mod (to_sym "parse_hex") parse_hex)
    (add_parser mod (to_sym "parse_integer") parse_integer)
    (add_parser mod (to_sym "parse_float") parse_float)
    (add_parser mod (to_sym "parse_string") parse_string)
    (add_parser mod (to_sym "parse_symbol") parse_symbol)
    (add_parser mod (to_sym "parse_atom") parse_atom)
    (add_parser mod (to_sym "parse_node") parse_node)
    (add_parser mod (to_sym "parse_expr") parse_expr)
    (add_parser mod (to_sym "parse_statement") parse_statement)
    ))

(export fun output_syntax_error (loc e) (
    (output_string stderr "Syntax Error ")
    (pp_loc stderr loc)
    (output_string stderr " : ")
    (output_string stderr e)
    (output_char stderr '\n')
    ))

    ))
