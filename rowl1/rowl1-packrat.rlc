;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-packrat.rlc 2014-04-03 03:21:15 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; character groups
(var CH_EOS        0) ; "\0"
(var CH_SPACES     1) ; "\t\r\n "
(var CH_0          2) ; "0"
(var CH_1          3) ; "1"
(var CH_2_7        4) ; "234567"
(var CH_8_9        5) ; "89"
(var CH_af         6) ; "af"
(var CH_b          7) ; "b"
(var CH_e          8) ; "e"
(var CH_HEX        9) ; "ABCDEFcd"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_OTHER     14) ; "GHIJKLMNOPQRSTUVWXYZcdghijklmpqsuwuz_"
(var CH_SHARP     15) ; "#"
(var CH_INVALID   16)

; end of file
(var EOF -2)

(define CHGRP (c) `(array_get char chgroup @c))
(define PARSED (p) `(== (field_get @p 1) @C_TRUE))
(define PARSED_FLAG (p) `(field_get @p 1))
(define TOKEN (p) `(field_get @p 2))
(define ERROR (p) `(field_get @p 3))
(define CHECK (p) `(if (== (field_get @p 1) @C_FALSE) (do
        (reset_parser_position p state)
        (return @C_FALSE)
        )))

(define MEMOIZE (sym)
    `(export fun @(s++ `parse_ sym) (p) (
        (var s (to_sym @(tos sym)))
        (var tbl (field_get (field_get p 4) 2))
        (var pos (field_get p 6))
        (var v (memotable_find tbl s pos (field_get p 7)))
        (if v (do
            (set_parser_state p (field_get v 0))
            (return @(PARSED_FLAG p))
            ))
        (@(s++ `parse_ sym '_') p)
        (var state (copy_parser_state p))
        (memotable_add tbl s pos (field_get p 7) (struct 1 state @FALSE @FALSE @FALSE))
        (return @(PARSED_FLAG p))
    )))

(define OR (p ps) (do
    (var end_lbl (mklabel))
   `(do
        (do . @(map (lambda (f) 
            `(do
                 (if (== (parse @(tos f) @p) @C_TRUE) (goto @end_lbl))
             )) ps))
        (label @end_lbl)
    )))

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-error")

(array char chgroup (
     0 16 16 16 16 16 16 16 16  1  1 16 16  1 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
     1 16 16 15 16 16 16 16 16 16 16 16 16 16 16 16
     2  3  4  4  4  4  4  4  5  5 16 16 16 16 16 16
    16  9  9  9  9  9  9 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 16 16 16 16 14
    16  6  7  9  9  8  6 14 14 14 14 14 14 14 13 10
    14 14 11 14 11 14 11 14 12 14 14 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    ))

; hashtable for memoization
; key:   (non-terminal symbol, position (integer))
; value: (node, parser state)
;
; structure of tables
;   0 : bucket (array)
;   1 : list of entries
;   2 : number of entries
;   
; structure of entries
;   0 : symbol
;   1 : expr
;   2 : pointer to the next entry
;   3 : pointer to the next entry in entry list
;   4 : position value
;   5 : hash value

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

(fun make_memotable (hint) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (struct 2 (allocate_array size) 0 0))
    ))

(fun memotable_clear (table) (
    (seq_clear (field_get table 0))
    (field_set table 1 0)
    ))

(fun hash (sym pos) (
    (var h (field_get sym @SymbolIndex))
    (var h (field_get sym @SymbolIndex))
    (= h (+ (* 7 h) pos))
    (return h)
    ))

(fun rehash (table) (
    (var old_size (seq_size (field_get table 0)))
    (var num_ent  (field_get table 2))
    (if (>= num_ent old_size) (do
        (var new_size (array_get int prime_numbers (bsr num_ent)))
        (if (! new_size) return)
        (var bucket (allocate_array new_size))
        (var entry (field_get table 1))
        (while entry (do
            (var h (umod (field_get entry 6) new_size))
            (field_set entry 2 (array_get object bucket h))
            (array_set object bucket h entry)
            (= entry (field_get entry 3))
            ))
        (field_set table 0 bucket)
        ))
    ))

(fun memotable_add (table sym pos nl obj) (
    (rehash table)

    (var bucket (field_get table 0))
    (var size (seq_size bucket))
    (var h_orig (hash sym pos))

    (var h (umod h_orig size))
    (var entry (array_get object bucket h))
    (while entry (do
        (if (&& (== (field_get entry 0) sym)
            (&& (== (field_get entry 4) pos)
                (== (field_get entry 5) nl))) (do
            (field_set entry 1 obj)
            return
            ))
        (= entry (field_get entry 2))
        ))

    (var ent (struct 4 sym obj 0 0 pos nl h_orig))
    (field_set ent 2 (array_get object bucket h))
    (array_set object bucket h ent)

    (field_set ent 3 (field_get table 1))
    (field_set table 1 ent)

    (field_set table 2 (+ (field_get table 2) 1))
    ))

(fun memotable_find (table sym pos nl) (
    (var bucket (field_get table 0))
    (var size (seq_size bucket))
    (var h (hash sym pos))
    (= h (umod h size))
    (var entry (array_get object bucket h))
    (while entry (do
        (if (&& (== (field_get entry 0) sym)
            (&& (== (field_get entry 4) pos)
                (== (field_get entry 5) nl)))
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return 0)
    ))

(var utilities null)
(fun apply_util (name args) (do
    (return (apply (quote (get_slot utilities (to_sym name))) args))
    ))

(var nospace_p @FALSE)
(var multiline_p @FALSE)
(var shell_mode_p @FALSE)
(var mayparse_p @FALSE)
(var left_rec (string "Left Recursion Detected"))
(var PVar (to_sym "parser")) ; internal use
(var syntax (to_sym "syntax"))

(extern fun load_global)
(extern fun ary_include)
(extern fun tuple2)

(fun __cons (a b) (
    (return (cons a b))
    ))

(fun __reverse (ls) (
    (return (list_reverse ls))
    ))

(fun __length (ls) (
    (return (box (list_len ls)))
    ))

(fun __lt (x y) ((if (< x y) (return @C_TRUE) (return @C_FALSE))))

(fun trace (obj) (
    (return (block (list2
        (apply (slot Prim (to_sym "print")) (list2 (slot Prim (to_sym "stderr")) obj))
        (apply (slot Prim (to_sym "print")) (list2 (slot Prim (to_sym "stderr")) (string "\n")))
        )))
    ))

(fun syntax_func (name) (
    (return (slot (slot PVar syntax) (to_sym name)))
    ))

(export fun parse (name p) (
    (return (runcode (lookup_func (get_slot p syntax) (to_sym name)) p))
    ))

(export fun parse_success (p) (
    (return @(PARSED p))
    ))
(export fun parsed_token (p) (
    (return @(TOKEN p))
    ))
(export fun parser_error (p) (
    (return @(ERROR p))
    ))

(fun parsed (p val) (
    (field_set p 1 @C_TRUE) ; parsed-flag
    (field_set p 2 val)     ; the token

    ; if column > indentation, current position is not the
    ; beginning of new line.
    (if (> (field_get p 9) (field_get p 10))
        (field_set p 7 @FALSE)
        )

    (return @C_TRUE)
    ))

(fun noparse_sub (p msg quiet may) (
    (field_set p 1 @C_FALSE)

    ; if current position > error position, update error message
    (if (> (field_get p 6) (field_get p 11)) (do
        (= mayparse_p may)
        (if (! quiet) (do
            (field_set p 3 (string msg))
            ; update the error position
            (field_set p 11 (field_get p 6))
            ))
        ))
    (return @C_FALSE)
    ))

(fun noparse (p msg) (
    (return (noparse_sub p msg @FALSE @FALSE))
    ))

(fun mayparse (p msg) (
    (return (noparse_sub p msg @FALSE @TRUE))
    ))

(fun noparse_quite (p) (
    (return (noparse_sub p 0 @TRUE @FALSE))
    ))

(fun mayparse_quiet (p) (
    (return (noparse_sub p 0 @TRUE @TRUE))
    ))

(fun negate (p) (
    (if @(PARSED p)
        (do
            (field_set p 1 @C_FALSE)
            (field_set p 3 (string "unexpected token"))
            (return @C_FALSE)
        )
        (do
            (field_set p 1 @C_TRUE)
            (field_set p 2 @C_NIL)
            (return @C_TRUE)
        ))
    ))

(fun apply_located (p loc) (
    (if @(PARSED p)
        (field_set p 2 (located loc (field_get p 2)))
        )
    (return @(PARSED_FLAG p))
    ))

(fun integer_overflow (p) (
    (return (noparse p "integer literal is too large"))
    ))

(fun junk_letter (p) (
    (return (noparse p "junk letter(s) at the end of integer literal"))
    ))

; structure of parser
;   0: head (ParserE)
;   1: parsed=true, noparse=false
;   2: parsed token
;   3: error message
;   4: (character buffer, input channel, table for memoization)
;   5: filename
;   6: current position in the character buffer
;   7: newline-flag
;   8: line number
;   9: column number
;  10: indentation
;  11: error position

(export fun make_parser (file ichan) (
    ; character buffer
    (var cbuf (make_cvector 0))
    ; current position in cbuf
    (var pos 0)

    ; table for memoization
    (var memo (make_memotable 10))
    (var buf (struct 3 cbuf ichan memo))

    (return (variant @ParserE 5 0 0 0 buf (string file) pos @FALSE 1 1 1 0))
    ))

(fun print_parser_state (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var pos (field_get p 6))
    (var n 100)
    (output_string stderr "input[newline=")
    (output_int stderr (field_get p 7))
    (output_string stderr "]:")
    (while (&& (< pos (cvector_size vec)) (> n 0)) (do
        (output_char stderr (cvector_at vec pos))
        (+= pos 1)
        (-= n 1)
        ))
    (output_string stderr "\n")
    ))

(fun output_escape_sequence (cmd) (
    (output_char stdout 033)    ; ESC
    (output_string stdout cmd)
    (flush stdout)
    ))
(fun consume_char (p vec ichan c) (
    (if (! shell_mode_p) (return (cvector_pushback vec c)))

    (if (== c 0x7f) (do ; DEL
        (var n (cvector_size vec))
        (if (&& (> n 0) (!= (cvector_at vec (- n 1)) '\n')) (do
            (output_escape_sequence "[1D")
            (output_escape_sequence "[0K")
            (cvector_resize vec (- (cvector_size vec) 1))
            ))
        return
        ))

    (if (== c '\f') (do
        (output_escape_sequence "[2J")
        (output_escape_sequence "[1;1H")
        (print_prompt p "> ")
        return
        ))

    (if (== c 033) (do ; ESC
        (var c 0)
        (input_char (address c) ichan) 
        (if (!= c '[') return)
        (input_char (address c) ichan)
        (if (== c 'A') (do
            ; Up
            ))
        (if (== c 'B') (do
            ; Down
            ))
        (if (== c 'C') (do
            ; Right
            ))
        (if (== c 'D') (do
            ; Left
            ))
        return
        ))

    (output_char stdout c)
    (flush stdout)
    (cvector_pushback vec c)
    ))

(fun reserve (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var ichan (field_get buf 1))
    (var line 0)
    (var c 0)
    (if shell_mode_p (unset_canon_mode ichan))
    (while (>= (input_char (address c) ichan) 0) (do
        (consume_char p vec ichan c)
        (if (|| (== c '\n') (== c '\0')) (do
            (if shell_mode_p (restore_termios ichan))
            (return 0)
            ))
        ))
    (if shell_mode_p (restore_termios ichan))
    (return -1)
    ))

(fun lookbehind (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (if (|| (== idx 0) (== (cvector_size vec) 0))
        (return -1)
        )
    (return (cvector_at vec (- idx 1)))
    ))

(fun lookahead (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (if (>= idx (cvector_size vec)) (do
        (if (&& (! shell_mode_p) (< (reserve p) 0))
            (return @EOF)
            )
        ))
    (if (>= idx (cvector_size vec))
        (return -1)
        )
    (return (cvector_at vec idx))
    ))

(export fun end_of_file (p) (
    (return (== (lookahead p) @EOF))
    ))

(fun end_of_file_ (p) (
    (if (end_of_file p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))

(fun lookahead_text (p str) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (var n (cvector_size vec))
    (var i 0)
    
    (while (< idx n) (do
        (var c (array_get uchar str i))
        (if (== c 0) (return @TRUE))
        (if (!= (cvector_at vec idx) c)
            (return @FALSE)
            )
        (+= idx 1)
        (+= i 1)
        ))
    (return @FALSE)
    ))

(fun getc (p) (
    (var c (lookahead p))
    (if (< c 0) (return c))
    ; update source location
    (if (== c '\n') (do
        (if (! shell_mode_p)
            (field_set p 8 (+ (field_get p 8) 1))
            )
        (field_set p 9 0)
        ))
    (field_set p 6 (+ (field_get p 6) 1))
    (field_set p 9 (+ (field_get p 9) 1))
    (return c)
    ))

(fun increment_line (p) (
    (field_set p 8 (+ (field_get p 8) 1))
    ))

(fun reset_memotable (p) (
    (var buf (field_get p 4))
    (memotable_clear (field_get buf 2))
    ))

(export fun reset_parser (p) (
    (var buf (field_get p 4))
    (var cbuf (field_get buf 0))
    (cvector_resize cbuf 0)
    (field_set p 6 0)
    ; reset error info
    (field_set p 3 0)
    (field_set p 11 0)
    (reset_memotable p)
    ))

(fun get_nextchar (p) (
    (var c (lookahead p))
    (if (< c 0)
        (return (to_sym "eof"))
        (return (ctos c))
        )
    ))

(fun copy_parser_state (p) (
    (var copy (variant @ParserE 4 0 0 0 0 0 0 0 0 0 0 0))
    (memcpy copy p (* 12 @WORD_SIZE))
    (return copy)
    ))

(fun set_parser_state (dst src) (
    ; NB: error message, indentation-level and error position must not be copied
    (var msg @(ERROR dst))
    (memcpy dst src (* 10 @WORD_SIZE))
    (field_set dst 3 msg)
    ))

(fun clear_parser_state (p state) (
    (var buf (field_get p 4))
    (set_parser_state p state)
    (memotable_clear (field_get buf 2))
    ))

(fun reset_parser_position (dst src) (
    ; NB: token info and error position must not be copied.
    (memcpy (+ dst (* 4 @WORD_SIZE)) (+ src (* 4 @WORD_SIZE)) (* 7 @WORD_SIZE))
    (return @C_NIL)
    ))

(fun extract_string (p begin end) (
    (var len (- end begin))
    (var vec (field_get (field_get p 4) 0))
    (var str (strndup (+ (cvector_raw vec) begin) len))
    (return str)
    ))

; boxed version
(fun get_input_text (p begin end) (
    (if (|| (! @(UFIX begin)) (! @(UFIX end)))
        (throw (invalid_argument (string "invalid offsets") (tuple2 begin end)))
        )
    (return (extract_string p (unbox begin) (unbox end)))
    ))

(export fun get_pos (p) (
    (return (box (field_get p 6)))
    ))

(fun prompt_string () (
    (var v (load_global (to_sym "PROMPT")))
    (if (!= (node_type v) @StringE)
        (throw (exception1 (string "invalid PROMPT prompt string") v))
        )
    (return v)
    ))

(export fun get_loc (p) (
    (var line (field_get p 8))
    (var clmn (field_get p 9))
    (return (make_loc (field_get p 5) line clmn line clmn))
    ))

(fun get_column (p) (
    (return (box (field_get p 9)))
    ))

; set new indentation-level and return current indentation-level
(fun set_indent (p c) (
    (var current_indent (field_get p 10))
    (field_set p 7 @TRUE)
    (field_set p 10 (unbox c))
    (return (box current_indent))
    ))

(fun check_indent (p) (
    (if (field_get p 7) (return @C_TRUE))
    (if (< (lookahead p) 0) (return @C_TRUE))

    (if (<= (field_get p 9) (field_get p 10))
        (return @C_FALSE)
        (return @C_TRUE)
        )
    ))

; utilities
(export fun is_spaces (c) (
    (return (== @(CHGRP c) @CH_SPACES))
    ))
(export fun is_01 (c) (
    (= c @(CHGRP c))
    (return (|| (== c @CH_0) (== c @CH_1)))
    ))
(export fun is_0_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_8_9)))
    ))
(export fun is_1_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_1 c) (<= c @CH_8_9)))
    ))
(export fun is_0_7 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_2_7)))
    ))
(export fun is_hexdigit (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_HEX)))
    ))
(export fun is_letter (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_af c) (<= c @CH_OTHER)))
    ))
(export fun is_identchar (c) (
    (if (< c 0) (return @FALSE))
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_OTHER)))
    ))
(var escape_chars "'\"\\abfnrtv0")
(fun is_escape_char (c) (
    (for i 0 (strlen escape_chars) (do
        (if (== c (array_get char escape_chars i))
            (return @TRUE)
        )))
    (return @FALSE)
    ))
(fun is_end_of_token (p) (
    (var c (lookahead p))
    (if (< c 0) (return @TRUE))
    (= c @(CHGRP c))
    (return (|| (< c @CH_0) (> c @CH_OTHER)))
    ))

(fun parse_char (p c) (
    (var v (lookahead p))
    (if (< v 0) (do
        (return (mayparse p (strcat "expect token: " (escape_char c))))
        ))
    (if (== v c) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p 
        (strcat "expect " 
        (strcat (escape_char c)
        (strcat " but got " (escape_char v))))))
    ))
 
(fun parse_fail (p) (
    (return (noparse p "Invalid comment syntax"))
    ))

(fun parse_any_char (p) (
    (var c (getc p))
    (if (< c 0)
        (return (mayparse p "end of input stream"))
        (return (parsed p (ctos c)))
        )
    ))

(fun parse_text (p str) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (var n (cvector_size vec))
    (var i 0)
    
    (var clmn (field_get p 9))
    (var line (field_get p 8))
    (while (< idx n) (do
        (var c (cvector_at vec idx))
        (var d (array_get uchar str i))
        (if (== d 0) (do
            (field_set p 6 idx)
            (field_set p 8 line)
            (field_set p 9 clmn)
            (return (parsed p (string str)))
            ))
        (if (!= d c)
            (return (noparse p (strcat "expect token: '" (strcat str "'"))))
            )
        (+= clmn 1)
        (if (== c '\n') (do
            (if (! shell_mode_p) (+= line 1))
            (= clmn 0)
            ))
        (+= idx 1)
        (+= i 1)
        ))
    (return (mayparse p (strcat "expect token: '" (strcat str "'"))))
    ))

(fun parse_word (p sym) (
    (if (is_identchar (lookbehind p))
        (return (noparse p "not beggining of a word"))
        )
    (parse_text p (symbol_name sym))
    (if (! (is_end_of_token p))
        (return (noparse p "not end of a word"))
        )
    (if @(PARSED p)
        (return (parsed p sym))
        (return (noparse p
            (strcat "expect token: '" (strcat (symbol_name sym) "'"))))
        )
    ))

; parse_integers
; multi-precision integer is not supported for now
(extern fun parse_bint)
(extern fun parse_bint_binary)
(extern fun parse_bint_octal)
(extern fun parse_bint_hex)
(fun parse_decimal_ (p) (
    (var sign 1)
    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var v (lookahead p))

    (if (< v 0) (return (mayparse p "expect token: a number")))

    (var state (copy_parser_state p))

    (= v (getc p))
    (if (== v '-') (do
        (= sign -1)
        (= v (getc p))
        ))

    (if (&& (== v '0') (is_end_of_token p))
        (return (parsed p (box 0)))
        )
    (if (! (is_1_9 v)) (do
        (noparse p "expect 1-9")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value (- v '0'))
    (while (is_0_9 (lookahead p)) (do
        (= v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 10))
            (= big_p @TRUE)
            )
        (= value (+ (* value 10) v))
        ))
    (if (is_end_of_token p)
        (if big_p
            (return (parsed p (parse_bint (extract_string p begin (field_get p 6)))))
            (return (parsed p (box (* sign value))))
            )
        )
    (if (== (lookahead p) 'e') (do
        (getc p)
        (parse_decimal p)
        @(CHECK p)
        (var exp (unbox @(TOKEN p)))
        (while (> exp 0) (do
            (if (> value (/ @INTEGER_MAX 10))
                (= big_p @TRUE)
                )
            (*= value 10)
            (-= exp 1)
            ))
        (if big_p
            (return (parsed p (parse_bint (extract_string p begin (field_get p 6)))))
            (return (parsed p (box (* sign value))))
            )
        ))

    (junk_letter p)
    (reset_parser_position p state)
    (return @C_FALSE)
    ))
@(MEMOIZE decimal)

(fun parse_binary_ (p) (
    (if (!= (lookahead p) '0') (return @C_FALSE))

    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var state (copy_parser_state p))

    (getc p)
    (var c (lookahead p))

    (if (&& (!= c 'b') (!= c 'B')) (do
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)

    (if (! (is_01 (lookahead p))) (do
        (noparse p "expect 0 or 1")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_01 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 2))
            (= big_p @TRUE)
            )
        (= value (| (<< value 1) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_binary (extract_string p begin (field_get p 6)) 2)))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE binary)

(fun parse_octal_ (p) (
    (if (!= (lookahead p) '0') (return @C_FALSE))

    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var state (copy_parser_state p))

    (getc p)
    (var c (lookahead p))

    (if (&& (!= c 'o') (!= c 'O')) (do
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)

    (if (== (parse_text p "0o") @C_FALSE) (return @C_FALSE))
    (if (! (is_0_7 (lookahead p))) (do
        (noparse p "expect 0-7")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_0_7 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (>> (- @INTEGER_MAX v) 3))
            (= big_p @TRUE)
            )
        (= value (+ (<< value 3) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_octal (extract_string p begin (field_get p 6)))))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE octal)

(fun parse_hex_ (p) (
    (if (!= (lookahead p) '0') (return @C_FALSE))

    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var state (copy_parser_state p))

    (getc p)
    (var c (lookahead p))

    (if (&& (!= c 'x') (!= c 'X')) (do
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)

    (if (! (is_hexdigit (lookahead p))) (do
        (noparse p "expect hex digit")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_hexdigit (lookahead p)) (do
        (var v (getc p))
        (if (<= 'a' v)
            (= v (+ (- v 'a') 10))
        (if (<= 'A' v)
            (= v (+ (- v 'A') 10))
            (= v (- v '0'))
            ))
        (if (> value (>> (- @INTEGER_MAX v) 4))
            (= big_p @TRUE)
            )
        (= value (+ (<< value 4) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_hex (extract_string p begin (field_get p 6)))))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE hex)

(extern fun float_from_s)
(fun parse_float_ (p) (
    (var begin (field_get p 6))
    (var state (copy_parser_state p))
    (if (== (parse_decimal p) @C_FALSE) (return @C_FALSE))
    (if (!= (lookahead p) '.') (do
        (noparse p "expect '.'")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)
    (if (! (is_0_9 (lookahead p))) (do
        (noparse p "expect digits after the decimal point")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)
    (while (is_0_9 (lookahead p)) (getc p))
    (var c (lookahead p))
    (if (|| (== c 'e') (== c 'E')) (do
        (getc p)
        (if (== (lookahead p) '-') (getc p))
        (if (! (is_0_9 (lookahead p))) (do
            (noparse p (strcat "expect a number: " (ctos (lookahead p))))
            (reset_parser_position p state)
            (return @C_FALSE)
            ))
        (getc p)
        (while (is_0_9 (lookahead p)) (getc p))
        ))
    (return (parsed p (float_from_s (extract_string p begin (field_get p 6)))))
    ))
@(MEMOIZE float)

(fun parse_spaces_oneline_ (p) (
    (var pos (get_pos p))
    (var comment (lookup_func_nocheck (get_slot p syntax) (to_sym "comment")))
    (while @TRUE (do
        (var c (lookahead p))
        (if (< c 0) break)
        (if (&& (is_spaces c) (!= c '\n')) (do
            (getc p)
            continue
            ))
        (if comment (do
            (runcode comment p)
            (if @(PARSED p) continue)
            ))
        break
        ))
    (if (== (get_pos p) pos)
        (return (noparse_quite p))
        (return (parsed p @C_NIL))
        )
    ))
@(MEMOIZE spaces_oneline)

(fun parse_spaces_ (p) (
    (var pos (get_pos p))
    (var comment (lookup_func_nocheck (get_slot p syntax) (to_sym "comment")))
    (while @TRUE (do
        (var c (lookahead p))
        (if (< c 0) break)
        (if (is_spaces c) (do
            (getc p)
            continue
            ))
        (if comment (do
            (runcode comment p)
            (if @(PARSED p) continue)
            ))
        break
        ))
    (if (== (get_pos p) pos)
        (return (noparse_quite p))
        (return (parsed p @C_NIL))
        )
    ))
@(MEMOIZE spaces)

(fun parse_shell_style_comment_ (p) (
    (var v (lookahead p))
    (if (!= v '#') (return (noparse_quite p)))
    (while @TRUE (do
        (var c (lookahead p))
        (if (|| (== c '\n') (< c 0)) break)
        (getc p)
        ))
    (return (parsed p @C_NIL))
    ))
@(MEMOIZE shell_style_comment)

(fun parse_C_style_comment_ (p) (
    (if (! (lookahead_text p "//")) (return @C_FALSE))
    (var v (parse_text p "//"))
    (while @TRUE (do
        (var c (lookahead p))
        (if (|| (== c '\n') (< c 0)) break)
        (getc p)
        ))
    (return (parsed p @C_NIL))
    ))
@(MEMOIZE C_style_comment)

(fun parse_symbol_impl_ (p) (
    (if (is_identchar (lookbehind p))
        (return (noparse p "not beggining of a symbol"))
        )
    (var c (lookahead p))
    (if (< c 0) (return (mayparse p "expect a symbol")))
    (if (! (is_letter c)) (return (noparse p "expect a symbol")))
    (while (is_identchar (lookahead p)) (do
        (getc p)
        ))
    (return (parsed p @C_NIL))
    ))
@(MEMOIZE symbol_impl)

(fun parse_symbol_ (p) (
    (var state (copy_parser_state p))
    (var begin (field_get p 6))
    (parse_symbol_impl p)
    @(CHECK p)
    (var c (lookahead p))
    (if (|| (== c '!') (== c '?')) (getc p))
    (var s (to_sym (extract_string p begin (field_get p 6))))
    (if (is_reserved_word p s) (do
        (noparse p (strcat "reserved symbol: " (symbol_name s)))
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (return (parsed p s))
    ))
@(MEMOIZE symbol)

(fun parse_any_symbol_ (p) (
    (var state (copy_parser_state p))
    (var begin (field_get p 6))
    (parse_symbol_impl p)
    @(CHECK p)
    (var c (lookahead p))
    (if (|| (== c '!') (== c '?')) (getc p))
    (var s (to_sym (extract_string p begin (field_get p 6))))
    (return (parsed p s))
    ))
@(MEMOIZE any_symbol)

(fun parse_identifier_ (p) (
    (var state (copy_parser_state p))
    (var begin (field_get p 6))
    (parse_symbol_impl p)
    @(CHECK p)
    (var c (lookahead p))
    (var s (to_sym (extract_string p begin (field_get p 6))))
    (if (is_reserved_word p s) (do
        (noparse p (strcat "reserved symbol: " (symbol_name s)))
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (return (parsed p s))
    ))
@(MEMOIZE identifier)

; double-quoted string literal
(fun parse_string_d_ (p) (
    (var v (lookahead p))
    (if (< v 0) (return (mayparse p "expect token: \" (double quote)")))
    (if (!= v '"') (return (noparse p "expect token: \" (double quote)")))
    (getc p)
    (var state (copy_parser_state p))
    (var begin (field_get p 6))
    (while (!= (lookahead p) '"') (do
        (var c (getc p))
        (if (< c 0) (do
            (mayparse p "expect character")
            (reset_parser_position p state)
            (return @C_FALSE)
            ))

        (if (== c '\n')
            (return (noparse p "missing terminate character"))
            )
        (if (== c '\\') (do
            (if (! (is_escape_char (getc p))) (do
                (noparse p "invalid escape sequence")
                (reset_parser_position p state)
                (return @C_FALSE)
                ))
            ))
        ))
    (var end (field_get p 6))
    (= v (getc p))
    (if (< v 0) (do
        (mayparse p "expect token: \" (double quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if (!= v '"') (do
        (noparse p "expect token: \" (double quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var str (extract_string p begin end))
    (= str (unescape_string str))
    (return (parsed p str))
    ))
@(MEMOIZE string_d)

(fun parse_fullform_ (p) (
    (var c (lookahead p))
    (if (< c 0) (return (mayparse p "expect token: a symbol")))
    (if (! (is_letter c)) (return (noparse p "expect token: a symbol")))

    (var state (copy_parser_state p))

    (if (== (parse_symbol p) @C_FALSE) (return @C_FALSE))

    (var hd @(TOKEN p))
    (parse_char p '{')
    @(CHECK p)
    (parse_spaces p)

    (var args 0)
    (if (!= (lookahead p) '}') (do
        (while (> (lookahead p) 0) (do
            (parse "expr" p)
            @(CHECK p)
            (= args (cons @(TOKEN p) args))
            (parse_spaces p)
            (if (== (lookahead p) '}') break)
            (parse_char p ',')
            @(CHECK p)
            (parse_spaces p)
            ))
        ))
    (parse_char p '}')
    @(CHECK p)
    (parsed p (make_node hd (list_reverse args)))
    (return @C_TRUE)
    ))
@(MEMOIZE fullform)

(fun parse_integer_ (p) (
    @(OR p `(
        decimal
        hex
        octal
        binary
        ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE integer)

(fun parse_atom_ (p) (
    @(OR p `(
        symbol
        float
        integer
        string
    ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE atom)

(fun parse_expr_ (p) (
    @(OR p `(
        fullform
        atom
    ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE expr)

(fun parse_stmt_ (p) (
    (return (parse "expr" p))
    ))
@(MEMOIZE stmt)

(export fun parse_toplevel (p) (
    (parse_toplevel_stmt p)
    (return @(PARSED_FLAG p))
    ))

(fun parse_toplevel_stmt_ (p) (
    (return (parse "stmt" p))
    ))

(fun parse_toplevel_stmt (p) (
    (parse_spaces p)
    (set_indent p (get_column p))
    (var loc (get_loc p))
    (parse "toplevel_stmt" p)
    (if (! @(PARSED p)) (return @C_NIL))
    (apply_located p loc)
    (var stmt @(TOKEN p))

    (parse_spaces_oneline p)
    (if (== (parse_char p '\n') @C_FALSE) (return @C_NIL))

    (parsed p stmt)
    (reset_memotable p)
    (return @C_NIL)
    ))

(fun print_prompt (p sign) (
    (var line (field_get p 8))
    (output_string stdout (prompt_string))
    (output_char stdout ':')
    (output_int stdout line)
    (output_string stdout sign)
    (flush stdout)
    ))

(export fun parse_shell (p) (
    (var save_shell_mode_p shell_mode_p)
    (= shell_mode_p @TRUE)
    (var buf (field_get p 4))
    (var ichan (field_get buf 1))
    (parse_shell_stmt p)
    (= shell_mode_p save_shell_mode_p)
    (if @(PARSED p) (increment_line p))
    (return @(PARSED_FLAG p))
    ))

(fun parse_shell_stmt (p) (
    (print_prompt p "> ")
    (reserve p)
    (var state (copy_parser_state p))
    (while @TRUE (do
        (= mayparse_p @FALSE)
        (parse_toplevel_stmt p)
        (if (|| @(PARSED p) (! mayparse_p)) return)

        (clear_parser_state p state)
        (print_prompt p "~ ")
        (reserve p)
        ))
    ))

(fun make_nodevar (idx) (
    (return (to_sym (strcat "node" (itos10 idx))))
    ))

(fun gen_copy_parser_state () (
    (return (apply_util "%copy_parser_state" (list1 PVar)))
    ))
(fun gen_reset_parser_position (dst src) (
    (return (apply_util "%reset_parser_position" (list2 dst src)))
    ))
(fun gen_set_parser_state (dst src) (
    (return (apply_util "%set_parser_state" (list2 dst src)))
    ))

(fun gen_parsed (v) (
    (return (apply_util "%parsed" (list2 PVar v)))
    ))

(fun gen_noparse (v) (
    (return (apply_util "%noparse" (list2 PVar v)))
    ))

(fun gen_parse_spaces () (
    (return (apply (syntax_func "spaces") (list1 PVar)))
    ))

(fun gen_get_token () (
    (return (make_node2 FieldRef PVar (box 2)))
    ))

(fun gen_get_error () (
    (return (make_node2 FieldRef PVar (box 3)))
    ))

(fun gen_test_parsed () (
    (return (make_node2 FieldRef PVar (box 1)))
    ))

(fun gen_test_noparse () (
    (return (make_node1 Not (gen_test_parsed)))
    ))

; Run given parser and do tests.
; If ws == true and !nospace_p, parse spaces between running the parser.
; If !multiline_p, indentation-level is checked.
(fun parse_with_check (p ws) (
    (if (! multiline_p)
        (= p (ifelse (apply_util "%check_indent" (list1 PVar))
                p
                (gen_noparse (string "Invalid indentation"))))
        )

    (if (&& ws (! nospace_p))
        (do
            (var code 0)
            (var state (to_unique_sym "state"))
            (= code (cons (defvar state (gen_copy_parser_state)) code))
            (= code (cons (gen_parse_spaces) code))
            (= code (cons p code))
            (= code (cons (mkif (gen_test_noparse)
                (gen_reset_parser_position PVar state)) code))
            (return (seq (list_reverse code)))
        ))
    (return p)
    ))

(fun is_reserved_word (p sym) (
    (var stx (get_slot_nocheck p syntax))
    (if (== stx @C_NIL) (return @FALSE))
    (var reserved_words (get_slot_nocheck stx (to_sym "reserved_words")))
    (if (== reserved_words @C_NIL) (return @FALSE))
    (if (!= (node_type reserved_words) @ArrayE)
        (throw (logic_error (string "'reserved_words' must be an array of symbols")))
        )
    (return (!= (ary_include reserved_words sym) @C_FALSE))
    ))

(fun compile_parser_element (pat ws) (
    (var hd (node_head pat))
    (if (== hd (to_sym "Word")) (do
        (return (parse_with_check
            (apply_util "%parse_word" (list2 PVar
                (quote (node_arg_symbol pat 0)))) ws))
        ))
    (if (== hd Symbol) (do
        (return (parse_with_check
            (apply (slot (slot PVar syntax) pat) (list1 PVar)) ws))
        ))
    (if (== hd Slot) (do
        (return (parse_with_check (apply pat (list1 PVar)) ws))
        ))
    (if (== hd String)
        (return (parse_with_check
            (apply_util "%parse_text" (list2 PVar pat)) ws)))
    (if (== hd List)
        (return (compile_seq pat ws))
        )
    (if (== hd Choice)
        (return (compile_choice pat ws))
        )
    (var len (node_size pat))
    (if (== hd Delimited) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited0 (node_arg pat 0) (node_arg pat 1) ws))
        ))
    (if (== hd Delimited1) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (node_arg pat 0) (node_arg pat 1) 1 ws))
        ))
    (if (== hd Delimited2) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (node_arg pat 0) (node_arg pat 1) 2 ws))
        ))
    (if (== hd ParseWith) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_parse_with (node_arg pat 0) (node_arg pat 1)ws))
        ))
    (if (!= len 1) (goto compile_error))
    (if (== hd OneOf)
        (return (compile_oneof (node_arg pat 0) ws))
        )
    (if (== hd NoneOf)
        (return (compile_noneof (node_arg pat 0) ws))
        )
    (if (== hd Many)
        (return (compile_many (node_arg pat 0) ws))
        )
    (if (== hd Many1)
        (return (compile_many1 (node_arg pat 0) ws))
        )
    (if (== hd Option)
        (return (compile_option (node_arg pat 0) ws))
        )
    (if (== hd And)
        (return (compile_and (node_arg pat 0) ws))
        )
    (if (== hd Not)
        (return (compile_not (node_arg pat 0) ws))
        )
    (if (== hd Aligned)
        (return (compile_aligned (node_arg pat 0) ws))
        )
    (if (== hd NoSpace)
        (return (compile_nospace (node_arg pat 0) ws))
        )
    (label compile_error)
    (throw (exception (list2 (string "invalid syntax element") pat)))
    ))

(fun oneof (p tbl str) (
    (var c (lookahead p))
    (if (< c 0)
        (return (mayparse p (strcat "expect token: one of " str)))
        )
    (if (array_get char tbl c) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p
        (strcat "expect one of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun noneof (p tbl str) (
    (var c (lookahead p))
    (if (< c 0)
        (return (mayparse p (strcat "expect token: none of " str)))
        )
    (if (! (array_get char tbl c)) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p
        (strcat "expect token: none of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun compile_character_set (str) (
    (var tbl (allocate_string 128))
    (var len (strlen str))
    (var i 0)
    (while (< i len) (do
        (var c (array_get char str i))
        (if (== c '\\') (do ; escaped char
            (+= i 1)
            (if (== i len) (goto error))
            (= c (array_get char str i))
            (if (== c 'a') (array_set char tbl '\a' 1)
            (if (== c 'b') (array_set char tbl '\b' 1)
            (if (== c 'f') (array_set char tbl '\f' 1)
            (if (== c 'n') (array_set char tbl '\n' 1)
            (if (== c 'r') (array_set char tbl '\r' 1)
            (if (== c 't') (array_set char tbl '\t' 1)
            (if (== c 'v') (array_set char tbl '\v' 1)
            (if (== c '0') (array_set char tbl '\0' 1)
                (array_set char tbl c 1)
                ))))))))
            (+= i 1)
            continue
            ))
        (if (&& (is_identchar c) (== (array_get char str (+ i 1)) '-')) (do
            (if (>= (+ i 2) len) (goto error))
            (var d (array_get char str (+ i 2)))
            (if (> c d) (goto error))
            (while (<= c d) (do
                (array_set char tbl c 1)
                (+= c 1)
                ))
            (+= i 3)
            continue
            ))
        (array_set char tbl c 1)
        (+= i 1)
        ))
    (return tbl)
    (label error)
    (throw (invalid_argument (string "invalid character-set") str))
    ))

(fun compile_oneof (str ws) (
    (var tbl (compile_character_set str))
    (return (parse_with_check
        (apply_util "%oneof" (list3 PVar tbl str)) ws))
    ))

(fun compile_noneof (str ws) (
    (var tbl (compile_character_set str))
    (return (parse_with_check
        (apply_util "%noneof" (list3 PVar tbl str)) ws))
    ))

; List{ p1, p2, ...} is translated to
;
; breakable {
;   ret = []
;   p1
;   if (noparse) break 
;   ret = cons(token(), ret)
;   p2 (with spaces)
;   if (noparse) break
;   ret = cons(token(), ret)
;   ...
;   Parsed{reverse(ret)}

(fun compile_seq (elems ws) (
    (if (! elems)
        (throw (exception (string "[] is not valid syntax element")))
        )

    (var body 0)
    (var ret (to_unique_sym "ret"))
    (= body (cons (defvar ret 0) body))
    (while elems (do
        (= body (cons (compile_parser_element (car elems) ws) body))
        (= body (cons (mkif (gen_test_noparse) (make_node0 Break)) body))
        (= ws @TRUE)
        (= body (cons (assign ret (apply_util "%cons" (list2 (gen_get_token) ret))) body))
        (= elems (cdr elems))
        ))
    (= body (cons (gen_parsed (apply_util "%reverse" (list1 ret))) body))
    (return (breakable (list_reverse body)))
    ))

; Choice{ p1, p2, .. } is translated to
; breakable {
;     p1
;     if (parsed) break
;     p2
;     if (parsed) break
;     ...
; }

(fun compile_choice (ps ws) (
    (if (< (node_size ps) 2)
        (throw (unexpected_error (string "require more than 1 arguments") ps)))

    (var body 0)
    (rfor i 0 (node_size ps) (do
        (= body (cons (compile_parser_element (node_arg ps i) ws) body))
        (= body (cons (mkif (gen_test_parsed) (make_node0 Break)) body))
        ))

    (return (breakable (list_reverse body)))
    ))

; Many{ p } is translated to
;
; elems = []
; breakable {
;    p
;    if noparse break
;    elems = cons(token(), elems)
;    while true {
;        p (with spaces)
;        if noparse break
;        elems = cons(token(), elems)
;    }
; }
; Parsed{reverse(elems)}

(fun compile_many (elem ws) (
    (var elems (to_unique_sym "elems"))

    (var loop_body 0)
    (= loop_body (cons (compile_parser_element elem @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (compile_parser_element elem ws) body))
    (= body (cons (mkif (gen_test_noparse) (make_node0 Break)) body))
    (= body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) body))
    (= body (cons (make_node2 While @C_TRUE
        (block (list_reverse loop_body))) body))

    (return (block (list3
        (defvar elems 0)
        (breakable (list_reverse body))
        (gen_parsed (apply_util "%reverse" (list1 elems)))
        )))
    ))

; Many1{ p } is translated to
;
; breakable {
;    elems = []
;    p
;    if noparse break
;    elems = cons(token(), elems)
;    while true {
;        p (with spaces)
;        if noparse break
;        elems = cons(token(), elems)
;    }
;    Parsed{reverse(elems)}
; }

(fun compile_many1 (elem ws) (
    (var elems (to_unique_sym "elems"))

    (var loop_body 0)
    (= loop_body (cons (compile_parser_element elem @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (compile_parser_element elem ws) body))
    (= body (cons (mkif (gen_test_noparse) (make_node0 Break)) body))
    (= body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) body))
    (= body (cons (make_node2 While @C_TRUE
        (block (list_reverse loop_body))) body))
    (= body (cons (gen_parsed (apply_util "%reverse" (list1 elems))) body))
    (return (breakable (list_reverse body)))
    ))

; Aligned{ p } is translated to
;
; breakable {
;     elems = []
;     state = copy_parser_state(..)
;     column = get_column(p)
;     set_indent(p, column)
;     run p
;     if (noparse) {
;         reset_parser_position(p, state)
;         parsed([])
;         break
;     }
;     while true {
;         elems = cons(token(), elems)
;         set_parser_state(state, p)
;         parse_spaces()
;         if (get_column(p) != column) {
;             break
;         }
;         set_indent(p, column)
;         run p
;         if (noparse) {
;             break
;         }
;     }
;     reset_parser_position(p, state)
;     reset_indent(p)
;     parsed(reverse(elems))
; }

(fun compile_aligned (elem ws) (
    (var state (to_unique_sym "state"))
    (var elems (to_unique_sym "elems"))
    (var clmn  (to_unique_sym "clmn "))
    (var indent_save (to_unique_sym "indent_save"))

    (var loop_body 0)
    (= loop_body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (gen_parse_spaces) loop_body))
    (= loop_body (cons (mkif 
            (make_node2 NotEqual
                (apply_util "%get_column" (list1 PVar))
                clmn
                )
            (make_node0 Break)) loop_body))
    (= loop_body (cons (apply_util "%set_indent" (list2 PVar clmn)) loop_body))
    (= loop_body (cons (compile_parser_element elem @FALSE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))

    (if (|| ws (! nospace_p))
        (= body (cons (gen_parse_spaces) body))
        )

    (= body (cons (defvar clmn (apply_util "%get_column" (list1 PVar))) body))
    (= body (cons (defvar indent_save (apply_util "%set_indent" (list2 PVar clmn))) body))
    (= body (cons (compile_parser_element elem @FALSE) body))
    (= body (cons (mkif (gen_test_noparse)
            (block (list3
                (gen_reset_parser_position PVar state)
                (gen_parsed 0)
                (make_node0 Break)
            )))
        body))
    (= body (cons (make_node2 While @C_TRUE
            (block (list_reverse loop_body))) body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (apply_util "%set_indent" (list2 PVar indent_save)) body))
    (= body (cons (gen_parsed (apply_util "%reverse" (list1 elems))) body))
    (return (breakable (list_reverse body)))
    ))

; Delimited{ p, delim } is translated to
;
; breakable {
;     elems = []
;     state = copy_parser_state(..)
;     run p
;     if noparse {
;         reset_parser_position(..)
;         parsed([])
;         break
;     }
;     elems = cons(token(), elems)
;     while true {
;         set_parser_state(state, p)
;         run delim (with spaces)
;         if noparse break
;         run p (with spaces)
;         if noparse break
;         elems = cons(token(), elems)
;     }
;     reset_parser_position(p, state)
;     parsed(reverse(elems))
; }

(fun compile_delimited0 (p delim ws) (
    (var state (to_unique_sym "state"))
    (var elems (to_unique_sym "elems"))

    (var loop_body 0)
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (compile_parser_element delim @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (compile_parser_element p @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (= body (cons (compile_parser_element p ws) body))
    (= body (cons (mkif (gen_test_noparse)
        (block (list3
            (gen_reset_parser_position PVar state)
            (gen_parsed 0)
            (make_node0 Break)
            ))) body))
    (= body (cons
        (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) body))
    (= body (cons
        (make_node2 While @C_TRUE (block (list_reverse loop_body)))
        body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (gen_parsed (apply_util "%reverse" (list1 elems)))
            body))
    (return (breakable (list_reverse body)))
    ))

(fun compile_delimited (p delim minlen ws) (
    (var state (to_unique_sym "state"))
    (var elems (to_unique_sym "elems"))

    (var loop_body 0)
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (compile_parser_element delim @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (compile_parser_element p @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_node0 Break)) loop_body))
    (= loop_body (cons (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (= body (cons (compile_parser_element p ws) body))
    (= body (cons (mkif (gen_test_noparse) (block (list2
        (gen_noparse (string "The number of elements is insufficient"))
        (make_node0 Break)
        ))) body))
    (= body (cons
        (assign elems (apply_util "%cons" (list2 (gen_get_token) elems))) body))
    (= body (cons
        (make_node2 While @C_TRUE (block (list_reverse loop_body)))
        body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (mkif
        (apply_util "%less_than"
            (list2 (apply_util "%length" (list1 elems))
                (box minlen))) (block (list2
        (gen_noparse (string "The number of elements is insufficient"))
        (make_node0 Break)
        ))) body))
    (= body (cons (gen_parsed (apply_util "%reverse" (list1 elems)))
            body))
    (return (breakable (list_reverse body)))
    ))

; parsewith{ stx, elem }
;
; save_stx: parser.stx
; parser.stx = stx
; v: nil
; try
;   v = stx.elem(parser)
; catch e -> {
;     parser.stx = save_stx
;     throw e
; }
; v

(fun compile_parse_with (expr0 expr1 ws) (
    (var stx (to_unique_sym "stx"))
    (var save_stx (to_unique_sym "save_stx"))
    (var field (to_unique_sym "field"))
    (var v (to_unique_sym "v"))
    (var e (to_unique_sym "e"))
    (var body 0)
    (= body (cons (defvar stx expr0) body))
    (= body (cons (defvar save_stx (slot PVar syntax)) body))
    (= body (cons (assign (slot PVar syntax) stx) body))
    (= body (cons (defvar v @C_NIL) body))
    (= body (cons (make_node2 Try
        (assign v (apply (apply_util "%get_slot" (list2 stx expr1)) (list1 PVar)))
        (lambda (list1 e) (block (list2
            (assign (slot PVar syntax) save_stx)
            (make_node1 Throw e)
            )))
        ) body))
    (= body (cons (assign (slot PVar syntax) save_stx) body))
    (= body (cons v body))
    (return (parse_with_check (block (list_reverse body)) ws))
    ))

; Option{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; if (head(v) == NoParse) {
;   reset_parser_position(parser, state)
;   nil
; } else
;   Parsed{loc(v), Some{val(v)}}
(fun compile_option (p ws) (
    (var state (to_unique_sym "state"))
    (return (block (list3
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (ifelse
            (gen_test_noparse)
            (block (list2
                (gen_reset_parser_position PVar state)
                (gen_parsed @C_NIL)
                ))
            (gen_parsed (qquote (make_node1 Some (unquote (gen_get_token)))))
            ))))
    ))

; And{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; reset_parser_position(parser, state)
; v
(fun compile_and (p ws) (
    (var state (to_unique_sym "state"))
    (return (block (list3
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (gen_reset_parser_position PVar state)
        )))
    ))

; Not{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; reset_parser_position(parser, state)
; negate(v,p)
(fun compile_not (p ws) (
    (var state (to_unique_sym "state"))
    (return (block (list4
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (gen_reset_parser_position PVar state)
        (apply_util "%negate" (list1 PVar))
        )))
    ))

(fun compile_nospace (elem ws) (
    (var save_nospace_p nospace_p)
    (= nospace_p @TRUE)
    (var p (compile_parser_element elem @FALSE))
    (= nospace_p save_nospace_p)
    (return p)
    ))

(fun compile_parser_action (elems act) (
    (if (!= (node_head elems) List)
        (= elems (list1 elems))
        )

    (var idx 0)
    (var body 0)
    (var bpos (to_unique_sym "bpos"))

    (= body (cons (defvar bpos (apply_util "%get_pos" (list1 PVar))) body))

    (var with_spaces @FALSE)
    (while elems (do
        (var ndvar (make_nodevar idx))
        (= body (cons (compile_parser_element (car elems) with_spaces) body))

        (if (! nospace_p) (= with_spaces @TRUE))

        (= body (cons (mkif (gen_test_noparse) (make_node0 Break)) body))
        (= body (cons (defvar ndvar (gen_get_token)) body))
        (incr idx)
        (= elems (cdr elems))
        ))

    (= body (cons (defvar (to_sym "begin") bpos) body))
    (= body (cons (defvar (to_sym "end")
        (apply_util "%get_pos" (list1 PVar))) body))

    (= body (cons (gen_parsed act) body))
    (return (breakable (list_reverse body)))
    ))

(var multiline (to_sym "multiline"))
(fun setup_options (opts) (
    (if (!= (node_head opts) List)
        (= opts (list1 opts))
        )
    (while opts (do
        (var opt (car opts))
        (if (== opt multiline)
            (= multiline_p @TRUE)
            (throw (unexpected_error (string "unknown parser option") opt)))
        (= opts (cdr opts))
        ))
    ))

(fun clear_options () (
    (= nospace_p @FALSE)
    (= multiline_p @FALSE)
    ))

(var idx 0)
(fun compile_parser (elems) (
    (if (!= (node_head elems) List)
        (= elems (list1 elems))
        )
    (+= idx 1)

    (var body 0)
    (var state (to_unique_sym "state"))
    (var error (to_unique_sym "error"))

    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (while elems (do
        (var t (car elems))
        (var size (node_size t))
        (if (|| (!= (node_head t) Tuple) (|| (< size 2) (> size 3))) (do
            (throw (unexpected_error 
                (string "Entries of syntax definition must be form of (parser, action, [options])")
                t))
            ))
        (if (== size 3)
            (setup_options (node_arg t 2))
            )

        (var act (compile_parser_action (node_arg t 0) (node_arg t 1)))
        (= body (cons act body))
        (= body (cons (mkif (gen_test_parsed) (make_node0 Break)) body))
        (= body (cons (gen_reset_parser_position PVar state) body))
        (= elems (cdr elems))
        (clear_options)
        ))
    (return (lambda (list1 PVar) (breakable (list_reverse body))))
    ))

(extern fun compile_matching)
(fun call_parser (p sym key fun) (
    (var tbl (field_get (field_get p 4) 2))
    (var pos (field_get p 6))
    (var v (memotable_find tbl key pos (field_get p 7)))
    (if v (do
        (if (field_get v 1) (do
            ; detected left-recursion
            (field_set v 0 (copy_parser_state (field_get v 0)))
            (field_set v 2 @TRUE)
            ))
        (set_parser_state p (field_get v 0))
        (return @(PARSED_FLAG p))
        ))
    (var loc (get_loc p))
    (var state (copy_parser_state p))
    (noparse state left_rec)

    ; state,possibly left-recursive,left-rec detected,parsed
    (var ent (struct 1 state @TRUE @FALSE @FALSE))
    (memotable_add tbl key pos (field_get p 7) ent)
    (label retry_lbl)
    (runcode (compile_matching sym fun) p)

    (if (field_get ent 2)
        (if (&& @(PARSED p)
                (> (field_get p 6) (field_get (field_get ent 0) 6)))
            (do
                (set_parser_state (field_get ent 0) p)
                (set_parser_state p state)
                (field_set ent 3 @TRUE)
                (goto retry_lbl)
            )
            (do
                (if (field_get ent 3)
                    (set_parser_state p (field_get ent 0))
                    (reset_parser_position p (field_get ent 0))
                    )
                (return @(PARSED_FLAG p))
            )))
    ; not left-recursive
    (field_set ent 3 @TRUE)
    (set_parser_state (field_get ent 0) p)
    (return @(PARSED_FLAG p))
    ))

(var key_idx 0)
(export fun transl_define_syntax (expr) (
    (var lhs (node_arg expr 0))
    (var elems (node_arg expr 1))
    (var key (to_unique_sym (strcat "%key" (itos10 key_idx))))
    (var parser_body (compile_parser elems))
    (var parser (apply_util "%call_parser"
            (list4 PVar (quote lhs) (quote key) parser_body)))
    (+= key_idx 1)
    (if (!= (node_head lhs) Slot)
        (= lhs (slot Syntax lhs))
        )
    (return (make_node3 Define lhs (lambda_nocheck (make_node2 When (list1 (make_node2 Domain PVar Parser)) parser) @C_TRUE) (to_sym "fusion")))
    ))

(export fun enable_shell_syntax () (
    (call0 (to_sym "enable_shell_syntax"))
    ))

(fun add_parser (mod sym func) (
    (add_function1 mod sym (domainP Parser) func 0)
    ))

(fun make_parser_ (io) (
    (return (make_parser (field_get io 1) (field_get io 2)))
    ))

(extern fun create_module)
(export fun init_parser_funcs (mod) (
    (= utilities (create_module (to_unique_sym "%ParserUtilities")))
    (add_function1 utilities (to_sym "%get_column") DontCare get_column 0)
    (add_function2 utilities (to_sym "%set_indent") DontCare DontCare set_indent 0)
    (add_function1 utilities (to_sym "%check_indent") DontCare check_indent 0)
    (add_function1 utilities (to_sym "%get_loc") (domainP Parser) get_loc 0)
    (add_function2 utilities (to_sym "%parsed") DontCare DontCare parsed 0)
    (add_function2 utilities (to_sym "%noparse") DontCare DontCare noparse 0)
    (add_function1 utilities (to_sym "%copy_parser_state") DontCare copy_parser_state 0)
    (add_function2 utilities (to_sym "%reset_parser_position") DontCare DontCare reset_parser_position 0)
    (add_function2 utilities (to_sym "%set_parser_state") DontCare DontCare set_parser_state 0)
    (add_function1 utilities (to_sym "%print_parser_state") DontCare print_parser_state 0)
    (add_function4 utilities (to_sym "%call_parser") DontCare DontCare DontCare DontCare call_parser 0)
    (add_function1 utilities (to_sym "%negate") DontCare negate 0)
    (add_function3 utilities (to_sym "%oneof") DontCare DontCare DontCare oneof 0)
    (add_function3 utilities (to_sym "%noneof") DontCare DontCare DontCare noneof 0)
    (add_function1 utilities (to_sym "%get_pos") DontCare get_pos 0)
    (add_function2 utilities (to_sym "%cons") DontCare DontCare __cons 0)
    (add_function1 utilities (to_sym "%reverse") DontCare __reverse 0)
    (add_function1 utilities (to_sym "%length") DontCare __length 0)
    (add_function2 utilities (to_sym "%less_than") intT intT __lt 0)

    (add_function2 utilities (to_sym "%parse_text") (domainP Parser) stringT parse_text 0)
    (add_function2 utilities (to_sym "%parse_word") (domainP Parser) symT parse_word 0)
    (add_function2 utilities (to_sym "%get_slot") DontCare symT get_slot 0)

    (add_parser mod (to_sym "parse_char") parse_char)
    (add_parser mod (to_sym "parse_char") parse_char)
    (add_parser mod (to_sym "parse_any") parse_any_char)
    (add_parser mod (to_sym "parse_comment") parse_fail)
    (add_parser mod (to_sym "parse_spaces") parse_spaces)
    (add_parser mod (to_sym "parse_decimal") parse_decimal)
    (add_parser mod (to_sym "parse_binary") parse_binary)
    (add_parser mod (to_sym "parse_octal") parse_octal)
    (add_parser mod (to_sym "parse_hex") parse_hex)
    (add_parser mod (to_sym "parse_integer") parse_integer)
    (add_parser mod (to_sym "parse_float") parse_float)
    (add_parser mod (to_sym "parse_string") parse_string_d)
    (add_parser mod (to_sym "parse_symbol") parse_symbol)
    (add_parser mod (to_sym "parse_identifier") parse_identifier)
    (add_parser mod (to_sym "parse_any_symbol") parse_any_symbol)
    (add_parser mod (to_sym "parse_atom") parse_atom)
    (add_parser mod (to_sym "parse_fullform") parse_fullform)
    (add_parser mod (to_sym "parse_expr") parse_expr)
    (add_parser mod (to_sym "parse_stmt") parse_stmt)
    (add_parser mod (to_sym "parse_toplevel_stmt") parse_toplevel_stmt_)

    (add_function1 mod (to_sym "lookahead") (domainP Parser) get_nextchar 0)
    (add_function3 mod (to_sym "input_text") (domainP Parser) intT intT get_input_text 0)

    (add_parser mod (to_sym "parse_shell_style_comment") parse_shell_style_comment)
    (add_parser mod (to_sym "parse_C_style_comment") parse_C_style_comment)

    (add_function1 mod (to_sym "parser_new") (domainP InputFileStream) make_parser_ 0)
    (add_function1 mod (to_sym "parse_shell") (domainP Parser) parse_shell 0)
    (add_function1 mod (to_sym "parse_toplevel") (domainP Parser) parse_toplevel 0)
    (add_function1 mod (to_sym "parser_tree") (domainP Parser) parsed_token 0)
    (add_function1 mod (to_sym "parser_error") (domainP Parser) parser_error 0)
    (add_function1 mod (to_sym "parser_loc") (domainP Parser) get_loc 0)
    (add_function1 mod (to_sym "parser_reset") (domainP Parser) reset_parser 0)
    (add_function1 mod (to_sym "parser_eof?") (domainP Parser) end_of_file_ 0)
    ))

(export fun output_syntax_error (loc e) (
    (pp_loc stderr loc)
    (output_string stderr " Syntax Error: ")
    (output_string stderr e)
    (output_char stderr '\n')
    ))

    ))
