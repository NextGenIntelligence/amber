;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-packrat.rlc 2012-04-18 23:44:25 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; character groups
(var CH_EOS        0) ; "\0"
(var CH_SPACES     1) ; "\t\r\n "
(var CH_0          2) ; "0"
(var CH_1          3) ; "1"
(var CH_2_7        4) ; "234567"
(var CH_8_9        5) ; "89"
(var CH_af         6) ; "af"
(var CH_b          7) ; "b"
(var CH_e          8) ; "e"
(var CH_HEX        9) ; "ABCDEFcd"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_OTHER     14) ; "GHIJKLMNOPQRSTUVWXYZcdghijklmpqsuwuz_"
(var CH_SHARP     15) ; "#"
(var CH_INVALID   16)

; fixed-length integers are 31-bits because of boxing
(var INTEGER_MAX  (- (<< 1 30) 1))

; end of file
(var EOF -2)

(define CHGRP (c) `(array_get char chgroup @c))
(define MEMOIZE (sym)
    `(export fun @(s++ `parse_ sym) (p) (
        (var s (to_sym (strcat "parse_" @(tos sym))))
        (var tbl (field_get (field_get p 1) 2))
        (var pos (field_get p 3))
        (var v (memotable_find tbl s pos))
        (if v (do
            (set_parser_state p (cdr v))
            (return (car v))
            ))
        (= v (@(s++ `parse_ sym '_') p))
        (var state (copy_parser_state p))
        (memotable_add tbl s pos (cons v state))
        (return v)
    )))

(define OR (p ps) (do
    (var end_lbl (mklabel))
   `(do
        (var state (copy_parser_state @p))
        (var v 0)
        (var errors 0)
        (do . @(map (lambda (f) 
            `(do
              (= v (@(s++ `parse_ f) @p))
              (if (== (expr_head v) Parsed) (goto @end_lbl))
              (= errors (merge_noparse errors v))
              (set_parser_state @p state)
             )) ps))
        (= v errors)
        (label @end_lbl)
        v
    )))
(define CHECK (v) `(if (== (expr_head @v) NoParse) (return @v)))

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-module")

(array char chgroup (
     0 16 16 16 16 16 16 16 16  1  1 16 16  1 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
     1 16 16 15 16 16 16 16 16 16 16 16 16 16 16 16
     2  3  4  4  4  4  4  4  5  5 16 16 16 16 16 16
    16  9  9  9  9  9  9 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 16 16 16 16 14
    16  6  7  9  9  8  6 14 14 14 14 14 14 14 13 10
    14 14 11 14 11 14 11 14 12 14 14 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    ))

; hashtable for memoization
; key:   (non-terminal symbol, position (integer))
; value: expression
;
; structure of tables
;   0 : bucket (vector)
;   1 : entries (vector)
;   
; structure of entries
;   0 : symbol
;   1 : expression
;   2 : pointer to the next entry
;   3 : position value
;   4 : hash value

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

(fun make_memotable (hint) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (struct 2 (make_vector size) (make_vector 0)))
    ))

(fun memotable_clear (table) (
    (vector_clear (field_get table 0))
    (vector_resize (field_get table 1) 0)
    ))

(fun hash (sym pos) (
    (var h (field_get sym @SymbolIndex))
    (= h (+ (* 7 h) pos))
    (return h)
    ))

(fun rehash (table) (
    (var old_size (vector_size (field_get table 0)))
    (var num_ent  (vector_size (field_get table 1)))
    (if (>= num_ent old_size) (do
        (var new_size (array_get int prime_numbers (bsr num_ent)))
        (if (! new_size) (error "rehash: too many entries"))
        (var bucket (make_vector new_size))
        (var entries (field_get table 1))
        (for i 0 (vector_size entries) (do
            (var entry (vector_at entries i))
            (if (! entry) continue)
            (var h (% (field_get entry 4) new_size))
            (field_set entry 2 (vector_at bucket h))
            (vector_put bucket h entry)
            ))
        (field_set table 0 bucket)
        ))
    ))

(fun memotable_add (table sym pos obj) (
    (rehash table)

    (var bucket (field_get table 0))
    (var entries (field_get table 1))
    (var size (vector_size bucket))
    (var h (hash sym pos))

    (var ent (struct 3 sym obj 0 pos h))
    (%= h size)

    (vector_pushback entries ent)

    (field_set ent 2 (vector_at bucket h))
    (vector_put bucket h ent)
    ))

(fun memotable_find (table sym pos) (
    (var bucket (field_get table 0))
    (var size (vector_size bucket))
    (var h (hash sym pos))
    (%= h size)
    (var entry (vector_at bucket h))
    (while entry (do
        (var e_sym (field_get entry 0))
        (var e_pos (field_get entry 3))
        (if (&& (== e_sym sym) (== e_pos pos))
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return 0)
    ))

(var case_sensitive_p @TRUE)
(var shell_mode_p @FALSE)

(extern object current_mod)
(extern fun set_current_module)

(export fun set_shell_mode () (
    (= shell_mode_p @TRUE)
    ))

(export fun unset_shell_mode () (
    (= shell_mode_p @FALSE)
    ))

(export fun in_shell_mode () (
    (return shell_mode_p)
    ))

(export fun parse (name p) (
    (var code (lookup_func current_mod (to_sym name)))
    (return (byterun code p))
    ))

(fun parsed (loc val) (
    (return (make_expr Parsed (list2 loc val)))
    ))

(fun noparse (loc msg) (
    (return (make_expr NoParse (list1 (list2 loc (string msg)))))
    ))

(fun merge_noparse (lhs rhs) (
    (if (! lhs) (return rhs))
    (if (! rhs) (return lhs))
    (return (make_expr NoParse (list_append (expr_args lhs) (expr_args rhs))))
    ))

(fun negate (val p) (
    (var hd (expr_head val))
    (var loc (get_loc p))
    (if (== hd Parsed)
        (return (noparse loc "unexpected token"))
        (return (parsed loc 0))
        )
    ))

(fun integer_overflow (loc) (
    (return (noparse loc "integer literal is too large"))
    ))

(fun junk_letter (loc) (
    (return (noparse loc "junk letter(s) at the end of integer literal"))
    ))

(export fun init_parser (file ichan) (
    ; character buffer
    (var cbuf (make_cvector 0))
    ; current position in cbuf
    (var pos 0)
    ; offset + pos is the number of total characters from the beginning of parsing
    (var offset 0)

    ; table for memoization
    (var memo (make_memotable 1000))
    (var buf (struct 3 cbuf ichan memo))
    (return (variant @ParserE 2 buf (string file) pos offset 1 1 0))
    ))

(export fun flush_parser (p) (
    (var buf (field_get p 1))
    (var cbuf (field_get buf 0))
    (var bufsz (cvector_size cbuf))

    (cvector_resize cbuf 0)
    (field_set p 4 (+ (field_get p 4) bufsz))
    (field_set p 3 0)
    (memotable_clear (field_get buf 2))
    (if shell_mode_p (field_set p 5 (+ (field_get p 5) 1)))
    ))

(fun copy_parser_state (p) (
    (var copy (variant @ParserE 2 0 0 0 0 0 0 0))
    (memcpy copy p (* 8 @WORD_SIZE))
    (return copy)
    ))

(fun set_parser_state (p state) (
    (memcpy p state (* 8 @WORD_SIZE))
    ))

(fun incr_nest_level (p) (
    (field_set p 7 (+ (field_get p 7) 1))
    ))

(fun decr_nest_level (p) (
    (field_set p 7 (- (field_get p 7) 1))
    ))

(fun nest_level (p) (
    (return (field_get p 7))
    ))

(fun extract_string (from p) (
    (var begin (field_get from 3))
    (var end   (field_get p 3))
    (var len (- end begin))
    (var vec (field_get (field_get p 1) 0))
    (return (strndup (+ (cvector_raw vec) begin) len))
    ))

(export fun get_loc (p) (
    (var line (field_get p 5))
    (return (make_loc (field_get p 2) line line))
    ))

(fun get_column (p) (
    (return (box (field_get p 6)))
    ))

(fun print_prompt (p) (
    (var line (field_get p 5))
    (output_string stdout "amber:")
    (output_int stdout line)
    (output_string stdout "> ")
    (flush stdout)
    ))

(fun reserve (p) (
    (var buf (field_get p 1))
    (var vec (field_get buf 0))
    (var ichan (field_get buf 1))
    (var line 0)
    (if shell_mode_p (print_prompt p))
    (var c 0)
    (while (>= (input_char (address c) ichan) 0) (do
        (cvector_pushback vec c)
        (if (|| (== c '\n') (== c '\0')) (return 0))
        ))
    (return -1)
    ))

(fun lookahead (p) (
    (var buf (field_get p 1))
    (var vec (field_get buf 0))
    (var idx (field_get p 3))
    (if (>= idx (cvector_size vec)) (do
        (if (< (reserve p) 0)
            (return @EOF)
            )
        ))
    (if (>= idx (cvector_size vec))
        (return -1)
        )
    (return (cvector_at vec idx))
    ))

(fun getc (p) (
    (var c (lookahead p))
    ; update source location
    (if (&& (== c '\n') (! shell_mode_p)) (do
        (field_set p 5 (+ (field_get p 5) 1))
        (field_set p 6 0)
        ))
    (field_set p 3 (+ (field_get p 3) 1))
    (field_set p 6 (+ (field_get p 6) 1))
    (return c)
    ))

; utilities
(fun is_spaces (c) (
    (return (== @(CHGRP c) @CH_SPACES))
    ))
(fun is_01 (c) (
    (= c @(CHGRP c))
    (return (|| (== c @CH_0) (== c @CH_1)))
    ))
(fun is_0_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_8_9)))
    ))
(fun is_1_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_1 c) (<= c @CH_8_9)))
    ))
(fun is_0_7 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_2_7)))
    ))
(fun is_hexdigit (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_HEX)))
    ))
(fun is_letter (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_af c) (<= c @CH_OTHER)))
    ))
(fun is_identchar (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_OTHER)))
    ))
(filevar escape_chars "'\"\\abfnrtv0")
(fun is_escape_char (c) (
    (for i 0 (strlen escape_chars) (do
        (if (== c (array_get char escape_chars i))
            (return @TRUE)
        )))
    (return @FALSE)
    ))
(fun is_end_of_token (p) (
    (var c (lookahead p))
    (if (< c 0) (return @TRUE))
    (= c @(CHGRP c))
    (return (|| (< c @CH_0) (> c @CH_OTHER)))
    ))

(fun parse_char (p c) (
    (var loc (get_loc p))
    (var v (getc p))
    (if (== v c) (do
        (return (parsed loc (ctos c)))
        ))
    (return (noparse loc 
        (strcat "expected " 
        (strcat (escape_char c)
        (strcat " but got " (escape_char v))))))
    ))

(fun parse_any_char (p) (
    (var loc (get_loc p))
    (var c (getc p))
    (if (< c 0)
        (return (noparse loc "end of input stream"))
        (return (parsed loc (ctos c)))
        )
    ))

(fun parse_text (p str) (
    (var loc (get_loc p))
    (var i 0)
    (var len (strlen str))
    (for i 0 len (do
        (var c (array_get char str i))
        (if (!= c (getc p))
            (return (noparse loc (strcat "expect " str)))
            )
        ))
    (return (parsed loc (string str)))
    ))

; parse_integers
; multi-precision integer is not supported for now
(fun parse_decimal_ (p) (
    (var loc (get_loc p))
    (var v (getc p))
    (if (&& (== v '0') (is_end_of_token p))
        (return (parsed loc (box 0)))
        )
    (if (! (is_1_9 v)) (return (noparse p "expect 1-9")))
    (var value (- v '0'))
    (while (is_0_9 (lookahead p)) (do
        (= v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 10))
            (return (integer_overflow p))
            )
        (= value (+ (* value 10) v))
        ))
    (if (is_end_of_token p)
        (return (parsed loc (box value)))
        )
    (if (== (lookahead p) 'e') (do
        (getc p)
        (var exp (parse_decimal p))
        @(CHECK exp)
        (= exp (unbox (expr_arg exp 1)))
        (while (> exp 0) (do
            (if (> value (/ @INTEGER_MAX 10))
                (return (integer_overflow loc))
                )
            (*= value 10)
            (-= exp 1)
            ))
        (return (parsed loc (box value)))
        ))
    (return (junk_letter loc))
    ))
@(MEMOIZE decimal)

(fun parse_binary_ (p) (
    (var loc (get_loc p))
    (var v (parse_text p "0b"))
    @(CHECK v)
    (if (! (is_01 (lookahead p))) (return (noparse loc "expect 0 or 1")))
    (var value 0)
    (while (is_01 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 2))
            (return (integer_overflow loc))
            )
        (= value (| (<< value 1) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE binary)

(fun parse_octal_ (p) (
    (var loc (get_loc p))
    (var v (parse_text p "0o"))
    @(CHECK v)
    (if (! (is_0_7 (lookahead p))) (return (noparse loc "expect 0-7")))
    (var value 0)
    (while (is_0_7 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (>> (- @INTEGER_MAX v) 3))
            (return (integer_overflow loc))
            )
        (= value (+ (<< value 3) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE octal)

(fun parse_hex_ (p) (
    (var loc (get_loc p))
    (var v (parse_text p "0x"))
    @(CHECK v)
    (if (! (is_hexdigit (lookahead p))) (return (noparse loc "expect hex digit")))
    (var value 0)
    (while (is_hexdigit (lookahead p)) (do
        (var v (getc p))
        (if (<= 'a' v)
            (= v (+ (- v 'a') 10))
        (if (<= 'A' v)
            (= v (+ (- v 'A') 10))
            (= v (- v '0'))
            ))
        (if (> value (>> (- @INTEGER_MAX v) 4))
            (return (integer_overflow loc))
            )
        (= value (+ (<< value 4) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE hex)

(fun parse_integer_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(decimal hex octal binary)))
    (if (== (expr_head v) NoParse) (return (noparse loc "expect integer literal")))
    (return v)
    ))
@(MEMOIZE integer)

(fun parse_spaces_ (p) (
    (var loc (get_loc p))
    (while @TRUE (do
        (var c (lookahead p))
        (if (is_spaces c)
            (getc p)
            break
            )
        ))
    (return (parsed loc Nil))
    ))
@(MEMOIZE spaces)

(fun parse_blanks_ (p) (
    (var loc (get_loc p))
    (while @TRUE (do
        (var c (lookahead p))
        (if (&& (is_spaces c) (!= c '\n'))
            (getc p)
            break
            )
        ))
    (return (parsed loc Nil))
    ))
@(MEMOIZE blanks)

(fun parse_symbol_ (p) (
    (var loc (get_loc p))
    (if (! (is_letter (lookahead p))) (return (noparse loc "expect [a-zA-Z_]")))
    (var begin (copy_parser_state p))
    (while (is_identchar (lookahead p)) (do
        (getc p)
        ))
    (return (parsed loc (to_sym (extract_string begin p))))
    ))
@(MEMOIZE symbol)

; single-quoted string literal
;   Only escape sequence \' is interpreted.
(fun parse_string_s_ (p) (
    (var loc (get_loc p))
    (if (!= (getc p) ''') (return (noparse loc "expect '")))
    (var begin (copy_parser_state p))
    (while (!= (lookahead p) ''') (do
        (var c (getc p))
        (if (== c '\\') (getc p))
        ))
    (var end (copy_parser_state p))
    (if (!= (getc p) ''') (return (noparse loc "expect '")))
    (var str (extract_string begin end))
    (unescape_string_s str)
    (return (parsed loc str))
    ))
@(MEMOIZE string_s)

; double-quoted string literal
(fun parse_string_d_ (p) (
    (var loc (get_loc p))
    (if (!= (getc p) '"') (return (noparse loc "expect \"")))
    (var begin (copy_parser_state p))
    (while (!= (lookahead p) '"') (do
        (var c (getc p))
        (if (== c '\\') (do
            (if (! (is_escape_char (getc p)))
                (return (noparse loc "invalid escape sequence"))
                )
            ))
        ))
    (var end (copy_parser_state p))
    (if (!= (getc p) '"') (return (noparse loc "expect \"")))
    (var str (extract_string begin end))
    (unescape_string_d str)
    (return (parsed loc str))
    ))
@(MEMOIZE string_d)

(fun parse_string_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(string_d string_s)))
    (if (== (expr_head v) NoParse) (return (noparse loc "expect string literal")))
    (return v)
    ))
@(MEMOIZE string)

(fun parse_node_ (p) (
    (var hd (parse_symbol p))
    (var bloc (get_loc p))

    (if (== (expr_head hd) NoParse) (return (noparse bloc "expect a head symbol")))
    (= hd (expr_arg hd 1))

    (parse "parse_spaces" p)
    (var v (parse_char p '{'))
    @(CHECK v)

    (incr_nest_level p)
    (parse "parse_spaces" p)

    (var args 0)
    (if (!= (lookahead p) '}') (do
        (while (> (lookahead p) 0) (do
            (= v (parse_item p))
            @(CHECK v)
            (parse "parse_spaces" p)

            (= args (cons (expr_arg v 1) args))
            (if (== (lookahead p) '}') break)
            (= v (parse_char p ','))
            @(CHECK v)
            (parse "parse_spaces" p)
            ))
        ))
    (= v (parse_char p '}'))
    @(CHECK v)
    (var eloc (get_loc p))

    (decr_nest_level p)
    (return (parsed (merge_loc bloc eloc)
        (make_expr_user hd (list_reverse args))))
    ))
@(MEMOIZE node)

(fun parse_item_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(
        node
        symbol
        integer
        string
    )))
    (if (== (expr_head v) NoParse) (return (noparse loc "expect an item")))
    (return v)
    ))
@(MEMOIZE item)

(fun parse_expression (p) (
    (return (parse "parse_item" p))
    ))

(fun parse_statement_ (p) (
    (var v (parse "parse_expression" p))
    @(CHECK v)
    (var loc (expr_arg v 0))
    (var stmt (expr_arg v 1))
    (eval_parser_command loc stmt)
    (return (parsed loc (make_located loc stmt)))
    ))
@(MEMOIZE statement)

(export fun parse_statements (p) (
    (if (== (lookahead p) @EOF) 0)
    (var stmts 0)
    (while @TRUE (do
        (if (== (lookahead p) @EOF) break)
        (parse "parse_spaces" p)

        (if (== (lookahead p) '\n') (do
            (getc p)
            continue
            ))
        (if (== (lookahead p) @EOF) break)

        (var v (parse "parse_statement" p))
        @(CHECK v)
        (parse "parse_blanks" p)

        (if (== (lookahead p) @EOF) break)

        (var nl (parse_char p '\n'))
        @(CHECK nl)
        (var stmt (expr_arg v 1))
        (var loc (expr_arg v 0))
        (= stmts (cons stmt stmts))
        (if (== (expr_head stmt) Include) break)
        ))
    (return (list_reverse stmts))
    ))

(extern fun eval_include)
(fun eval_parser_command (loc expr) (
    (var ty (expr_head expr))
    (if (== ty Import)
        (import_module loc current_mod (expr_arg expr 0))
        )
    ))

(fun add_parser (mod sym func) (
    (add_builtin_function1 mod sym (domainP Parser) func 0)
    ))

(fun to_parse (sym) (
    (return (to_sym (strcat "parse_" (symbol_name sym))))
    ))

(var Seq (to_sym "Seq"))
(var ParserVar (to_sym "%Parser")) ; internal use
(fun make_nodevar (idx) (
    (return (to_sym (strcat "node" (itos idx))))
    ))

(fun gen_at (node idx) (
    (return (make_expr Subscript (list2 node (box idx))))
    ))
(fun gen_copy_parser_state () (
    (return (make_expr Apply (list2 (to_sym "%copy_parser_state") (list1 ParserVar))))
    ))
(fun gen_set_parser_state (state) (
    (return (make_expr Apply (list2 (to_sym "%set_parser_state") (list2 ParserVar state))))
    ))

(extern object current_loc)
(fun compile_parser_element (pat) (
    (var hd (expr_head pat))
    (if (== hd Symbol)
        (return (make_expr Apply (list2 (to_parse pat) (list1 ParserVar)))))
    (if (== hd String)
        (return (make_expr Apply (list2 (to_sym "parse_text") (list2 ParserVar pat)))))
    (if (== hd List)
        (return (compile_seq pat))
        )
    (if (== hd Choice)
        (return (compile_choice (expr_args pat)))
        )
    (if (== hd Many)
        (return (compile_many (expr_arg pat 0)))
        )
    (if (== hd Many1)
        (return (compile_many1 (expr_arg pat 0)))
        )
    (if (== hd Option)
        (return (compile_option (expr_arg pat 0)))
        )
    (if (== hd And)
        (return (compile_and (expr_arg pat 0)))
        )
    (if (== hd Not)
        (return (compile_not (expr_arg pat 0)))
        )
    (if (== hd Aligned)
        (return (compile_aligned (expr_arg pat 0)))
        )
    (output_error stderr current_loc)
    (output_string stderr "invalid syntax element: ")
    (pretty_print stderr pat)
    (output_char stderr '\n')
    (exit 1)
    ))

; List{ p1, p2, ...} is translated to
;
; elems = []
; v = p1
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; parse_spaces()
; v = p2
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; ...
; return Parsed{merge{loc(p1), loc(pn)}, reverse(elems)}

(fun compile_seq (elems) (
    (var body 0)
    (var tmp (unique_sym))
    (var ret (unique_sym))
    (var bloc (unique_sym))
    (var eloc (unique_sym))
    (var loc (to_sym "%Loc"))
    (var firstp @TRUE)

    (= body (cons (make_expr DefineVariable (list2 tmp 0)) body))
    (= body (cons (make_expr DefineVariable (list2 ret 0)) body))
    (while elems (do
        (= body (cons (make_expr Assign (list2 tmp (compile_parser_element (car elems)))) body))
        (= body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 tmp)) (quote NoParse)))
            (make_expr Return (list1 tmp))
            )) body))
        (if firstp
            (= body (cons (make_expr DefineVariable (list2 bloc (gen_at tmp 0))) body))
            )
        (= body (cons (make_expr Assign (list2 ret (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at tmp 1) ret))))) body))
        (= elems (cdr elems))
        (if elems 
            (= body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) body))
            (= body (cons (make_expr DefineVariable (list2 eloc (gen_at tmp 0))) body))
            )
        (= firstp @FALSE)
        ))
    (= body (cons (make_expr DefineVariable (list2 loc
        (make_expr Apply (list2 (to_sym "%merge_loc") (list2 bloc eloc))))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (make_expr Apply (list2 (to_sym "reverse") (list1 ret))))))) body))
    (return (make_expr Apply (list2
        (make_expr Lambda (list2 ParserVar
        (make_expr Block (list_reverse body))))
        (list1 ParserVar))))
    ))

; Choice{ p1, p2, .. } is translated to
;
; lambda() {
;     errors = 0
;     state = copy_parser_state(parser)
;     v = p1
;     if (head(v) == Parsed) (return v)
;     errors = merge_noparse(errors, v)
;     set_parser_state(parser, state)
;     v = p2
;     ...
; }(p)

(fun compile_choice (ps) (
    (if (< (list_len ps) 2) (do
        (output_error stderr current_loc)
        (output_string stderr "Choice must have more than 1 argument.\n")
        (exit 1)
        ))

    (var body 0)
    (var state (unique_sym))
    (var v (unique_sym))
    (var errors (unique_sym))

    (= body (cons (make_expr DefineVariable (list2 v 0)) body))
    (= body (cons (make_expr DefineVariable (list2 errors 0)) body))
    (= body (cons (make_expr DefineVariable (list2 state (gen_copy_parser_state))) body))

    (while ps (do
        (= body (cons (make_expr Assign (list2 v (compile_parser_element (car ps)))) body))
        (= body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote Parsed)))
            (make_expr Return (list1 v))
            )) body))
        (= body (cons (make_expr Assign (list2 errors
            (make_expr Apply (list2 (to_sym "%merge_noparse") (list2 errors v))))) body))
        (= body (cons (gen_set_parser_state state) body))
        (= ps (cdr ps))
        ))
    (= body (cons errors body))

    (return (make_expr Apply (list2
        (make_expr Lambda (list2 ParserVar (make_expr Block (list_reverse body))))
        (list1 ParserVar)
        )))
    ))

; Many{ p } is translated to
;
; elems = []
; state = copy_parser_state(..)
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     state = copy_parser_state(..)
;     parse_spaces()
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_many (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (make_expr DefineVariable (list2 v p)) loop_body))
    (= loop_body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break)) loop_body))
    (= loop_body (cons (make_expr Assign (list2 eloc (gen_at v 0))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 elems (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at v 1) elems))))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 state (gen_copy_parser_state))) loop_body))
    (= loop_body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) loop_body))

    (var body 0)
    (= body (cons (make_expr DefineVariable (list2 bloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 eloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 elems 0)) body))
    (= body (cons (make_expr DefineVariable (list2 state (gen_copy_parser_state))) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state state) body))
    (= body (cons (make_expr DefineVariable (list2 loc
        (make_expr Apply (list2 (to_sym "%merge_loc") (list2 bloc eloc))))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (make_expr Apply (list2 (to_sym "reverse") (list1 elems))))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; Many1{ p } is translated to
;
; elems = []
; v = p
; if (head(v) == NoParse) return v
; elems = cons(val(v), elems)
; state = copy_parser_state(..)
; parse_spaces()
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     state = copy_parser_state(..)
;     parse_spaces()
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_many1 (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (make_expr Assign (list2 v p)) loop_body))
    (= loop_body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break)) loop_body))
    (= loop_body (cons (make_expr Assign (list2 eloc (gen_at v 0))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 elems (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at v 1) elems))))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 state (gen_copy_parser_state))) loop_body))
    (= loop_body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) loop_body))

    (var body 0)
    (= body (cons (make_expr DefineVariable (list2 bloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 eloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 elems 0)) body))
    (= body (cons (make_expr DefineVariable (list2 v p)) body))
    (= body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (make_expr Return (list1 v)))) body))
    (= body (cons (make_expr Assign (list2 elems (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at v 1) elems))))) body))
    (= body (cons (make_expr DefineVariable (list2 state (gen_copy_parser_state))) body))
    (= body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state state) body))
    (= body (cons (make_expr DefineVariable (list2 loc
        (make_expr Apply (list2 (to_sym "%merge_loc") (list2 bloc eloc))))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (make_expr Apply (list2 (to_sym "reverse") (list1 elems))))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; Aligned{ p } is translated to
;
; elems = []
; column = get_column(p)
; v = p
; if (head(v) == NoParse) return v
; elems = cons(val(v), elems)
; state = copy_parser_state(..)
; parse_spaces()
; while true {
;     if (get_column(p) != column) break
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     state = copy_parser_state(..)
;     parse_spaces()
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_aligned (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var clmn  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (make_expr If (list2
            (make_expr NotEqual (list2 
                (make_expr Apply (list2 (to_sym "%get_column") (list1 ParserVar)))
                clmn
                ))
            Break)) loop_body))
    (= loop_body (cons (make_expr Assign (list2 v p)) loop_body))
    (= loop_body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break)) loop_body))
    (= loop_body (cons (make_expr Assign (list2 eloc (gen_at v 0))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 elems (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at v 1) elems))))) loop_body))
    (= loop_body (cons (make_expr Assign (list2 state (gen_copy_parser_state))) loop_body))
    (= loop_body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) loop_body))

    (var body 0)
    (= body (cons (make_expr DefineVariable (list2 clmn (make_expr Apply (list2 (to_sym "%get_column") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 bloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 eloc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar))))) body))
    (= body (cons (make_expr DefineVariable (list2 elems 0)) body))
    (= body (cons (make_expr DefineVariable (list2 v p)) body))
    (= body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (make_expr Return (list1 v)))) body))
    (= body (cons (make_expr Assign (list2 elems (make_expr Apply (list2 (to_sym "cons") (list2 (gen_at v 1) elems))))) body))
    (= body (cons (make_expr DefineVariable (list2 state (gen_copy_parser_state))) body))
    (= body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state state) body))
    (= body (cons (make_expr DefineVariable (list2 loc
        (make_expr Apply (list2 (to_sym "%merge_loc") (list2 bloc eloc))))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (make_expr Apply (list2 (to_sym "reverse") (list1 elems))))))) body))
    (return (make_expr Block (list_reverse body)))
    ))


; Option{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; if (head(v) == NoParse) {
;   set_parser_state(parser, state)
;   nil
; } else
;   Parsed{loc(v), Some{val(v)}}
(fun compile_option (p) (
    (var v (unique_sym))
    (var state (unique_sym))
    (var loc (to_sym "%Loc"))
    (return (make_expr Block (list4
        (make_expr DefineVariable (list2 state (gen_copy_parser_state)))
        (make_expr DefineVariable (list2 loc (make_expr Apply (list2 (to_sym "%get_loc") (list1 ParserVar)))))
        (make_expr DefineVariable (list2 v (compile_parser_element p)))
        (make_ifelse
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (make_expr Block (list2
                (gen_set_parser_state state)
                (qquote (make_expr Parsed (list2 (unquote loc) 0)))
                ))
            (qquote (make_expr Parsed (list2 (unquote (gen_at v 0))
                (make_expr Some (list1 (unquote (gen_at v 1)))))))
            ))))
            
    ))

; And{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; v
(fun compile_and (p) (
    (var state (unique_sym))
    (var v (unique_sym))
    (return (make_expr Block (list4
        (make_expr DefineVariable (list2 state (gen_copy_parser_state)))
        (make_expr DefineVariable (list2 v (compile_parser_element p)))
        (gen_set_parser_state state)
        v)))
    ))

; Not{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; negate(v)
(fun compile_not (p) (
    (var state (unique_sym))
    (var v (unique_sym))
    (return (make_expr Block (list4
        (make_expr DefineVariable (list2 state (gen_copy_parser_state)))
        (make_expr DefineVariable (list2 v (compile_parser_element p)))
        (gen_set_parser_state state)
        (make_expr Apply (list2 (to_sym "%negate") (list1 v)))
        )))
    ))

(fun compile_parser_func (sym elems act) (
    (if (!= (expr_head elems) List) (do
        (output_error stderr current_loc)
        (output_string stderr "invalid syntax declaration\n")
        (exit 1)
        ))

    (var idx 0)
    (var body 0)
    (var bloc (unique_sym))
    (var eloc (unique_sym))
    (var loc (to_sym "%Loc"))

    (while elems (do
        (var ndvar (make_nodevar idx))
        (= body (cons (make_expr DefineVariable
            (list2 ndvar (compile_parser_element (car elems)))) body))
        (= body (cons (make_expr If (list2
            (make_expr Equal (list2 (make_expr Head (list1 ndvar)) (quote NoParse)))
            (make_expr Return (list1 ndvar))
            )) body))
        (if (== idx 0)
            (= body (cons (make_expr DefineVariable (list2 bloc (gen_at ndvar 0))) body))
            )
        (incr idx)
        (= elems (cdr elems))
        (if elems 
            (= body (cons (make_expr Apply (list2 (to_sym "parse_spaces") (list1 ParserVar))) body))
            (= body (cons (make_expr DefineVariable (list2 eloc (gen_at ndvar 0))) body))
            )
        (= body (cons (make_expr Assign (list2 ndvar (gen_at ndvar 1))) body))
        ))
    (= body (cons (make_expr DefineVariable (list2 loc
        (make_expr Apply (list2 (to_sym "%merge_loc") (list2 bloc eloc))))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote act)))) body))

    (= body (make_expr Block (list_reverse body)))
    (return (make_expr DefineFunction
        (list2 sym (make_expr Lambda (list2 (make_expr Domain (list2 ParserVar Parser)) body)))))
    ))

(extern fun compile_matching)
(fun call_parser (p sym new) (
    (var tbl (field_get (field_get p 1) 2))
    (var pos (field_get p 3))
    (var v (memotable_find tbl sym pos))
    (if v (do
        (field_set p 3 (cdr v))
        (return (car v))
        ))
    (var loc (get_loc p))
    (= v (byterun (compile_matching loc sym new) p))
    (memotable_add tbl sym pos (cons v (field_get p 3)))
    (return v)
    ))

(fun bind_parser (p sym new orig) (
    (var tbl (field_get (field_get p 1) 2))
    (var pos (field_get p 3))
    (var v (memotable_find tbl sym pos))
    (if v (do
        (field_set p 3 (cdr v))
        (return (car v))
        ))
    (var loc (get_loc p))
    (var state (copy_parser_state p))
    (var errors 0)

    (= v (byterun (compile_matching loc sym new) p))
    (if (== (expr_head v) Parsed) (goto end_lbl))
    (= errors (merge_noparse errors v))
    (set_parser_state p state)

    (= v (byterun (compile_matching loc sym orig) p))
    (if (== (expr_head v) Parsed) (goto end_lbl))
    (= errors (merge_noparse errors v))
    (set_parser_state p state)

    (label end_lbl)
    (memotable_add tbl sym pos (cons v (field_get p 3)))
    (return v)
    ))

(fun compile_parser1 (sym new) (
    (return (make_expr DefineFunction (list2 sym
        (make_expr Lambda (list2 (make_expr Domain (list2 ParserVar Parser))
        (make_expr Apply (list2 (to_sym "%call_parser") (list3 ParserVar (quote sym) new)))
        )))))
    ))

(fun compile_parser2 (sym new orig) (
    (return (make_expr DefineFunction (list2 sym
        (make_expr Lambda (list2 (make_expr Domain (list2 ParserVar Parser))
        (make_expr Apply (list2 (to_sym "%bind_parser") (list4 ParserVar (quote sym) new orig)))
        )))))
    ))

(export fun compile_define_syntax (sym pat act) (
    (= sym (to_parse sym))
    (if (lookup_symbol current_mod sym)
        (do
            (var parser_sym (unique_sym))
            (var copy_sym   (unique_sym))
            (var new_parser_stmt (compile_parser_func parser_sym pat act))
            (var stmts (list3
                (make_expr DefineVariable (list2 copy_sym sym))
                new_parser_stmt
                (compile_parser2 sym parser_sym copy_sym)
                ))
            (return stmts)
        )
        (do
            (var parser_sym (unique_sym))
            (var new_parser_stmt (compile_parser_func parser_sym pat act))
            (var stmts (list2
                new_parser_stmt
                (compile_parser1 sym parser_sym)
                ))
            (return stmts)
        ))
    ))

(export fun init_parser_funcs (mod) (
    (var std (find_module no_loc mod (to_sym "std") @TRUE))
    (var parser (find_module no_loc std (to_sym "parser") @TRUE))

    (add_builtin_function1 parser (to_sym "%get_loc") (domainP Parser) get_loc 0)
    (add_builtin_function1 parser (to_sym "%get_column") (domainP Parser) get_column 0)
    (add_builtin_function2 parser (to_sym "%merge_loc") (domainP Loc) (domainP Loc) merge_loc 0)
    (add_builtin_function1 parser (to_sym "%copy_parser_state") (domainP Parser) copy_parser_state 0)
    (add_builtin_function2 parser (to_sym "%set_parser_state") (domainP Parser) (domainP Parser) set_parser_state 0)
    (add_builtin_function3 parser (to_sym "%call_parser") (domainP Parser) (domainP Symbol) (domainP Function) call_parser 0)
    (add_builtin_function4 parser (to_sym "%bind_parser") (domainP Parser) (domainP Symbol) (domainP Function) (domainP Function) bind_parser 0)
    (add_builtin_function2 parser (to_sym "%merge_noparse") DontCare DontCare merge_noparse 0)
    (add_builtin_function1 parser (to_sym "%negate") DontCare negate 0)

    (add_builtin_function2 parser (to_sym "parse_text") (domainP Parser) (domainP String) parse_text 0)

    (add_parser parser (to_sym "parse_spaces") parse_spaces)
    (add_parser parser (to_sym "parse_blanks") parse_blanks)
    (add_parser parser (to_sym "parse_decimal") parse_decimal)
    (add_parser parser (to_sym "parse_binary") parse_binary)
    (add_parser parser (to_sym "parse_octal") parse_octal)
    (add_parser parser (to_sym "parse_hex") parse_hex)
    (add_parser parser (to_sym "parse_integer") parse_integer)
    (add_parser parser (to_sym "parse_string") parse_string)
    (add_parser parser (to_sym "parse_symbol") parse_symbol)

    ; expressions
    (add_parser parser (to_sym "parse_item") parse_item)
    (add_parser parser (to_sym "parse_expression") parse_expression)
    (add_parser parser (to_sym "parse_statement") parse_statement)
    ))

(export fun output_syntax_errors (e) (
    (output_string stderr "Syntax Error ")
    (var errors (expr_args e))
    (var multi @FALSE)
    (if (!= (list_len errors) 1) (do
        (= multi @TRUE)
        (output_char stderr '\n'))
        )
    (while errors (do
        (if multi (output_char stderr '\t'))
        (output_loc stderr (caar errors))
        (output_string stderr " : ")
        (output_string stderr (cadar errors))
        (output_char stderr '\n')
        (= errors (cdr errors))
        ))
    ))

    ))
