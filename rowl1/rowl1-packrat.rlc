;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-packrat.rlc 2013-07-08 19:05:30 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; character groups
(var CH_EOS        0) ; "\0"
(var CH_SPACES     1) ; "\t\r\n "
(var CH_0          2) ; "0"
(var CH_1          3) ; "1"
(var CH_2_7        4) ; "234567"
(var CH_8_9        5) ; "89"
(var CH_af         6) ; "af"
(var CH_b          7) ; "b"
(var CH_e          8) ; "e"
(var CH_HEX        9) ; "ABCDEFcd"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_OTHER     14) ; "GHIJKLMNOPQRSTUVWXYZcdghijklmpqsuwuz_"
(var CH_SHARP     15) ; "#"
(var CH_INVALID   16)

; fixed-length integers are 31-bits because of boxing
(var INTEGER_MAX  (- (<< 1 30) 1))

; end of file
(var EOF -2)

(define CHGRP (c) `(array_get char chgroup @c))
(define PARSED (p) `(== (field_get @p 1) @C_TRUE))
(define PARSED_FLAG (p) `(field_get @p 1))
(define TOKEN (p) `(field_get @p 2))
(define ERROR (p) `(field_get @p 3))
(define CHECK (p) `(if (== (field_get @p 1) @C_FALSE) (do
        (reset_parser_position p state)
        (return @C_FALSE)
        )))

(define MEMOIZE (sym)
    `(export fun @(s++ `parse_ sym) (p) (
        (var s (to_sym @(tos sym)))
        (var tbl (field_get (field_get p 4) 2))
        (var pos (field_get p 6))
        (var v (memotable_find tbl s pos (field_get p 7)))
        (if v (do
            (set_parser_state p (field_get v 0))
            (return @(PARSED_FLAG p))
            ))
        (@(s++ `parse_ sym '_') p)
        (var state (copy_parser_state p))
        (memotable_add tbl s pos (field_get p 7) (struct 1 state @FALSE @FALSE @FALSE))
        (return @(PARSED_FLAG p))
    )))

(define OR (p ps) (do
    (var end_lbl (mklabel))
   `(do
        (do . @(map (lambda (f) 
            `(do
                 (if (== (parse @(tos f) @p) @C_TRUE) (goto @end_lbl))
             )) ps))
        (label @end_lbl)
    )))

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-module")
(import "rowl1-error")

(extern object global)

(array char chgroup (
     0 16 16 16 16 16 16 16 16  1  1 16 16  1 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
     1 16 16 15 16 16 16 16 16 16 16 16 16 16 16 16
     2  3  4  4  4  4  4  4  5  5 16 16 16 16 16 16
    16  9  9  9  9  9  9 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 16 16 16 16 14
    16  6  7  9  9  8  6 14 14 14 14 14 14 14 13 10
    14 14 11 14 11 14 11 14 12 14 14 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    ))

; hashtable for memoization
; key:   (non-terminal symbol, position (integer))
; value: (node, parser state)
;
; structure of tables
;   0 : bucket (array)
;   1 : list of entries
;   2 : number of entries
;   
; structure of entries
;   0 : symbol
;   1 : expr
;   2 : pointer to the next entry
;   3 : pointer to the next entry in entry list
;   4 : position value
;   5 : hash value

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

(fun make_memotable (hint) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (struct 2 (allocate_array size) 0 0))
    ))

(fun memotable_clear (table) (
    (seq_clear (field_get table 0))
    (field_set table 1 0)
    ))

(fun hash (sym pos) (
    (var h (field_get sym @SymbolIndex))
    (= h (+ (* 7 h) pos))
    (return h)
    ))

(fun rehash (table) (
    (var old_size (seq_size (field_get table 0)))
    (var num_ent  (field_get table 2))
    (if (>= num_ent old_size) (do
        (var new_size (array_get int prime_numbers (bsr num_ent)))
        (if (! new_size) return)
        (var bucket (allocate_array new_size))
        (var entry (field_get table 1))
        (while entry (do
            (var h (umod (field_get entry 6) new_size))
            (field_set entry 2 (array_get object bucket h))
            (array_set object bucket h entry)
            (= entry (field_get entry 3))
            ))
        (field_set table 0 bucket)
        ))
    ))

(fun memotable_add (table sym pos nl obj) (
    (rehash table)

    (var bucket (field_get table 0))
    (var size (seq_size bucket))
    (var h_orig (hash sym pos))

    (var h (umod h_orig size))
    (var entry (array_get object bucket h))
    (while entry (do
        (if (&& (== (field_get entry 0) sym)
            (&& (== (field_get entry 4) pos)
                (== (field_get entry 5) nl))) (do
            (field_set entry 1 obj)
            return
            ))
        (= entry (field_get entry 2))
        ))

    (var ent (struct 4 sym obj 0 0 pos nl h_orig))
    (field_set ent 2 (array_get object bucket h))
    (array_set object bucket h ent)

    (field_set ent 3 (field_get table 1))
    (field_set table 1 ent)

    (field_set table 2 (+ (field_get table 2) 1))
    ))

(fun memotable_find (table sym pos nl) (
    (var bucket (field_get table 0))
    (var size (seq_size bucket))
    (var h (hash sym pos))
    (= h (umod h size))
    (var entry (array_get object bucket h))
    (while entry (do
        (if (&& (== (field_get entry 0) sym)
            (&& (== (field_get entry 4) pos)
                (== (field_get entry 5) nl)))
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return 0)
    ))

(var parser_mod null)
(var nospace_p @FALSE)
(var multiline_p @FALSE)
(var shell_mode_p @FALSE)
(var mayparse_p @FALSE)
(var left_rec (string "Left Recursion Detected"))

(extern object current_mod)
(extern object current_loc)
(extern fun set_current_module)
(extern fun prompt_string)

(fun __cons (a b) (
    (return (cons a b))
    ))

(fun __reverse (ls) (
    (return (list_reverse ls))
    ))

(fun __length (ls) (
    (return (box (list_len ls)))
    ))

(fun trace (obj) (
    (return (block (list2
        (apply (to_sym "print") (list2 (to_sym "stderr") obj))
        (apply (to_sym "print") (list2 (to_sym "stderr") (string "\n")))
        )))
    ))

(export fun set_shell_mode () (
    (= shell_mode_p @TRUE)
    ))

(export fun unset_shell_mode () (
    (= shell_mode_p @FALSE)
    ))

(export fun in_shell_mode () (
    (return shell_mode_p)
    ))

(export fun parse (name p) (
    (return (byterun (lookup_func current_mod (to_sym name)) p))
    ))

(export fun parse_success (p) (
    (return @(PARSED p))
    ))
(export fun parsed_token (p) (
    (return @(TOKEN p))
    ))
(export fun parser_error (p) (
    (return @(ERROR p))
    ))

(fun parsed (p val) (
    (field_set p 1 @C_TRUE) ; parsed-flag
    (field_set p 2 val)     ; the token

    ; if column > indentation, current position is not the
    ; beginning of new line.
    (if (> (field_get p 9) (field_get p 10))
        (field_set p 7 @FALSE)
        )

    (return @C_TRUE)
    ))

(fun noparse_sub (p msg quiet may) (
    (field_set p 1 @C_FALSE)

    ; if current position > error position, update error message
    (if (>= (field_get p 6) (field_get p 11)) (do
        (= mayparse_p may)
        (if (! quiet) (do
            (field_set p 3 (string msg))
            ; update the error position
            (field_set p 11 (field_get p 6))
            ))
        ))
    (return @C_FALSE)
    ))

(fun noparse (p msg) (
    (return (noparse_sub p msg @FALSE @FALSE))
    ))

(fun mayparse (p msg) (
    (return (noparse_sub p msg @FALSE @TRUE))
    ))

(fun noparse_quite (p) (
    (return (noparse_sub p 0 @TRUE @FALSE))
    ))

(fun mayparse_quiet (p) (
    (return (noparse_sub p 0 @TRUE @TRUE))
    ))

(fun negate (p) (
    (if @(PARSED p)
        (do
            (field_set p 1 @C_FALSE)
            (field_set p 3 (string "unexpected token"))
            (return @C_FALSE)
        )
        (do
            (field_set p 1 @C_TRUE)
            (field_set p 2 @C_NIL)
            (return @C_TRUE)
        ))
    ))

(fun apply_located (p) (
    (if @(PARSED p)
        (field_set p 2 (located (get_loc p) (field_get p 2)))
        )
    (return @(PARSED_FLAG p))
    ))

(fun integer_overflow (p) (
    (return (noparse p "integer literal is too large"))
    ))

(fun junk_letter (p) (
    (return (noparse p "junk letter(s) at the end of integer literal"))
    ))

; structure of parser
;   0: head (ParserE)
;   1: parsed=true, noparse=false
;   2: parsed token
;   3: error message
;   4: (character buffer, input channel, table for memoization)
;   5: filename
;   6: current position in the character buffer
;   7: newline-flag
;   8: line number
;   9: column number
;  10: indentation
;  11: error position

(export fun init_parser (file ichan) (
    ; character buffer
    (var cbuf (make_cvector 0))
    ; current position in cbuf
    (var pos 0)

    ; table for memoization
    (var memo (make_memotable 10))
    (var buf (struct 3 cbuf ichan memo))

    (return (variant @ParserE 5 0 0 0 buf (string file) pos @FALSE 1 1 1 0))
    ))

(fun print_parser_state (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var pos (field_get p 6))
    (var n 100)
    (output_string stderr "input[newline=")
    (output_int stderr (field_get p 7))
    (output_string stderr "]:")
    (while (&& (< pos (cvector_size vec)) (> n 0)) (do
        (output_char stderr (cvector_at vec pos))
        (+= pos 1)
        (-= n 1)
        ))
    (output_string stderr "\n")
    ))

(fun reserve (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var ichan (field_get buf 1))
    (var line 0)
    (var c 0)
    (while (>= (input_char (address c) ichan) 0) (do
        (cvector_pushback vec c)
        (if (|| (== c '\n') (== c '\0')) (return 0))
        ))
    (return -1)
    ))

(fun lookahead (p) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (if (>= idx (cvector_size vec)) (do
        (if (&& (! shell_mode_p) (< (reserve p) 0))
            (return @EOF)
            )
        ))
    (if (>= idx (cvector_size vec))
        (return -1)
        )
    (return (cvector_at vec idx))
    ))

(fun lookahead_text (p str) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (var n (cvector_size vec))
    (var i 0)
    
    (while (< idx n) (do
        (var c (array_get uchar str i))
        (if (== c 0) (return @TRUE))
        (if (!= (cvector_at vec idx) c)
            (return @FALSE)
            )
        (+= idx 1)
        (+= i 1)
        ))
    (return @FALSE)
    ))

(fun getc (p) (
    (var c (lookahead p))
    (if (< c 0) (return c))
    ; update source location
    (if (== c '\n') (do
        (if (! shell_mode_p)
            (field_set p 8 (+ (field_get p 8) 1))
            )
        (field_set p 9 0)
        ))
    (field_set p 6 (+ (field_get p 6) 1))
    (field_set p 9 (+ (field_get p 9) 1))
    (return c)
    ))

(export fun flush_parser (p force) (
    (var buf (field_get p 4))
    (var cbuf (field_get buf 0))
    (var bufsz (cvector_size cbuf))
    (var pos (field_get p 6))

    ; XXX: Not good implementation.
    ; Ring buffer is better.
    (if (|| (>= pos bufsz) force) (do
        (cvector_resize cbuf 0)
        (field_set p 6 0)
        ))

    ; reset error info
    (field_set p 3 0)
    (field_set p 11 0)

    (memotable_clear (field_get buf 2))
    (if (&& shell_mode_p (! force)) (field_set p 8 (+ (field_get p 8) 1)))
    ))

(fun copy_parser_state (p) (
    (var copy (variant @ParserE 4 0 0 0 0 0 0 0 0 0 0 0))
    (memcpy copy p (* 12 @WORD_SIZE))
    (return copy)
    ))

(fun set_parser_state (dst src) (
    ; NB: error message, indentation-level and error position must not be copied
    (var msg @(ERROR dst))
    (memcpy dst src (* 10 @WORD_SIZE))
    (field_set dst 3 msg)
    ))

(fun clear_parser_state (p state) (
    (var buf (field_get p 4))
    (set_parser_state p state)
    (memotable_clear (field_get buf 2))
    ))

(fun reset_parser_position (dst src) (
    ; NB: token info and error position must not be copied.
    (memcpy (+ dst (* 4 @WORD_SIZE)) (+ src (* 4 @WORD_SIZE)) (* 7 @WORD_SIZE))
    (return @C_NIL)
    ))

(fun extract_string (p begin end) (
    (var len (- end begin))
    (var vec (field_get (field_get p 4) 0))
    (var str (strndup (+ (cvector_raw vec) begin) len))
    (return str)
    ))

; boxed version
(fun get_input_text (p begin end) (
    (return (extract_string p (unbox begin) (unbox end)))
    ))

(export fun get_pos (p) (
    (return (box (field_get p 6)))
    ))

(export fun get_loc (p) (
    (var line (field_get p 8))
    (var clmn (field_get p 9))
    (if shell_mode_p
        (return (make_loc (prompt_string) line clmn line clmn))
        (return (make_loc (field_get p 5) line clmn line clmn))
        )
    ))

(fun get_column (p) (
    (return (box (field_get p 9)))
    ))

; set new indentation-level and return current indentation-level
(fun set_indent (p c) (
    (var current_indent (field_get p 10))
    (field_set p 7 @TRUE)
    (field_set p 10 (unbox c))
    (return (box current_indent))
    ))

(fun check_indent (p) (
    (if (field_get p 7) (return @C_TRUE))
    (if (< (lookahead p) 0) (return @C_TRUE))

    (if (<= (field_get p 9) (field_get p 10))
        (return @C_FALSE)
        (return @C_TRUE)
        )
    ))

; utilities
(fun is_spaces (c) (
    (return (== @(CHGRP c) @CH_SPACES))
    ))
(fun is_01 (c) (
    (= c @(CHGRP c))
    (return (|| (== c @CH_0) (== c @CH_1)))
    ))
(fun is_0_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_8_9)))
    ))
(fun is_1_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_1 c) (<= c @CH_8_9)))
    ))
(fun is_0_7 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_2_7)))
    ))
(fun is_hexdigit (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_HEX)))
    ))
(export fun is_letter (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_af c) (<= c @CH_OTHER)))
    ))
(export fun is_identchar (c) (
    (if (< c 0) (return @FALSE))
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_OTHER)))
    ))
(var escape_chars "'\"\\abfnrtv0")
(fun is_escape_char (c) (
    (for i 0 (strlen escape_chars) (do
        (if (== c (array_get char escape_chars i))
            (return @TRUE)
        )))
    (return @FALSE)
    ))
(fun is_end_of_token (p) (
    (var c (lookahead p))
    (if (< c 0) (return @TRUE))
    (= c @(CHGRP c))
    (return (|| (< c @CH_0) (> c @CH_OTHER)))
    ))

(fun parse_char (p c) (
    (var v (lookahead p))
    (if (< v 0) (do
        (return (mayparse p (strcat "expect token: " (escape_char c))))
        ))
    (if (== v c) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p 
        (strcat "expect " 
        (strcat (escape_char c)
        (strcat " but got " (escape_char v))))))
    ))
 
(fun parse_fail (p) (
    (return (noparse p "Invalid comment syntax"))
    ))

(fun parse_any_char (p) (
    (var c (getc p))
    (if (< c 0)
        (return (mayparse p "end of input stream"))
        (return (parsed p (ctos c)))
        )
    ))

(fun parse_text (p str) (
    (var buf (field_get p 4))
    (var vec (field_get buf 0))
    (var idx (field_get p 6))
    (var n (cvector_size vec))
    (var i 0)
    
    (var clmn (field_get p 9))
    (var line (field_get p 8))
    (while (< idx n) (do
        (var c (cvector_at vec idx))
        (var d (array_get uchar str i))
        (if (== d 0) (do
            (field_set p 6 idx)
            (field_set p 8 line)
            (field_set p 9 clmn)
            (return (parsed p (string str)))
            ))
        (if (!= d c)
            (return (noparse p (strcat "expect token: '" (strcat str "'"))))
            )
        (+= clmn 1)
        (if (== c '\n') (do
            (if (! shell_mode_p) (+= line 1))
            (= clmn 0)
            ))
        (+= idx 1)
        (+= i 1)
        ))
    (return (mayparse p (strcat "expect token: '" (strcat str "'"))))
    ))

; parse_integers
; multi-precision integer is not supported for now
(extern fun parse_bint)
(extern fun parse_bint_binary)
(extern fun parse_bint_octal)
(extern fun parse_bint_hex)
(fun parse_decimal_ (p) (
    (var sign 1)
    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var v (lookahead p))

    (if (< v 0) (return (mayparse p "expect token: a number")))

    (var state (copy_parser_state p))

    (= v (getc p))
    (if (== v '-') (do
        (= sign -1)
        (= v (getc p))
        ))

    (if (&& (== v '0') (is_end_of_token p))
        (return (parsed p (box 0)))
        )
    (if (! (is_1_9 v)) (do
        (noparse p "expect 1-9")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value (- v '0'))
    (while (is_0_9 (lookahead p)) (do
        (= v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 10))
            (= big_p @TRUE)
            )
        (= value (+ (* value 10) v))
        ))
    (if (is_end_of_token p)
        (if big_p
            (return (parsed p (parse_bint (extract_string p begin (field_get p 6)))))
            (return (parsed p (box (* sign value))))
            )
        )
    (if (== (lookahead p) 'e') (do
        (getc p)
        (parse_decimal p)
        @(CHECK p)
        (var exp (unbox @(TOKEN p)))
        (while (> exp 0) (do
            (if (> value (/ @INTEGER_MAX 10))
                (= big_p @TRUE)
                )
            (*= value 10)
            (-= exp 1)
            ))
        (if big_p
            (return (parsed p (parse_bint (extract_string p begin (field_get p 6)))))
            (return (parsed p (box (* sign value))))
            )
        ))

    (junk_letter p)
    (reset_parser_position p state)
    (return @C_FALSE)
    ))
@(MEMOIZE decimal)

(fun parse_binary_ (p) (
    (var big_p @FALSE)
    (var begin (field_get p 6))

    (var state (copy_parser_state p))

    (if (== (parse_text p "0b") @C_FALSE) (return @C_FALSE))
    (if (! (is_01 (lookahead p))) (do
        (noparse p "expect 0 or 1")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_01 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 2))
            (= big_p @TRUE)
            )
        (= value (| (<< value 1) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_binary (extract_string p begin (field_get p 6)) 2)))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE binary)

(fun parse_octal_ (p) (
    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var state (copy_parser_state p))
    (if (== (parse_text p "0o") @C_FALSE) (return @C_FALSE))
    (if (! (is_0_7 (lookahead p))) (do
        (noparse p "expect 0-7")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_0_7 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (>> (- @INTEGER_MAX v) 3))
            (= big_p @TRUE)
            )
        (= value (+ (<< value 3) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_octal (extract_string p begin (field_get p 6)))))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE octal)

(fun parse_hex_ (p) (
    (var big_p @FALSE)
    (var begin (field_get p 6))
    (var state (copy_parser_state p))
    (if (== (parse_text p "0x") @C_FALSE) (return @C_FALSE))
    (if (! (is_hexdigit (lookahead p))) (do
        (noparse p "expect hex digit")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var value 0)
    (while (is_hexdigit (lookahead p)) (do
        (var v (getc p))
        (if (<= 'a' v)
            (= v (+ (- v 'a') 10))
        (if (<= 'A' v)
            (= v (+ (- v 'A') 10))
            (= v (- v '0'))
            ))
        (if (> value (>> (- @INTEGER_MAX v) 4))
            (= big_p @TRUE)
            )
        (= value (+ (<< value 4) v))
        ))
    (if (! (is_end_of_token p)) (do
        (junk_letter p)
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if big_p
        (return (parsed p (parse_bint_hex (extract_string p begin (field_get p 6)))))
        (return (parsed p (box value)))
        )
    ))
@(MEMOIZE hex)

(extern fun float_from_s)
(fun parse_float_ (p) (
    (var begin (field_get p 6))
    (var state (copy_parser_state p))
    (if (== (parse_decimal p) @C_FALSE) (return @C_FALSE))
    (if (!= (lookahead p) '.') (do
        (noparse p "expect '.'")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)
    (if (! (is_0_9 (lookahead p))) (do
        (noparse p "expect digits after the decimal point")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (getc p)
    (while (is_0_9 (lookahead p)) (getc p))
    (if (== (lookahead p) 'e') (do
        (getc p)
        (if (== (lookahead p) '-') (getc p))
        (if (! (is_0_9 (lookahead p))) (do
            (noparse p (strcat "expect a number: " (ctos (lookahead p))))
            (reset_parser_position p state)
            (return @C_FALSE)
            ))
        (getc p)
        (while (is_0_9 (lookahead p)) (getc p))
        ))
    (return (parsed p (float_from_s (extract_string p begin (field_get p 6)))))
    ))
@(MEMOIZE float)

(fun parse_blank (p) (
    (var c (lookahead p))
    (if (< c 0) (return (mayparse_quiet p)))
    (if (&& (is_spaces c) (!= c '\n')) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse_quite p))
    ))

(fun parse_blanks_ (p) (
    (var pos (get_pos p))
    (var blank   (lookup_func current_mod (to_sym "blank")))
    (var comment (lookup_func current_mod (to_sym "comment")))
    (while @TRUE (do
        (byterun blank p)
        (if @(PARSED p) continue)
        (byterun comment p)
        (if @(PARSED p) continue)
        break
        ))
    (if (== (get_pos p) pos)
        (return (noparse_quite p))
        (return (parsed p @C_NIL))
        )
    ))
@(MEMOIZE blanks)

(fun parse_spaces_ (p) (
    (var pos (get_pos p))
    (var blank   (lookup_func current_mod (to_sym "blank")))
    (var comment (lookup_func current_mod (to_sym "comment")))
    (while @TRUE (do
        (byterun blank p)
        (if @(PARSED p) continue)
        (parse_char p '\n')
        (if @(PARSED p) continue)
        (byterun comment p)
        (if @(PARSED p) continue)
        break
        ))
    (if (== (get_pos p) pos)
        (return (noparse_quite p))
        (return (parsed p @C_NIL))
        )
    ))
@(MEMOIZE spaces)

(fun parse_shell_style_comment_ (p) (
    (var v (lookahead p))
    (if (!= v '#') (return (noparse_quite p)))
    (while @TRUE (do
        (var c (lookahead p))
        (if (|| (== c '\n') (< c 0)) break)
        (getc p)
        ))
    (return (parsed p @C_NIL))
    ))
@(MEMOIZE shell_style_comment)

(fun parse_C_style_comment_ (p) (
    (if (! (lookahead_text p "//")) (return @C_FALSE))
    (var v (parse_text p "//"))
    (while @TRUE (do
        (var c (lookahead p))
        (if (|| (== c '\n') (< c 0)) break)
        (getc p)
        ))
    (return (parsed p @C_NIL))
    ))
@(MEMOIZE C_style_comment)

(var reserved_symbols null)
(fun parse_symbol_ (p) (
    (var c (lookahead p))
    (if (< c 0) (return (mayparse p "expect a symbol")))
    (if (! (is_letter c)) (return (noparse p "expect a symbol")))

    (var state (copy_parser_state p))

    (var begin (field_get p 6))
    (while (is_identchar (lookahead p)) (do
        (getc p)
        ))
    (var s (to_sym (extract_string p begin (field_get p 6))))

    (if (list_member s reserved_symbols) (do
        (noparse p (strcat "reserved symbol: " (symbol_name s)))
        (reset_parser_position p state)
        (return @C_FALSE)
        ))

    (return (parsed p s))
    ))
@(MEMOIZE symbol)

; single-quoted string literal
;   Only escape sequence \' is interpreted.
(fun parse_string_s_ (p) (
    (var v (lookahead p))
    (if (< v 0) (return (mayparse p "expect token: ' (single quote)")))
    (if (!= v ''') (return (noparse p "expect token: ' (single quote)")))
    (var state (copy_parser_state p))
    (getc p)
    (var begin (field_get p 6))
    (while (!= (lookahead p) ''') (do
        (var c (getc p))
        (if (< c 0) (do
            (mayparse p "expect character")
            (reset_parser_position p state)
            (return @C_FALSE)
            ))
        (if (== c '\\') (getc p))
        ))
    (var end (field_get p 6))

    (= v (getc p))
    (if (< v 0) (do
        (mayparse p "expect token: ' (single quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if (!= v ''') (do
        (noparse p "expect token: ' (single quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))

    (var str (extract_string p begin end))
    (unescape_string_s str)
    (return (parsed p str))
    ))
@(MEMOIZE string_s)

; double-quoted string literal
(fun parse_string_d_ (p) (
    (var v (lookahead p))
    (if (< v 0) (return (mayparse p "expect token: \" (double quote)")))
    (if (!= v '"') (return (noparse p "expect token: \" (double quote)")))
    (getc p)
    (var state (copy_parser_state p))
    (var begin (field_get p 6))
    (while (!= (lookahead p) '"') (do
        (var c (getc p))
        (if (< c 0) (do
            (mayparse p "expect character")
            (reset_parser_position p state)
            (return @C_FALSE)
            ))

        (if (== c '\\') (do
            (if (! (is_escape_char (getc p))) (do
                (noparse p "invalid escape sequence")
                (reset_parser_position p state)
                (return @C_FALSE)
                ))
            ))
        ))
    (var end (field_get p 6))
    (= v (getc p))
    (if (< v 0) (do
        (mayparse p "expect token: \" (double quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (if (!= v '"') (do
        (noparse p "expect token: \" (double quote)")
        (reset_parser_position p state)
        (return @C_FALSE)
        ))
    (var str (extract_string p begin end))
    (unescape_string_d str)
    (return (parsed p str))
    ))
@(MEMOIZE string_d)

(fun parse_string_ (p) (
    @(OR p `(string_d string_s))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE string)

(fun parse_object_ (p) (
    (var c (lookahead p))
    (if (< c 0) (return (mayparse p "expect token: a symbol")))
    (if (! (is_letter c)) (return (noparse p "expect token: a symbol")))

    (var state (copy_parser_state p))

    (if (== (parse_symbol p) @C_FALSE) (return @C_FALSE))

    (var hd @(TOKEN p))
    (parse_blanks p)
    (parse_char p '{')
    @(CHECK p)
    (parse_spaces p)

    (var args 0)
    (if (!= (lookahead p) '}') (do
        (while (> (lookahead p) 0) (do
            (parse "expr" p)
            @(CHECK p)
            (= args (cons @(TOKEN p) args))
            (parse_spaces p)
            (if (== (lookahead p) '}') break)
            (parse_char p ',')
            @(CHECK p)
            (parse_spaces p)
            ))
        ))
    (parse_char p '}')
    @(CHECK p)
    (parsed p (make_object hd (list_reverse args)))
    (return @C_TRUE)
    ))
@(MEMOIZE object)

(fun parse_integer_ (p) (
    @(OR p `(
        decimal
        hex
        octal
        binary
        ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE integer)

(fun parse_atom_ (p) (
    @(OR p `(
        symbol
        float
        integer
        string
    ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE atom)

(fun parse_expr_ (p) (
    @(OR p `(
        object
        atom
    ))
    (if @(PARSED p)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))
@(MEMOIZE expr)

(fun parse_statement_ (p) (
    (return (parse "expr" p))
    ))
@(MEMOIZE statement)

(export fun parse_statements (p) (
    (var save_current_mod current_mod)
    (set_current_module (find_module global Syntax))
    (var eof (parse_statements_sub p))
    (set_current_module save_current_mod)
    (return eof)
    ))

(fun parse_statements_sub (p) (
    (if (== (lookahead p) @EOF) (return @TRUE))
    (parse_spaces p)
    (if (== (lookahead p) @EOF) (return @TRUE))

    (set_indent p (get_column p))
    (parse "statement" p)
    (if (! @(PARSED p)) (return @FALSE))
    (apply_located p)
    (var stmt @(TOKEN p))

    (parse_blanks p)
    (if (== (parse_char p '\n') @C_FALSE) (return @FALSE))

    (if (!= (node_bhead stmt) Located) (throw
        (unexpected_error (get_loc p)
            (string "parse_statement must returns Locate{...}")
            stmt))
        )

    (parsed p stmt)
    (flush_parser p @FALSE)
    (return @FALSE)
    ))

(fun print_prompt (p sign) (
    (var line (field_get p 8))
    (output_string stdout (prompt_string))
    (output_char stdout ':')
    (output_int stdout line)
    (output_string stdout sign)
    (flush stdout)
    ))

(export fun parse_shell_statement (p) (
    (var save_current_mod current_mod)
    (set_current_module (find_module current_mod Syntax))
    (var v (parse_shell_statement_sub p))
    (set_current_module save_current_mod)
    (return v)
    ))

(fun parse_shell_statement_sub (p) (
    (print_prompt p "> ")
    (reserve p)
    (var state (copy_parser_state p))
    (while @TRUE (do
        (= mayparse_p @FALSE)
        (parse_spaces p)
        (set_indent p (get_column p))
        (parse "statement" p)
        (if (! @(PARSED p)) (if mayparse_p (goto retry) return))
        (apply_located p)

        (var e @(TOKEN p))
        (var loc (get_loc p))

        (parse_blanks p)
        (parse_char p '\n')
        (if (! @(PARSED p)) (if mayparse_p (goto retry) return))

        (if (!= (node_bhead e) Located) (throw
            (unexpected_error (get_loc p)
                (string "parse_statement must returns Locate{...}")
                e))
            )
        (parsed p e)
        return

        (label retry)
        (clear_parser_state p state)
        (print_prompt p "~ ")
        (reserve p)
        ))
    ))

(var PVar (to_sym "parser")) ; internal use
(fun make_nodevar (idx) (
    (return (to_sym (strcat "node" (itos idx))))
    ))

(fun gen_copy_parser_state () (
    (return (tryapply (to_sym "%copy_parser_state") (list1 PVar)))
    ))
(fun gen_reset_parser_position (dst src) (
    (return (tryapply (to_sym "%reset_parser_position") (list2 dst src)))
    ))
(fun gen_set_parser_state (dst src) (
    (return (tryapply (to_sym "%set_parser_state") (list2 dst src)))
    ))

(fun gen_parsed (v) (
    (return (tryapply (to_sym "%parsed") (list2 PVar v)))
    ))

(fun gen_noparse (v) (
    (return (tryapply (to_sym "%noparse") (list2 PVar v)))
    ))

(fun gen_parse_spaces () (
    (return (tryapply (to_sym "spaces") (list1 PVar)))
    ))

(fun gen_get_token () (
    (return (make_object2 FieldRef PVar (box 2)))
    ))

(fun gen_get_error () (
    (return (make_object2 FieldRef PVar (box 3)))
    ))

(fun gen_test_parsed () (
    (return (make_object2 FieldRef PVar (box 1)))
    ))

(fun gen_test_noparse () (
    (return (make_object1 Not (gen_test_parsed)))
    ))

; Run given parser and do tests.
; If ws == true and !nospace_p, parse spaces between running the parser.
; If !multiline_p, indentation-level is checked.
(fun parse_with_check (p ws) (
    (if (! multiline_p)
        (= p (ifelse (tryapply (to_sym "%check_indent") (list1 PVar))
                p
                (gen_noparse (string "Invalid indentation"))))
        )

    (if (&& ws (! nospace_p))
        (do
            (var code 0)
            (var state (unique_sym))
            (= code (cons (defvar state (gen_copy_parser_state)) code))
            (= code (cons (gen_parse_spaces) code))
            (= code (cons p code))
            (= code (cons (mkif (gen_test_noparse)
                (gen_reset_parser_position PVar state)) code))
            (return (seq (list_reverse code)))
        ))
    (return p)
    ))

(fun compile_parser_element (pat ws) (
    (var hd (node_bhead pat))
    (if (== hd BSymbol)
        (return (parse_with_check
            (tryapply pat (list1 PVar)) ws))
        )
    (if (== hd BString)
        (return (parse_with_check
            (tryapply (to_sym "text") (list2 PVar pat)) ws)))
    (if (== hd List)
        (return (compile_seq pat ws))
        )
    (if (== hd Choice)
        (return (compile_choice pat ws))
        )
    (var len (node_size pat))
    (if (== hd Delimited) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited0 (node_arg pat 0) (node_arg pat 1) ws))
        ))
    (if (== hd Delimited1) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (node_arg pat 0) (node_arg pat 1) 1 ws))
        ))
    (if (== hd Delimited2) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (node_arg pat 0) (node_arg pat 1) 2 ws))
        ))
    (if (== hd Located) (do
        (if (!= len 1) (goto compile_error))
        (return (compile_located (node_arg pat 0) ws))
        ))
    (if (== hd ParseWith) (do
        (if (!= len 1) (goto compile_error))
        (return (compile_parse_with (node_arg pat 0) ws))
        ))
    (if (!= len 1) (goto compile_error))
    (if (== hd OneOf)
        (return (compile_oneof (node_arg pat 0) ws))
        )
    (if (== hd NoneOf)
        (return (compile_noneof (node_arg pat 0) ws))
        )
    (if (== hd Many)
        (return (compile_many (node_arg pat 0) ws))
        )
    (if (== hd Many1)
        (return (compile_many1 (node_arg pat 0) ws))
        )
    (if (== hd Option)
        (return (compile_option (node_arg pat 0) ws))
        )
    (if (== hd And)
        (return (compile_and (node_arg pat 0) ws))
        )
    (if (== hd Not)
        (return (compile_not (node_arg pat 0) ws))
        )
    (if (== hd Aligned)
        (return (compile_aligned (node_arg pat 0) ws))
        )
    (if (== hd NoSpace)
        (return (compile_nospace (node_arg pat 0) ws))
        )
    (label compile_error)
    (throw (exception current_loc (list2 (string "invalid syntax element") pat)))
    ))

(fun oneof (p tbl str) (
    (var c (lookahead p))
    (if (< c 0)
        (return (mayparse p (strcat "expect token: one of " str)))
        )
    (if (array_get char tbl c) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p
        (strcat "expect one of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun noneof (p tbl str) (
    (var c (lookahead p))
    (if (< c 0)
        (return (mayparse p (strcat "expect token: none of " str)))
        )
    (if (! (array_get char tbl c)) (do
        (getc p)
        (return (parsed p (ctos c)))
        ))
    (return (noparse p
        (strcat "expect token: none of " 
        (strcat str
        (strcat " but got " (escape_char c))))))
    ))

(fun compile_character_set (str) (
    (var tbl (allocate_string 128))
    (var len (strlen str))
    (var i 0)
    (while (< i len) (do
        (var c (array_get char str i))
        (if (== c '\\') (do ; escaped char
            (+= i 1)
            (if (== i len) (goto error))
            (= c (array_get char str i))
            (if (== c 'a') (array_set char tbl '\a' 1)
            (if (== c 'b') (array_set char tbl '\b' 1)
            (if (== c 'f') (array_set char tbl '\f' 1)
            (if (== c 'n') (array_set char tbl '\n' 1)
            (if (== c 'r') (array_set char tbl '\r' 1)
            (if (== c 't') (array_set char tbl '\t' 1)
            (if (== c 'v') (array_set char tbl '\v' 1)
            (if (== c '0') (array_set char tbl '\0' 1)
                (array_set char tbl c 1)
                ))))))))
            (+= i 1)
            continue
            ))
        (if (== (array_get char str (+ i 1)) '-') (do
            (if (>= (+ i 2) len) (goto error))
            (var d (array_get char str (+ i 2)))
            (if (> c d) (goto error))
            (while (<= c d) (do
                (array_set char tbl c 1)
                (+= c 1)
                ))
            (+= i 3)
            continue
            ))
        (array_set char tbl c 1)
        (+= i 1)
        ))
    (return tbl)
    (label error)
    (throw (invalid_argument current_loc 
        (string "invalid character-set")
        str
        ))
    ))

(fun compile_oneof (str ws) (
    (var tbl (compile_character_set str))
    (return (parse_with_check
        (tryapply (to_sym "%oneof") (list3 PVar tbl str)) ws))
    ))

(fun compile_noneof (str ws) (
    (var tbl (compile_character_set str))
    (return (parse_with_check
        (tryapply (to_sym "%noneof") (list3 PVar tbl str)) ws))
    ))

; List{ p1, p2, ...} is translated to
;
; breakable {
;   ret = []
;   p1
;   if (noparse) break 
;   ret = cons(token(), ret)
;   p2 (with spaces)
;   if (noparse) break
;   ret = cons(token(), ret)
;   ...
;   Parsed{reverse(ret)}

(fun compile_seq (elems ws) (
    (if (! elems)
        (throw (exception current_loc (string "[] is not valid syntax element")))
        )

    (var body 0)
    (var ret (unique_sym))
    (= body (cons (defvar ret 0) body))
    (while elems (do
        (= body (cons (compile_parser_element (car elems) ws) body))
        (= body (cons (mkif (gen_test_noparse) (make_object0 Break)) body))
        (= ws @TRUE)
        (= body (cons (assign ret (tryapply (to_sym "%cons") (list2 (gen_get_token) ret))) body))
        (= elems (cdr elems))
        ))
    (= body (cons (gen_parsed (tryapply (to_sym "%reverse") (list1 ret))) body))
    (return (breakable (list_reverse body)))
    ))

; Choice{ p1, p2, .. } is translated to
; breakable {
;     p1
;     if (parsed) break
;     p2
;     if (parsed) break
;     ...
; }

(fun compile_choice (ps ws) (
    (if (< (node_size ps) 2)
        (throw (unexpected_error current_loc
            (string "require more than 1 arguments")
            ps
            )))

    (var body 0)
    (rfor i 0 (node_size ps) (do
        (= body (cons (compile_parser_element (node_arg ps i) ws) body))
        (= body (cons (mkif (gen_test_parsed) (make_object0 Break)) body))
        ))

    (return (breakable (list_reverse body)))
    ))

; Many{ p } is translated to
;
; elems = []
; breakable {
;    p
;    if noparse break
;    elems = cons(token(), elems)
;    while true {
;        p (with spaces)
;        if noparse break
;        elems = cons(token(), elems)
;    }
; }
; Parsed{reverse(elems)}

(fun compile_many (elem ws) (
    (var elems (unique_sym))

    (var loop_body 0)
    (= loop_body (cons (compile_parser_element elem @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (compile_parser_element elem ws) body))
    (= body (cons (mkif (gen_test_noparse) (make_object0 Break)) body))
    (= body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) body))
    (= body (cons (make_object2 While @C_TRUE
        (block (list_reverse loop_body))) body))

    (return (block (list3
        (defvar elems 0)
        (breakable (list_reverse body))
        (gen_parsed (tryapply (to_sym "%reverse") (list1 elems)))
        )))
    ))

; Many1{ p } is translated to
;
; breakable {
;    elems = []
;    p
;    if noparse break
;    elems = cons(token(), elems)
;    while true {
;        p (with spaces)
;        if noparse break
;        elems = cons(token(), elems)
;    }
;    Parsed{reverse(elems)}
; }

(fun compile_many1 (elem ws) (
    (var elems (unique_sym))

    (var loop_body 0)
    (= loop_body (cons (compile_parser_element elem @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (compile_parser_element elem ws) body))
    (= body (cons (mkif (gen_test_noparse) (make_object0 Break)) body))
    (= body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) body))
    (= body (cons (make_object2 While @C_TRUE
        (block (list_reverse loop_body))) body))
    (= body (cons (gen_parsed (tryapply (to_sym "%reverse") (list1 elems))) body))
    (return (breakable (list_reverse body)))
    ))

; Aligned{ p } is translated to
;
; breakable {
;     elems = []
;     state = copy_parser_state(..)
;     column = get_column(p)
;     set_indent(p, column)
;     run p
;     if (noparse) {
;         reset_parser_position(p, state)
;         parsed([])
;         break
;     }
;     while true {
;         elems = cons(token(), elems)
;         set_parser_state(state, p)
;         parse_spaces()
;         if (get_column(p) != column) {
;             break
;         }
;         set_indent(p, column)
;         run p
;         if (noparse) {
;             break
;         }
;     }
;     reset_parser_position(p, state)
;     reset_indent(p)
;     parsed(reverse(elems))
; }

(fun compile_aligned (elem ws) (
    (var state (unique_sym))
    (var elems (unique_sym))
    (var clmn  (unique_sym))
    (var indent_save (unique_sym))

    (var loop_body 0)
    (= loop_body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (gen_parse_spaces) loop_body))
    (= loop_body (cons (mkif 
            (make_object2 NotEqual
                (tryapply (to_sym "%get_column") (list1 PVar))
                clmn
                )
            (make_object0 Break)) loop_body))
    (= loop_body (cons (tryapply (to_sym "%set_indent") (list2 PVar clmn)) loop_body))
    (= loop_body (cons (compile_parser_element elem @FALSE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))

    (if (|| ws (! nospace_p))
        (= body (cons (gen_parse_spaces) body))
        )

    (= body (cons (defvar clmn (tryapply (to_sym "%get_column") (list1 PVar))) body))
    (= body (cons (defvar indent_save (tryapply (to_sym "%set_indent") (list2 PVar clmn))) body))
    (= body (cons (compile_parser_element elem @FALSE) body))
    (= body (cons (mkif (gen_test_noparse)
            (block (list3
                (gen_reset_parser_position PVar state)
                (gen_parsed 0)
                (make_object0 Break)
            )))
        body))
    (= body (cons (make_object2 While @C_TRUE
            (block (list_reverse loop_body))) body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (tryapply (to_sym "%set_indent") (list2 PVar indent_save)) body))
    (= body (cons (gen_parsed (tryapply (to_sym "%reverse") (list1 elems))) body))
    (return (breakable (list_reverse body)))
    ))

; Delimited{ p, delim } is translated to
;
; breakable {
;     elems = []
;     state = copy_parser_state(..)
;     run p
;     if noparse {
;         reset_parser_position(..)
;         parsed([])
;         break
;     }
;     elems = cons(token(), elems)
;     while true {
;         set_parser_state(state, p)
;         run delim (with spaces)
;         if noparse break
;         run p (with spaces)
;         if noparse break
;         elems = cons(token(), elems)
;     }
;     reset_parser_position(p, state)
;     parsed(reverse(elems))
; }

(fun compile_delimited0 (p delim ws) (
    (var state (unique_sym))
    (var elems (unique_sym))

    (var loop_body 0)
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (compile_parser_element delim @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (compile_parser_element p @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (= body (cons (compile_parser_element p ws) body))
    (= body (cons (mkif (gen_test_noparse)
        (block (list3
            (gen_reset_parser_position PVar state)
            (gen_parsed 0)
            (make_object0 Break)
            ))) body))
    (= body (cons
        (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) body))
    (= body (cons
        (make_object2 While @C_TRUE (block (list_reverse loop_body)))
        body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (gen_parsed (tryapply (to_sym "%reverse") (list1 elems)))
            body))
    (return (breakable (list_reverse body)))
    ))

(fun compile_delimited (p delim minlen ws) (
    (var state (unique_sym))
    (var elems (unique_sym))

    (var loop_body 0)
    (= loop_body (cons (gen_set_parser_state state PVar) loop_body))
    (= loop_body (cons (compile_parser_element delim @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (compile_parser_element p @TRUE) loop_body))
    (= loop_body (cons (mkif (gen_test_noparse) (make_object0 Break)) loop_body))
    (= loop_body (cons (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) loop_body))

    (var body 0)
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (= body (cons (compile_parser_element p ws) body))
    (= body (cons (mkif (gen_test_noparse) (block (list2
        (gen_noparse (string "The number of elements is insufficient"))
        (make_object0 Break)
        ))) body))
    (= body (cons
        (assign elems (tryapply (to_sym "%cons") (list2 (gen_get_token) elems))) body))
    (= body (cons
        (make_object2 While @C_TRUE (block (list_reverse loop_body)))
        body))
    (= body (cons (gen_reset_parser_position PVar state) body))
    (= body (cons (mkif
        (tryapply (to_sym "lt")
            (list2 (tryapply (to_sym "%length") (list1 elems))
                (box minlen))) (block (list2
        (gen_noparse (string "The number of elements is insufficient"))
        (make_object0 Break)
        ))) body))
    (= body (cons (gen_parsed (tryapply (to_sym "%reverse") (list1 elems)))
            body))
    (return (breakable (list_reverse body)))
    ))

; Located{ p } is translated to
;
; v = p
; if (head(v) == NoParse) return
; Parsed{loc, Located{loc, v}}
(fun compile_located (p ws) (
    (= p (compile_parser_element p ws))
    (return (block (list2 p (tryapply (to_sym "%apply_located") (list1 PVar)))))
    ))

; parsewith{ sym } is translated to
(fun compile_parse_with (sym ws) (
    (return (parse_with_check (tryapply sym (list1 PVar)) ws))
    ))

; Option{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; if (head(v) == NoParse) {
;   reset_parser_position(parser, state)
;   nil
; } else
;   Parsed{loc(v), Some{val(v)}}
(fun compile_option (p ws) (
    (var state (unique_sym))
    (return (block (list3
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (ifelse
            (gen_test_noparse)
            (block (list2
                (gen_reset_parser_position PVar state)
                (gen_parsed @C_NIL)
                ))
            (gen_parsed (qquote (make_object1 Some (unquote (gen_get_token)))))
            ))))
    ))

; And{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; reset_parser_position(parser, state)
; v
(fun compile_and (p ws) (
    (var state (unique_sym))
    (return (block (list3
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (gen_reset_parser_position PVar state)
        )))
    ))

; Not{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; reset_parser_position(parser, state)
; negate(v,p)
(fun compile_not (p ws) (
    (var state (unique_sym))
    (return (block (list4
        (defvar state (gen_copy_parser_state))
        (compile_parser_element p ws)
        (gen_reset_parser_position PVar state)
        (tryapply (to_sym "%negate") (list1 PVar))
        )))
    ))

(fun compile_nospace (elem ws) (
    (var save_nospace_p nospace_p)
    (= nospace_p @TRUE)
    (var p (compile_parser_element elem ws))
    (= nospace_p save_nospace_p)
    (return p)
    ))

(fun compile_parser_action (elems act) (
    (if (!= (node_bhead elems) List)
        (= elems (list1 elems))
        )

    (var idx 0)
    (var body 0)
    (var bpos (unique_sym))

    (= body (cons (defvar bpos (tryapply (to_sym "%get_pos") (list1 PVar))) body))

    (var with_spaces @FALSE)
    (while elems (do
        (var ndvar (make_nodevar idx))
        (= body (cons (compile_parser_element (car elems) with_spaces) body))

        (if (! nospace_p) (= with_spaces @TRUE))

        (= body (cons (mkif (gen_test_noparse) (make_object0 Break)) body))
        (= body (cons (defvar ndvar (gen_get_token)) body))
        (incr idx)
        (= elems (cdr elems))
        ))

    (= body (cons (defvar (to_sym "begin") bpos) body))
    (= body (cons (defvar (to_sym "end")
        (tryapply (to_sym "%get_pos") (list1 PVar))) body))

    (= body (cons (gen_parsed act) body))
    (return (breakable (list_reverse body)))
    ))

(var multiline (to_sym "multiline"))
(fun setup_options (opts) (
    (if (!= (node_bhead opts) List)
        (= opts (list1 opts))
        )
    (while opts (do
        (var opt (car opts))
        (if (== opt multiline)
            (= multiline_p @TRUE)
            (throw (unexpected_error current_loc
                (string "unknown parser option") opt))
            )
        (= opts (cdr opts))
        ))
    ))

(fun clear_options () (
    (= nospace_p @FALSE)
    (= multiline_p @FALSE)
    ))

(var idx 0)
(fun compile_parser (elems) (
    (if (!= (node_bhead elems) List)
        (= elems (list1 elems))
        )
    (+= idx 1)

    (var body 0)
    (var state (unique_sym))
    (var error (unique_sym))

    (= body (cons (defvar state (gen_copy_parser_state)) body))
    (while elems (do
        (var t (car elems))
        (var size (node_size t))
        (if (|| (!= (node_bhead t) Tuple) (|| (< size 2) (> size 3))) (do
            (throw (unexpected_error current_loc
                (string "Entries of syntax definition must be form of (parser, action, [options])")
                t))
            ))
        (if (== size 3)
            (setup_options (node_arg t 2))
            )

        (var act (compile_parser_action (node_arg t 0) (node_arg t 1)))
        (= body (cons act body))
        (= body (cons (mkif (gen_test_parsed) (make_object0 Break)) body))
        (= body (cons (gen_reset_parser_position PVar state) body))
        (= elems (cdr elems))
        (clear_options)
        ))
    (return (lambda (list1 PVar) (breakable (list_reverse body))))
    ))

(extern fun compile_matching)
(fun call_parser (p sym key fun) (
    (var tbl (field_get (field_get p 4) 2))
    (var pos (field_get p 6))
    (var v (memotable_find tbl key pos (field_get p 7)))
    (if v (do
        (if (field_get v 1) (do
            ; detected left-recursion
            (field_set v 0 (copy_parser_state (field_get v 0)))
            (field_set v 2 @TRUE)
            ))
        (set_parser_state p (field_get v 0))
        (return @(PARSED_FLAG p))
        ))
    (var loc (get_loc p))
    (var state (copy_parser_state p))
    (noparse state left_rec)

    ; state,possibly left-recursive,left-rec detected,parsed
    (var ent (struct 1 state @TRUE @FALSE @FALSE))
    (memotable_add tbl key pos (field_get p 7) ent)
    (label retry_lbl)
    (byterun (compile_matching loc sym fun) p)

    (if (field_get ent 2)
        (if (&& @(PARSED p)
                (> (field_get p 6) (field_get (field_get ent 0) 6)))
            (do
                (set_parser_state (field_get ent 0) p)
                (set_parser_state p state)
                (field_set ent 3 @TRUE)
                (goto retry_lbl)
            )
            (do
                (if (field_get ent 3)
                    (set_parser_state p (field_get ent 0))
                    (reset_parser_position p (field_get ent 0))
                    )
                (return @(PARSED_FLAG p))
            )))
    ; not left-recursive
    (field_set ent 3 @TRUE)
    (set_parser_state (field_get ent 0) p)
    (return @(PARSED_FLAG p))
    ))

(var key_idx 0)
(export fun compile_define_syntax (sym elems) (
    (var key (to_sym (strcat "%key" (itos key_idx))))
    (var parser_body (compile_parser elems))
    (var parser (tryapply (to_sym "%call_parser")
            (list4 PVar (quote sym) (quote key) parser_body)))
    (+= key_idx 1)
    (return (make_object2 DefFunction sym
        (lambda (make_object2 When
            (list1 (make_object2 Domain PVar Parser)) parser)
            @C_TRUE)))
    ))

(export fun add_reserve_symbol (sym) (
    (= reserved_symbols (cons sym reserved_symbols))
    ))

(fun return_true (p) (
    (return @C_TRUE)
    ))

(fun add_parser (mod sym func) (
    (add_function1 mod sym (domainP Parser) func 0)
    ))

(extern object global)

(export fun enable_shell_syntax () (
    (call0 (qualified "Syntax" (to_sym "enable_shell_syntax")))
    ))

(export fun init_parser_funcs (syntax) (
    (add_function1 syntax (to_sym "%get_column") DontCare get_column 0)
    (add_function2 syntax (to_sym "%set_indent") DontCare DontCare set_indent 0)
    (add_function1 syntax (to_sym "%check_indent") DontCare check_indent 0)
    (add_function2 syntax (to_sym "%parsed") DontCare DontCare parsed 0)
    (add_function2 syntax (to_sym "%noparse") DontCare DontCare noparse 0)
    (add_function1 syntax (to_sym "%copy_parser_state") DontCare copy_parser_state 0)
    (add_function2 syntax (to_sym "%reset_parser_position") DontCare DontCare reset_parser_position 0)
    (add_function2 syntax (to_sym "%set_parser_state") DontCare DontCare set_parser_state 0)
    (add_function1 syntax (to_sym "%print_parser_state") DontCare print_parser_state 0)
    (add_function4 syntax (to_sym "%call_parser") DontCare DontCare DontCare DontCare call_parser 0)
    (add_function1 syntax (to_sym "%negate") DontCare negate 0)
    (add_function3 syntax (to_sym "%oneof") DontCare DontCare DontCare oneof 0)
    (add_function3 syntax (to_sym "%noneof") DontCare DontCare DontCare noneof 0)
    (add_function1 syntax (to_sym "%apply_located") DontCare apply_located 0)
    (add_function1 syntax (to_sym "%get_pos") DontCare get_pos 0)

    ; Use internal version of list operations considering redefinition of them.
    (add_function2 syntax (to_sym "%cons") DontCare DontCare __cons 0)
    (add_function1 syntax (to_sym "%reverse") DontCare __reverse 0)
    (add_function1 syntax (to_sym "%length") DontCare __length 0)

    (add_function3 syntax (to_sym "input_text") (domainP Parser) intT intT get_input_text 0)

    (add_parser syntax (to_sym "spaces") parse_spaces)
    (add_parser syntax (to_sym "blanks") parse_blanks)

    (add_function2 syntax (to_sym "text") (domainP Parser) stringT parse_text 0)
    (add_parser syntax (to_sym "any") parse_any_char)
    (add_parser syntax (to_sym "blank") parse_blank)
    (add_parser syntax (to_sym "comment") parse_fail)
    (add_parser syntax (to_sym "shell_style_comment") parse_shell_style_comment)
    (add_parser syntax (to_sym "C_style_comment") parse_C_style_comment)
    (add_parser syntax (to_sym "decimal") parse_decimal)
    (add_parser syntax (to_sym "binary") parse_binary)
    (add_parser syntax (to_sym "octal") parse_octal)
    (add_parser syntax (to_sym "hex") parse_hex)
    (add_parser syntax (to_sym "integer") parse_integer)
    (add_parser syntax (to_sym "float") parse_float)
    (add_parser syntax (to_sym "string") parse_string)
    (add_parser syntax (to_sym "string_d") parse_string_d)
    (add_parser syntax (to_sym "string_s") parse_string_s)
    (add_parser syntax (to_sym "symbol") parse_symbol)
    (add_parser syntax (to_sym "atom") parse_atom)
    (add_parser syntax (to_sym "object") parse_object)
    (add_parser syntax (to_sym "expr") parse_expr)
    (add_parser syntax (to_sym "statement") parse_statement)
    ))

(export fun output_syntax_error (loc e) (
    (output_string stderr "Syntax Error ")
    (pp_loc stderr loc)
    (output_string stderr " : ")
    (output_string stderr e)
    (output_char stderr '\n')
    ))

    ))
