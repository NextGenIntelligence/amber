;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-packrat.rlc 2012-07-04 03:04:29 nineties $
;

; TODO:
; parse_statement and `scoped' syntax elements may have side-effects.
; Further validation is required.

(import "rlvm-compile")
(import "rowl1-types")

; character groups
(var CH_EOS        0) ; "\0"
(var CH_SPACES     1) ; "\t\r\n "
(var CH_0          2) ; "0"
(var CH_1          3) ; "1"
(var CH_2_7        4) ; "234567"
(var CH_8_9        5) ; "89"
(var CH_af         6) ; "af"
(var CH_b          7) ; "b"
(var CH_e          8) ; "e"
(var CH_HEX        9) ; "ABCDEFcd"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_OTHER     14) ; "GHIJKLMNOPQRSTUVWXYZcdghijklmpqsuwuz_"
(var CH_SHARP     15) ; "#"
(var CH_INVALID   16)

; fixed-length integers are 31-bits because of boxing
(var INTEGER_MAX  (- (<< 1 30) 1))

; end of file
(var EOF -2)

(define CHGRP (c) `(array_get char chgroup @c))
(define MEMOIZE (sym)
    `(export fun @(s++ `parse_ sym) (p) (
        (var s (to_sym @(++ "parse_" sym "_")))
        (var tbl (field_get (field_get p 1) 2))
        (var pos (field_get p 3))
        (var v (memotable_find tbl s pos))
        (if v (do
            (set_parser_state p (field_get v 1))
            (return (field_get v 0))
            ))
        (= v (@(s++ `parse_ sym '_') p))
        (var state (copy_parser_state p))
        (memotable_add tbl s pos (struct 2 v state @FALSE))
        (return v)
    )))

(define OR (p ps) (do
    (var end_lbl (mklabel))
   `(do
        (var state (copy_parser_state @p))
        (var v 0)
        (var errors 0)
        (do . @(map (lambda (f) 
            `(do
              (= v (@(s++ `parse_ f) @p))
              (if (== (expr_head v) Parsed) (goto @end_lbl))
              (= errors (merge_noparse errors v))
              (set_parser_state @p state)
             )) ps))
        (= v errors)
        (label @end_lbl)
        v
    )))
(define CHECK (v)
    `(do
        (var s @v)
        (if (== (expr_head s) NoParse) (return s))
    ))

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-module")
(import "rowl1-error")

(array char chgroup (
     0 16 16 16 16 16 16 16 16  1  1 16 16  1 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
     1 16 16 15 16 16 16 16 16 16 16 16 16 16 16 16
     2  3  4  4  4  4  4  4  5  5 16 16 16 16 16 16
    16  9  9  9  9  9  9 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 16 16 16 16 14
    16  6  7  9  9  8  6 14 14 14 14 14 14 14 13 10
    14 14 11 14 11 14 11 14 12 14 14 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
    ))

; hashtable for memoization
; key:   (non-terminal symbol, position (integer))
; value: (node, parser state)
;
; structure of tables
;   0 : bucket (vector)
;   1 : entries (vector)
;   
; structure of entries
;   0 : symbol
;   1 : expr
;   2 : pointer to the next entry
;   3 : position value
;   4 : hash value

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

(fun make_memotable (hint) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (struct 2 (make_vector size) (make_vector 0)))
    ))

(fun memotable_clear (table) (
    (vector_clear (field_get table 0))
    (vector_resize (field_get table 1) 0)
    ))

(fun hash (sym pos) (
    (var h (field_get sym @SymbolIndex))
    (= h (+ (* 7 h) pos))
    (return h)
    ))

(fun rehash (table) (
    (var old_size (vector_size (field_get table 0)))
    (var num_ent  (vector_size (field_get table 1)))
    (if (>= num_ent old_size) (do
        (var new_size (array_get int prime_numbers (bsr num_ent)))
        (if (! new_size) (error "rehash: too many entries"))
        (var bucket (make_vector new_size))
        (var entries (field_get table 1))
        (for i 0 (vector_size entries) (do
            (var entry (vector_at entries i))
            (if (! entry) continue)
            (var h (% (field_get entry 4) new_size))
            (field_set entry 2 (vector_at bucket h))
            (vector_put bucket h entry)
            ))
        (field_set table 0 bucket)
        ))
    ))

(fun memotable_add (table sym pos obj) (
    (rehash table)

    (var bucket (field_get table 0))
    (var entries (field_get table 1))
    (var size (vector_size bucket))
    (var h (hash sym pos))

    (var ent (struct 3 sym obj 0 pos h))
    (%= h size)

    (vector_pushback entries ent)

    (field_set ent 2 (vector_at bucket h))
    (vector_put bucket h ent)
    ))

(fun memotable_find (table sym pos) (
    (var bucket (field_get table 0))
    (var size (vector_size bucket))
    (var h (hash sym pos))
    (%= h size)
    (var entry (vector_at bucket h))
    (while entry (do
        (var e_sym (field_get entry 0))
        (var e_pos (field_get entry 3))
        (if (&& (== e_sym sym) (== e_pos pos))
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return 0)
    ))

(var space_sensitive_p @FALSE)
(var multiline_p @FALSE)
(var shell_mode_p @FALSE)
(var may_parse @FALSE)
(var LeftRec (noparse no_loc "Left Recursion Detection"))

(extern object current_mod)
(extern fun set_current_module)

(fun trace (obj) (
    (return (make_expr Block (list2
        (apply (to_sym "print") (list2 (to_sym "stderr") obj))
        (apply (to_sym "print") (list2 (to_sym "stderr") (string "\n")))
        )))
    ))

(export fun set_shell_mode () (
    (= shell_mode_p @TRUE)
    ))

(export fun unset_shell_mode () (
    (= shell_mode_p @FALSE)
    ))

(export fun in_shell_mode () (
    (return shell_mode_p)
    ))

(export fun parse (name p) (
    (var code (lookup_func current_mod (to_sym name)))
    (return (byterun code p))
    ))

(fun parsed (loc val) (
    (return (make_expr Parsed (list2 loc val)))
    ))

(fun mayparse (loc msg) (
    (= may_parse @TRUE)
    (return (make_expr NoParse (list1 (list2 loc (string msg)))))
    ))

(fun noparse (loc msg) (
    (return (make_expr NoParse (list1 (list2 loc (string msg)))))
    ))

(fun merge_noparse (lhs rhs) (
    (if (! lhs) (return rhs))
    (if (! rhs) (return lhs))
    (if (== lhs LeftRec) (return rhs))
    (if (== rhs LeftRec) (return lhs))
    (return (make_expr NoParse (list_append (expr_args lhs) (expr_args rhs))))
    ))

(fun negate (p val) (
    (var hd (expr_head val))
    (var loc (get_loc p))
    (if (== hd Parsed)
        (return (noparse loc "unexpected token"))
        (return (parsed loc nil))
        )
    ))

(fun apply_located (v) (
    (expr_arg_set v 1 (located (expr_arg v 0) (expr_arg v 1)))
    (return v)
    ))

(fun integer_overflow (loc) (
    (return (noparse loc "integer literal is too large"))
    ))

(fun junk_letter (loc) (
    (return (noparse loc "junk letter(s) at the end of integer literal"))
    ))

; structure of parser
;   0: head (ParserE)
;   1: (character buffer, input channel, table for memoization)
;   2: filename
;   3: current position in the character buffer
;   4: line number
;   5: column number
;   6: indentation

(export fun init_parser (file ichan) (
    ; character buffer
    (var cbuf (make_cvector 0))
    ; current position in cbuf
    (var pos 0)
    ; offset + pos is the number of total characters from the beginning of parsing
    (var offset 0)

    ; table for memoization
    (var memo (make_memotable 1000))
    (var buf (struct 3 cbuf ichan memo))

    (return (variant @ParserE 2 buf (string file) pos 1 1 1))
    ))

(export fun flush_parser (p force) (
    (var buf (field_get p 1))
    (var cbuf (field_get buf 0))
    (var bufsz (cvector_size cbuf))
    (var pos (field_get p 3))

    ; XXX: Not good implementation.
    ; Ring buffer is better.
    (if (|| (>= pos bufsz) force) (do
        (cvector_resize cbuf 0)
        (field_set p 3 0)
        ))

    (memotable_clear (field_get buf 2))
    (if shell_mode_p (field_set p 4 (+ (field_get p 4) 1)))
    ))

(fun copy_parser_state (p) (
    (var copy (variant @ParserE 2 0 0 0 0 0 0))
    (memcpy copy p (* 7 @WORD_SIZE))
    (return copy)
    ))

(fun set_parser_state (dst src) (
    ; NB: indent-level is not copied.
    (memcpy dst src (* 6 @WORD_SIZE))
    ))

(fun clear_parser_state (p state) (
    (var buf (field_get p 1))
    (set_parser_state p state)
    (memotable_clear (field_get buf 2))
    ))

(fun extract_string (from p) (
    (var begin (field_get from 3))
    (var end   (field_get p 3))
    (var len (- end begin))
    (var vec (field_get (field_get p 1) 0))
    (return (strndup (+ (cvector_raw vec) begin) len))
    ))

(export fun get_loc (p) (
    (var line (field_get p 4))
    (return (make_loc (field_get p 2) line line))
    ))

(fun get_column (p) (
    (return (box (field_get p 5)))
    ))

(fun get_indent (p) (
    (return (box (field_get p 6)))
    ))

; set new indentation-level and return current indentation-level
(fun set_indent (p c) (
    (var current_indent (field_get p 6))
    (field_set p 6 (unbox c))
    (return (box current_indent))
    ))

(fun reserve (p) (
    (var buf (field_get p 1))
    (var vec (field_get buf 0))
    (var ichan (field_get buf 1))
    (var line 0)
    (var c 0)
    (while (>= (input_char (address c) ichan) 0) (do
        (cvector_pushback vec c)
        (if (|| (== c '\n') (== c '\0')) (return 0))
        ))
    (return -1)
    ))

(fun lookahead (p) (
    (var buf (field_get p 1))
    (var vec (field_get buf 0))
    (var idx (field_get p 3))
    (if (>= idx (cvector_size vec)) (do
        (if (&& (! shell_mode_p) (< (reserve p) 0))
            (return @EOF)
            )
        ))
    (if (>= idx (cvector_size vec))
        (return -1)
        )
    (return (cvector_at vec idx))
    ))

(fun getc (p) (
    (var c (lookahead p))
    (if (< c 0) (return c))
    ; update source location
    (if (== c '\n') (do
        (if (! shell_mode_p)
            (field_set p 4 (+ (field_get p 4) 1))
            )
        (field_set p 5 0)
        ))
    (field_set p 3 (+ (field_get p 3) 1))
    (field_set p 5 (+ (field_get p 5) 1))
    (return c)
    ))

; utilities
(fun is_spaces (c) (
    (return (== @(CHGRP c) @CH_SPACES))
    ))
(fun is_01 (c) (
    (= c @(CHGRP c))
    (return (|| (== c @CH_0) (== c @CH_1)))
    ))
(fun is_0_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_8_9)))
    ))
(fun is_1_9 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_1 c) (<= c @CH_8_9)))
    ))
(fun is_0_7 (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_2_7)))
    ))
(fun is_hexdigit (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_HEX)))
    ))
(fun is_letter (c) (
    (= c @(CHGRP c))
    (return (&& (<= @CH_af c) (<= c @CH_OTHER)))
    ))
(fun is_identchar (c) (
    (if (< c 0) (return @FALSE))
    (= c @(CHGRP c))
    (return (&& (<= @CH_0 c) (<= c @CH_OTHER)))
    ))
(var escape_chars "'\"\\abfnrtv0")
(fun is_escape_char (c) (
    (for i 0 (strlen escape_chars) (do
        (if (== c (array_get char escape_chars i))
            (return @TRUE)
        )))
    (return @FALSE)
    ))
(fun is_end_of_token (p) (
    (var c (lookahead p))
    (if (< c 0) (return @TRUE))
    (= c @(CHGRP c))
    (return (|| (< c @CH_0) (> c @CH_OTHER)))
    ))

(fun parse_char (p c) (
    (var loc (get_loc p))
    (var v (getc p))
    (if (< v 0)
        (return (mayparse loc (strcat "expect " (escape_char c))))
        )
    (if (== v c) (do
        (return (parsed loc (ctos c)))
        ))
    (return (noparse loc 
        (strcat "expect " 
        (strcat (escape_char c)
        (strcat " but got " (escape_char v))))))
    ))

(fun parse_any_char (p) (
    (var loc (get_loc p))
    (var c (getc p))
    (if (< c 0)
        (return (mayparse loc "end of input stream"))
        (return (parsed loc (ctos c)))
        )
    ))

(fun parse_text (p str) (
    (var loc (get_loc p))
    (var i 0)
    (var len (strlen str))
    (for i 0 len (do
        (var c (array_get char str i))
        (var v (getc p))
        (if (< v 0) (return (mayparse loc (strcat "expect " str))))
        (if (!= c v) (return (noparse loc (strcat "expect " str))))
        ))
    (return (parsed loc (string str)))
    ))

; parse_integers
; multi-precision integer is not supported for now
(fun parse_decimal_ (p) (
    (var loc (get_loc p))
    (var v (getc p))

    (if (< v 0) (return (mayparse p "expect a number")))
        
    (if (&& (== v '0') (is_end_of_token p))
        (return (parsed loc (box 0)))
        )
    (if (! (is_1_9 v)) (return (noparse p "expect 1-9")))
    (var value (- v '0'))
    (while (is_0_9 (lookahead p)) (do
        (= v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 10))
            (return (integer_overflow p))
            )
        (= value (+ (* value 10) v))
        ))
    (if (is_end_of_token p)
        (return (parsed loc (box value)))
        )
    (if (== (lookahead p) 'e') (do
        (getc p)
        (var exp (parse_decimal p))
        @(CHECK exp)
        (= exp (unbox (expr_arg exp 1)))
        (while (> exp 0) (do
            (if (> value (/ @INTEGER_MAX 10))
                (return (integer_overflow loc))
                )
            (*= value 10)
            (-= exp 1)
            ))
        (return (parsed loc (box value)))
        ))
    (return (junk_letter loc))
    ))
@(MEMOIZE decimal)

(fun parse_binary_ (p) (
    (var loc (get_loc p))
    @(CHECK `(parse_text p "0b"))
    (if (! (is_01 (lookahead p))) (return (noparse loc "expect 0 or 1")))
    (var value 0)
    (while (is_01 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (/ (- @INTEGER_MAX v) 2))
            (return (integer_overflow loc))
            )
        (= value (| (<< value 1) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE binary)

(fun parse_octal_ (p) (
    (var loc (get_loc p))
    @(CHECK `(parse_text p "0o"))
    (if (! (is_0_7 (lookahead p))) (return (noparse loc "expect 0-7")))
    (var value 0)
    (while (is_0_7 (lookahead p)) (do
        (var v (- (getc p) '0'))
        (if (> value (>> (- @INTEGER_MAX v) 3))
            (return (integer_overflow loc))
            )
        (= value (+ (<< value 3) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE octal)

(fun parse_hex_ (p) (
    (var loc (get_loc p))
    @(CHECK `(parse_text p "0x"))
    (if (! (is_hexdigit (lookahead p))) (return (noparse loc "expect hex digit")))
    (var value 0)
    (while (is_hexdigit (lookahead p)) (do
        (var v (getc p))
        (if (<= 'a' v)
            (= v (+ (- v 'a') 10))
        (if (<= 'A' v)
            (= v (+ (- v 'A') 10))
            (= v (- v '0'))
            ))
        (if (> value (>> (- @INTEGER_MAX v) 4))
            (return (integer_overflow loc))
            )
        (= value (+ (<< value 4) v))
        ))
    (if (! (is_end_of_token p))
        (return (junk_letter loc))
        )
    (return (parsed loc (box value)))
    ))
@(MEMOIZE hex)

(fun parse_integer_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(decimal hex octal binary)))
    (if (== (expr_head v) NoParse) (return (noparse loc "expect integer literal")))
    (return v)
    ))
@(MEMOIZE integer)

(fun parse_blank_ (p) (
    (var loc (get_loc p))
    (var c (getc p))
    (if (< c 0) (return (mayparse loc "end of input stream")))
    (if (&& (is_spaces c) (!= c '\n')) (return (parsed loc (ctos c))))
    (return (noparse loc "expect a blank character"))
    ))
@(MEMOIZE blank)

(fun parse_blanks_ (p) (
    (var loc (get_loc p))
    (var code (lookup_func current_mod (to_sym "parse_blank")))
    (var state (copy_parser_state p))
    (while (== (expr_head (byterun code p)) Parsed) (do
        (set_parser_state state p)
        ))
    (set_parser_state p state)
    (return (parsed loc nil))
    ))
@(MEMOIZE blanks)

(fun parse_spaces_ (p) (
    (var loc (get_loc p))
    (var code (lookup_func current_mod (to_sym "parse_blank")))
    (var state (copy_parser_state p))
    (while @TRUE (do
        (set_parser_state state p)
        (var v (byterun code p))
        (if (== (expr_head v) Parsed) continue)
        (set_parser_state p state)
        (= v (parse_char p '\n'))
        (if (== (expr_head v) Parsed) continue)
        (set_parser_state p state)
        break
        ))
    (if (<= (get_column p) (get_indent p)) (do
        (return (noparse loc "invalid indentation"))
        ))
    (return (parsed loc nil))
    ))
@(MEMOIZE spaces)

(fun parse_symbol_ (p) (
    (var loc (get_loc p))
    (var c (lookahead p))
    (if (< c 0) (return (mayparse loc "expect a symbol")))
    (if (! (is_letter c)) (return (noparse loc "expect a symbol")))
    (var begin (copy_parser_state p))
    (while (is_identchar (lookahead p)) (do
        (getc p)
        ))
    (return (parsed loc (to_sym (extract_string begin p))))
    ))
@(MEMOIZE symbol)

; single-quoted string literal
;   Only escape sequence \' is interpreted.
(fun parse_string_s_ (p) (
    (var loc (get_loc p))
    (var v (getc p))
    (if (< v 0) (return (mayparse loc "expect '")))
    (if (!= v ''') (return (noparse loc "expect '")))
    (var begin (copy_parser_state p))
    (while (!= (lookahead p) ''') (do
        (var c (getc p))
        (if (== c '\\') (getc p))
        ))
    (var end (copy_parser_state p))

    (= v (getc p))
    (if (< v 0) (return (mayparse loc "expect '")))
    (if (!= v ''') (return (noparse loc "expect '")))

    (var str (extract_string begin end))
    (unescape_string_s str)
    (return (parsed loc str))
    ))
@(MEMOIZE string_s)

; double-quoted string literal
(fun parse_string_d_ (p) (
    (var loc (get_loc p))

    (var v (getc p))
    (if (< v 0) (return (mayparse loc "expect \"")))
    (if (!= v '"') (return (noparse loc "expect \"")))

    (var begin (copy_parser_state p))
    (while (!= (lookahead p) '"') (do
        (var c (getc p))
        (if (< c 0) (return (mayparse loc "expect character")))

        (if (== c '\\') (do
            (if (! (is_escape_char (getc p)))
                (return (noparse loc "invalid escape sequence"))
                )
            ))
        ))
    (var end (copy_parser_state p))
    (= v (getc p))
    (if (< v 0) (return (mayparse loc "expect \"")))
    (if (!= v '"') (return (noparse loc "expect \"")))
    (var str (extract_string begin end))
    (unescape_string_d str)
    (return (parsed loc str))
    ))
@(MEMOIZE string_d)

(fun parse_string_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(string_d string_s)))
    (if (== (expr_head v) NoParse)
        (return (noparse loc "expect string literal"))
        )
    (return v)
    ))
@(MEMOIZE string)

(fun parse_node_ (p) (
    (var hd (parse_symbol p))
    (var bloc (get_loc p))
    (if (== (expr_head hd) NoParse)
        (return (noparse bloc "expect a head symbol"))
        )
    (= hd (expr_arg hd 1))

    @(CHECK `(parse_spaces p))
    @(CHECK `(parse_char p '{'))
    (parse_spaces p)

    (var args 0)
    (if (!= (lookahead p) '}') (do
        (while (> (lookahead p) 0) (do
            (var v (parse "parse_expr" p))
            @(CHECK v)
            (parse_spaces p)

            (= args (cons (expr_arg v 1) args))
            (if (== (lookahead p) '}') break)
            @(CHECK `(parse_char p ','))
            (parse_spaces p)
            ))
        ))
    @(CHECK `(parse_char p '}'))
    (var eloc (get_loc p))

    (return (parsed (merge_loc bloc eloc)
        (make_expr_user hd (list_reverse args))))
    ))
@(MEMOIZE node)

(fun parse_atom_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(
        symbol
        integer
        string
    )))
    (if (== (expr_head v) NoParse) 
        (return (noparse loc "expect an atom"))
        )
    (return v)
    ))
@(MEMOIZE atom)

(fun parse_expr_ (p) (
    (var loc (get_loc p))
    (var v @(OR p `(
        node
        atom
    )))
    (return v)
    ))
@(MEMOIZE expr)

(fun parse_statement_ (p) (
    (var v (parse "parse_expr" p))
    @(CHECK v)

    (eval_parser_command v)
    (var loc (expr_arg v 0))
    (var stmt (expr_arg v 1))
    (return (parsed loc (located loc stmt)))
    ))
@(MEMOIZE statement)

(export fun parse_statements (p) (
    (if (== (lookahead p) @EOF) (return 0))
    (var stmts 0)
    (while @TRUE (do
        (if (== (lookahead p) @EOF) break)
        (parse_spaces p)

        (if (== (lookahead p) '\n') (do
            (getc p)
            continue
            ))
        (if (== (lookahead p) @EOF) break)

        (set_indent p (get_column p))
        (var v (parse "parse_statement" p))
        @(CHECK v)
        (parse_blanks p)

        (if (== (lookahead p) @EOF) break)

        @(CHECK `(parse_char p '\n'))
        (var stmt (expr_arg v 1))
        (var loc (expr_arg v 0))

        (if (!= (expr_head stmt) Located) (do
            (output_error stderr loc)
            (output_string stderr "parse_statement must returns Located{ ... }\n")
            (exit 1)
            ))

        (= stmts (cons stmt stmts))

        ; stop continue parsing when the stmt has side-effects for parsing.
        (var hd (expr_head (expr_arg stmt 1)))
        (if (|| (== hd BeginModule)
            (|| (== hd EndModule)
            (|| (== hd Include)
            (== hd DefSyntax))))
            break
            )
        ))
    (return (list_reverse stmts))
    ))

(fun print_prompt (p sign) (
    (var line (field_get p 4))
    (output_string stdout "amber:")
    (output_int stdout line)
    (output_string stdout sign)
    (flush stdout)
    ))

(export fun parse_shell_statement (p) (
    (print_prompt p "> ")
    (reserve p)
    (var state (copy_parser_state p))
    (while @TRUE (do
        (= may_parse @FALSE)
        (parse_spaces p)

        (set_indent p (get_column p))
        (var e (parse "parse_statement" p))
        (if (== (expr_head e) NoParse) (if may_parse (goto retry) (return e)))
        (parse_spaces p)
        (var semi (parse_char p ';'))
        (if (== (expr_head semi) NoParse) (if may_parse (goto retry) (return semi)))
        (var nl (parse_char p '\n'))
        (if (== (expr_head nl) NoParse) (if may_parse (goto retry) (return nl)))

        (if (!= (expr_head (expr_arg e 1)) Located) (do
            (output_error stderr (expr_arg e 0))
            (output_string stderr "parse_statement must returns Located{ ... }\n")
            (exit 1)
            ))
        (return e)

        (label retry)
        (clear_parser_state p state)
        (print_prompt p "~ ")
        (reserve p)
        ))
    ))

(fun eval_parser_command (expr) (
    (if (!= (expr_head expr) Parsed) (return nil))
    (var loc (expr_arg expr 0))
    (= expr (expr_arg expr 1))
    (var ty (expr_head expr))
    (if (== ty Import)
        (import_module loc current_mod (expr_arg expr 0))
        )
    (return nil)
    ))

(fun add_parser (mod sym func) (
    (add_builtin_function1 mod sym (domainP Parser) func 0)
    ))

(fun to_parse (sym) (
    (return (to_sym (strcat "parse_" (symbol_name sym))))
    ))

(fun to_parse_ (sym) (
    (return (to_sym (strcat "parse_" (strcat (symbol_name sym) "_"))))
    ))

(var ParserVar (to_sym "%Parser")) ; internal use
(fun make_nodevar (idx) (
    (return (to_sym (strcat "node" (itos idx))))
    ))

(fun gen_at (node idx) (
    (return (make_expr ExprAt (list2 node (box idx))))
    ))
(fun gen_copy_parser_state (v) (
    (return (apply (to_sym "%copy_parser_state") (list1 v)))
    ))
(fun gen_set_parser_state (dst src) (
    (return (apply (to_sym "%set_parser_state") (list2 dst src)))
    ))

(fun gen_parse_spaces (cont) (
    (var tmp (unique_sym))
    (if space_sensitive_p (return cont))
    (= cont (cons (defvar tmp (apply (to_sym "%parse_spaces") (list1 ParserVar))) cont))
    (if (! multiline_p)
        (= cont (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 tmp)) (quote NoParse)))
            (mkreturn tmp)
            ) cont))
        )
    (return cont)
    ))

(fun gen_parse_spaces_break (cont) (
    (var tmp (unique_sym))
    (if space_sensitive_p (return cont))
    (= cont (cons (defvar tmp (apply (to_sym "%parse_spaces") (list1 ParserVar))) cont))
    (if (! multiline_p)
        (= cont (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 tmp)) (quote NoParse)))
            Break
            ) cont))
        )
    (return cont)
    ))

(extern object current_loc)
(fun compile_parser_element (pat) (
    (var hd (expr_head pat))
    (if (== hd Symbol)
        (return (apply (dynamic (to_parse pat))
            (list1 ParserVar))))
    (if (== hd String)
        (return (apply (dynamic (to_sym "parse_text"))
            (list2 ParserVar pat))))
    (if (== hd List)
        (return (compile_seq pat))
        )
    (if (== hd Choice)
        (return (compile_choice (expr_args pat)))
        )
    (var len (list_len (expr_args pat)))
    (if (== hd Delimited) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 0))
        ))
    (if (== hd Delimited1) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 1))
        ))
    (if (== hd Delimited2) (do
        (if (!= len 2) (goto compile_error))
        (return (compile_delimited (expr_arg pat 0) (expr_arg pat 1) 2))
        ))
    (if (!= len 1) (goto compile_error))
    (if (== hd Many)
        (return (compile_many (expr_arg pat 0)))
        )
    (if (== hd Many1)
        (return (compile_many1 (expr_arg pat 0)))
        )
    (if (== hd Option)
        (return (compile_option (expr_arg pat 0)))
        )
    (if (== hd And)
        (return (compile_and (expr_arg pat 0)))
        )
    (if (== hd Not)
        (return (compile_not (expr_arg pat 0)))
        )
    (if (== hd Aligned)
        (return (compile_aligned (expr_arg pat 0)))
        )
    (if (== hd Scoped)
        (return (compile_scoped (expr_arg pat 0)))
        )
    (label compile_error)
    (throw (exception current_loc (list2 (string "invalid syntax element") pat)))
    ))

; List{ p1, p2, ...} is translated to
;
; elems = []
; v = p1
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; parse_spaces()
; v = p2
; if (v == NoParse) (return v)
; elems = cons(val(v), elems)
; ...
; return Parsed{merge{loc(p1), loc(pn)}, reverse(elems)}

(fun compile_seq (elems) (
    (var body 0)
    (var tmp (unique_sym))
    (var ret (unique_sym))
    (var bloc (unique_sym))
    (var eloc (unique_sym))
    (var loc (to_sym "%Loc"))
    (var firstp @TRUE)

    (= body (cons (defvar tmp 0) body))
    (= body (cons (defvar ret 0) body))
    (while elems (do
        (= body (cons (assign tmp (compile_parser_element (car elems))) body))
        (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 tmp)) (quote NoParse)))
            (mkreturn tmp)
            ) body))
        (if firstp
            (= body (cons (defvar bloc (gen_at tmp 0)) body))
            )
        (= body (cons (assign ret (apply (to_sym "cons") (list2 (gen_at tmp 1) ret))) body))
        (= elems (cdr elems))
        (if elems 
            (= body (gen_parse_spaces body))
            (= body (cons (defvar eloc (gen_at tmp 0)) body))
            )
        (= firstp @FALSE)
        ))
    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (apply (to_sym "reverse") (list1 ret)))))) body))
    (return (apply
        (make_expr Lambda (list2 ParserVar
        (make_expr Block (list_reverse body))))
        (list1 ParserVar)))
    ))

; Choice{ p1, p2, .. } is translated to
;
; lambda() {
;     errors = 0
;     state = copy_parser_state(parser)
;     v = p1
;     if (head(v) == Parsed) (return v)
;     errors = merge_noparse(errors, v)
;     set_parser_state(parser, state)
;     v = p2
;     ...
; }(p)

(fun compile_choice (ps) (
    (if (< (list_len ps) 2) (do
        (output_error stderr current_loc)
        (output_string stderr "Choice must have more than 1 argument.\n")
        (exit 1)
        ))

    (var body 0)
    (var state (unique_sym))
    (var v (unique_sym))
    (var errors (unique_sym))

    (= body (cons (defvar v 0) body))
    (= body (cons (defvar errors 0) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))

    (while ps (do
        (= body (cons (assign v (compile_parser_element (car ps))) body))
        (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote Parsed)))
            (mkreturn v)
            ) body))
        (= body (cons (assign errors
            (apply (to_sym "%merge_noparse") (list2 errors v))) body))
        (= body (cons (gen_set_parser_state ParserVar state) body))
        (= ps (cdr ps))
        ))
    (= body (cons errors body))

    (return (apply
        (make_expr Lambda (list2 ParserVar (make_expr Block (list_reverse body))))
        (list1 ParserVar)
        ))
    ))

; Many{ p } is translated to
;
; elems = []
; state = copy_parser_state(..)
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state(state, p)
;     parse_spaces()
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_many (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (defvar v p) loop_body))
    (= loop_body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break) loop_body))
    (= loop_body (cons (assign eloc (gen_at v 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state ParserVar) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))

    (var body 0)
    (= body (cons (defvar bloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar eloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state ParserVar state) body))
    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (apply (to_sym "reverse") (list1 elems)))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; Many1{ p } is translated to
;
; elems = []
; v = p
; if (head(v) == NoParse) return v
; elems = cons(val(v), elems)
; state = copy_parser_state(..)
; while true {
;     parse_spaces()
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state(state, p)
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_many1 (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (gen_parse_spaces_break loop_body))
    (= loop_body (cons (assign v p) loop_body))
    (= loop_body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break) loop_body))
    (= loop_body (cons (assign eloc (gen_at v 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state ParserVar) loop_body))

    (var body 0)
    (= body (cons (defvar bloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar eloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar v p) body))
    (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (mkreturn v)) body))
    (= body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state ParserVar state) body))
    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (apply (to_sym "reverse") (list1 elems)))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; Aligned{ p } is translated to
;
; elems = []
; column = get_column(p)
; set_indent(p, column)
; v = p
; if (head(v) == NoParse) return v
; elems = cons(val(v), elems)
; state = copy_parser_state(..)
; parse_spaces()
; while true {
;     if (get_column(p) != column) break
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state(state, p)
;     parse_spaces()
; }
; set_parser_state(state)
; reset_indent(p)
; Parsed{loc, reverse(elems)}

(fun compile_aligned (elem) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var clmn  (unique_sym))
    (var indent_save (unique_sym))
    (var loc   (to_sym "%Loc"))
    (var p (compile_parser_element elem))

    (var loop_body 0)
    (= loop_body (cons (mkif 
            (make_expr NotEqual (list2 
                (apply (to_sym "%get_column") (list1 ParserVar))
                clmn
                ))
            Break) loop_body))
    (= loop_body (cons (assign v p) loop_body))
    (= loop_body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break) loop_body))
    (= loop_body (cons (assign eloc (gen_at v 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state ParserVar) loop_body))
    (if (! space_sensitive_p)
        (= loop_body (cons (apply
            (to_sym "%parse_spaces") (list1 ParserVar)) loop_body))
        )

    (var body 0)
    (= body (cons (defvar clmn (apply (to_sym "%get_column") (list1 ParserVar))) body))
    (= body (cons (defvar indent_save (apply (to_sym "%set_indent") (list2 ParserVar clmn))) body))
    (= body (cons (defvar bloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar eloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar v p) body))
    (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (make_expr Block (list2
                (apply (to_sym "%set_indent") (list2 ParserVar indent_save))
                (mkreturn v)
            )))
        body))
    (= body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))
    (if (! space_sensitive_p)
        (= body (cons (apply
            (to_sym "%parse_spaces") (list1 ParserVar)) body))
        )
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state ParserVar state) body))
    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (= body (cons (apply (to_sym "%set_indent") (list2 ParserVar indent_save)) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (apply (to_sym "reverse") (list1 elems)))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; Delimited{ p, delim } is translated to
;
; elems = []
; state = copy_parser_state(..)
; while true {
;     v = p
;     if (head(v) == NoParse) break
;     elems = cons(val(v), elems)
;     set_parser_state(setate, p)
;     parse_spaces()
;     v = delim
;     if (head(v) == NoParse) break
;     parse_spaces()
; }
; set_parser_state(state)
; Parsed{loc, reverse(elems)}

(fun compile_delimited (p delim minlen) (
    (var v     (unique_sym))
    (var state (unique_sym))
    (var elems (unique_sym))
    (var bloc  (unique_sym))
    (var eloc  (unique_sym))
    (var loc   (to_sym "%Loc"))
    (= p (compile_parser_element p))
    (= delim (compile_parser_element delim))

    (var loop_body 0)
    (= loop_body (cons (defvar v p) loop_body))
    (= loop_body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break) loop_body))
    (= loop_body (cons (assign eloc (gen_at v 0)) loop_body))
    (= loop_body (cons (assign elems (apply (to_sym "cons") (list2 (gen_at v 1) elems))) loop_body))
    (= loop_body (cons (gen_set_parser_state state ParserVar) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))
    (= loop_body (cons (assign v delim) loop_body))
    (= loop_body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            Break) loop_body))
    (= loop_body (gen_parse_spaces_break loop_body))

    (var body 0)
    (= body (cons (defvar bloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar eloc (apply (to_sym "%get_loc") (list1 ParserVar))) body))
    (= body (cons (defvar elems 0) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))
    (= body (cons (make_expr While (list2 true
            (make_expr Block (list_reverse loop_body)))) body))
    (= body (cons (gen_set_parser_state ParserVar state) body))
    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (if (> minlen 0)
        (= body (cons (mkif  
            (apply (to_sym "lt")
                (list2 (apply (to_sym "length") (list1 elems)))
                    (box minlen))
            (mkreturn 
                (qquote (make_expr NoParse (list1 (list2 (unquote loc) (string "The number of elements is insufficient"))))))
            ) body))
        )

    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote (apply (to_sym "reverse") (list1 elems)))))) body))
    (return (make_expr Block (list_reverse body)))
    ))

; scope{ p } is translated to
;
; module = new anonymous module
; enter module
; v = p
; exit module
; v
(fun compile_scoped (elem) (
    (var v (unique_sym))
    (var p (compile_parser_element elem))
    (return (make_expr Block (list3
        (apply (to_sym "%open_scope") 0)
        (defvar v p)
        (apply (to_sym "%close_scope") (list1 v))
        )))
    ))

; enter anonymous scope
(fun open_scope () (
    (var module (make_module nil current_mod))
    (set_current_module module)
    ))

; exit from anonymous scope
(fun close_scope (v) (
    (var ls (imported_modules current_mod))
    (var mod current_mod)
    (set_current_module (super_module current_mod))
    (if (&& (== (expr_head v) Parsed) ls)
        (expr_arg_set v 1 (make_expr Scoped (list2 mod (expr_arg v 1))))
        )
    (return v)
    ))

; Option{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; if (head(v) == NoParse) {
;   set_parser_state(parser, state)
;   nil
; } else
;   Parsed{loc(v), Some{val(v)}}
(fun compile_option (p) (
    (var v (unique_sym))
    (var state (unique_sym))
    (var loc (to_sym "%Loc"))
    (return (make_expr Block (list4
        (defvar state (gen_copy_parser_state ParserVar))
        (defvar loc (apply (to_sym "%get_loc") (list1 ParserVar)))
        (defvar v (compile_parser_element p))
        (ifelse
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote NoParse)))
            (make_expr Block (list2
                (gen_set_parser_state ParserVar state)
                (qquote (make_expr Parsed (list2 (unquote loc) nil)))
                ))
            (qquote (make_expr Parsed (list2 (unquote (gen_at v 0))
                (make_expr Some (list1 (unquote (gen_at v 1)))))))
            ))))
            
    ))

; And{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; v
(fun compile_and (p) (
    (var state (unique_sym))
    (var v (unique_sym))
    (return (make_expr Block (list4
        (defvar state (gen_copy_parser_state ParserVar))
        (defvar v (compile_parser_element p))
        (gen_set_parser_state ParserVar state)
        v)))
    ))

; Not{ p } is translated to
;
; state = copy_parser_state(parser)
; v = p
; set_parser_state(parser, state)
; negate(v,p)
(fun compile_not (p) (
    (var state (unique_sym))
    (var v (unique_sym))
    (return (make_expr Block (list4
        (defvar state (gen_copy_parser_state ParserVar))
        (defvar v (compile_parser_element p))
        (gen_set_parser_state ParserVar state)
        (apply (to_sym "%negate") (list2 ParserVar v))
        )))
    ))

(fun compile_parser_action (elems act) (
    (if (!= (expr_head elems) List) (do
        (output_error stderr current_loc)
        (output_string stderr "syntax statement must be List{syntax element, ...}: ")
        (pretty_print stderr elems)
        (output_string stderr "\n")
        (exit 1)
        ))

    (var idx 0)
    (var body 0)
    (var bloc (unique_sym))
    (var eloc (unique_sym))
    (var loc (to_sym "%Loc"))

    (while elems (do
        (var ndvar (make_nodevar idx))
        (= body (cons (defvar ndvar (compile_parser_element (car elems))) body))
        (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 ndvar)) (quote NoParse)))
            (mkreturn ndvar)
            ) body))
        (if (== idx 0)
            (= body (cons (defvar bloc (gen_at ndvar 0)) body))
            )
        (incr idx)
        (= elems (cdr elems))
        (if elems 
            (= body (gen_parse_spaces body))
            (= body (cons (defvar eloc (gen_at ndvar 0)) body))
            )
        (= body (cons (assign ndvar (gen_at ndvar 1)) body))
        ))

    (= body (cons (defvar loc
        (apply (to_sym "%merge_loc") (list2 bloc eloc))) body))
    (= body (cons (qquote (make_expr Parsed (list2 (unquote loc) (unquote act)))) body))

    (= body (make_expr Block (list_reverse body)))
    (return (apply
        (make_expr Lambda (list2 (make_expr Domain (list2 ParserVar Parser)) body))
        (list1 ParserVar)
        ))
    ))

(var space_sensitive (to_sym "space_sensitive"))
(var multiline (to_sym "multiline"))
(fun setup_options (opts) (
    (if (!= (expr_head opts) List)
        (= opts (list1 opts))
        )
    (while opts (do
        (var opt (car opts))
        (if (== opt space_sensitive)
            (= space_sensitive_p @TRUE)
        (if (== opt multiline)
            (= multiline_p @TRUE)
            (throw (unexpected_error current_loc
                (string "unknown parser option") opt))
            ))
        (= opts (cdr opts))
        ))
    ))
(fun clear_options () (
    (= space_sensitive_p @FALSE)
    (= multiline_p @FALSE)
    ))

(fun compile_parser (sym elems) (
    (if (!= (expr_head elems) List) (do
        (output_error stderr current_loc)
        (output_string stderr "invalid syntax declaration\n")
        (exit 1)
        ))

    (var body 0)
    (var state (unique_sym))
    (var v (unique_sym))
    (var errors (unique_sym))

    ; if sym == parse_statement
    ; modify parsed expression to Located{...}
    (var return_stmt 0)
    (if (== sym (to_sym "parse_statement_"))
        (= return_stmt (make_expr Block (list2
            (apply (to_sym "%eval_parser_command") (list1 v))
            (mkreturn 
                (apply (to_sym "%apply_located") (list1 v))
            ))))
        (= return_stmt (mkreturn v))
        )

    (= body (cons (defvar v 0) body))
    (= body (cons (defvar errors 0) body))
    (= body (cons (defvar state (gen_copy_parser_state ParserVar)) body))
    (while elems (do
        (var t (car elems))
        (var size (expr_size t))
        (if (|| (!= (expr_head t) Tuple) (|| (< size 2) (> size 3))) (do
            (output_error stderr current_loc)
            (output_string stderr "parser element must be form of Tuple{parser, action, [options]}:")
            (pretty_print stderr t)
            (output_string stderr "\n")
            (exit 1)
            ))
        (if (== size 3)
            (setup_options (expr_arg t 2))
            )

        (var act (compile_parser_action (expr_arg t 0) (expr_arg t 1)))
        (= body (cons (assign v act) body))
        (= body (cons (mkif 
            (make_expr Equal (list2 (make_expr Head (list1 v)) (quote Parsed)))
            return_stmt
            ) body))
        (= body (cons (assign errors
            (apply (to_sym "%merge_noparse") (list2 errors v))) body))
        (= body (cons (gen_set_parser_state ParserVar state) body))
        (= elems (cdr elems))

        (clear_options)
        ))
    (= body (cons errors body))

    (return (make_expr Block (list_reverse body)))
    ))

(extern fun compile_matching)
(fun call_parser (p sym new) (
    (var tbl (field_get (field_get p 1) 2))
    (var pos (field_get p 3))
    (var v (memotable_find tbl sym pos))
    (if v (do
        (if (== (field_get v 0) LeftRec) (do
            ; detected left-recursion
            (field_set v 1 (copy_parser_state (field_get v 1)))
            (field_set v 2 @TRUE)
            ))
        (set_parser_state p (field_get v 1))
        (return (field_get v 0))
        ))
    (var loc (get_loc p))
    (var state (copy_parser_state p))

    (var ent (struct 2 LeftRec state @FALSE))
    (memotable_add tbl sym pos ent)
    (label retry_lbl)
    (= v (byterun (compile_matching loc sym new) p))

    (if (field_get ent 2)
        (if (&& (== (expr_head v) Parsed)
                (> (field_get p 3) (field_get (field_get ent 1) 3)))
            (do
                (field_set ent 0 v)
                (set_parser_state (field_get ent 1) p)
                (set_parser_state p state)
                (goto retry_lbl)
            )
            (do
                ; accept previous try
                (set_parser_state p (field_get ent 1))
                (return (field_get ent 0))
            )))
    ; not left-recursive
    (field_set ent 0 v)
    (set_parser_state (field_get ent 1) p)
    (return v)
    ))

(fun bind_parser (old_parser new_parser) (
    (var v (unique_sym))
    (return (make_expr Block (list3
        (defvar v new_parser)
        (mkif (make_expr Equal (list2 (make_expr Head (list1 v)) (quote Parsed)))
            (mkreturn v))
        (apply old_parser (list1 ParserVar))
        )))
    ))

(fun compile_parser_driver (sym sym_) (
    (return (make_expr DefineFunction (list2 sym
        (make_expr Lambda (list2 (make_expr Domain (list2 ParserVar Parser))
        (apply (to_sym "%call_parser") (list3 ParserVar (quote sym) sym_))
        )))))
    ))

(export fun compile_define_syntax (sym elems) (
    (var parser_sym (to_parse sym))
    (var parser_sym_ (to_parse_ sym))
    (if (lookup_effective_symbol current_mod parser_sym)
        (do
            (var copy_sym   (unique_sym))
            (var new_parser (compile_parser parser_sym_ elems))
            (var stmts (list3
                ; save existing parser
                (make_expr DefineFunction (list2 copy_sym parser_sym_))
                (make_expr DefineFunction (list2 parser_sym_
                    (make_expr Lambda (list2
                        (make_expr Domain (list2 ParserVar Parser))
                        (bind_parser copy_sym new_parser)))
                    ))
                (compile_parser_driver parser_sym parser_sym_)
                ))
            (return stmts)
        )
        (do
            (var new_parser (compile_parser parser_sym_ elems))
            (var stmts (list2
                (make_expr DefineFunction (list2 parser_sym_
                    (make_expr Lambda (list2
                        (make_expr Domain (list2 ParserVar Parser))
                        new_parser))
                    ))
                (compile_parser_driver parser_sym parser_sym_)
                ))
            (return stmts)
        ))
    ))

(export fun init_parser_funcs (mod) (
    (var std (find_module no_loc mod (to_sym "std") @TRUE))
    (var parser (find_module no_loc std (to_sym "parser") @TRUE))

    (add_builtin_function1 parser (to_sym "%get_loc") (domainP Parser) get_loc 0)
    (add_builtin_function1 parser (to_sym "%get_column") (domainP Parser) get_column 0)
    (add_builtin_function2 parser (to_sym "%set_indent") (domainP Parser) (domainP Int) set_indent 0)
    (add_builtin_function2 parser (to_sym "%merge_loc") (domainP Loc) (domainP Loc) merge_loc 0)
    (add_builtin_function1 parser (to_sym "%copy_parser_state") (domainP Parser) copy_parser_state 0)
    (add_builtin_function2 parser (to_sym "%set_parser_state") (domainP Parser) (domainP Parser) set_parser_state 0)
    (add_builtin_function3 parser (to_sym "%call_parser") (domainP Parser) (domainP Symbol) (domainP Function) call_parser 0)

    (add_builtin_function2 parser (to_sym "%merge_noparse") DontCare DontCare merge_noparse 0)
    (add_builtin_function2 parser (to_sym "%negate") (domainP Parser) DontCare negate 0)
    (add_builtin_function1 parser (to_sym "%apply_located") DontCare apply_located 0)
    (add_builtin_function1 parser (to_sym "%eval_parser_command") DontCare eval_parser_command 0)
    (add_builtin_function0 parser (to_sym "%open_scope") open_scope 0)
    (add_builtin_function1 parser (to_sym "%close_scope") DontCare close_scope 0)

    (add_parser parser (to_sym "%parse_spaces") parse_spaces)

    (add_builtin_function2 parser (to_sym "parse_text") (domainP Parser) (domainP String) parse_text 0)

    (add_parser parser (to_sym "parse_any_") parse_any_char)
    (add_parser parser (to_sym "parse_blank_") parse_blank_)
    (add_parser parser (to_sym "parse_decimal_") parse_decimal_)
    (add_parser parser (to_sym "parse_binary_") parse_binary_)
    (add_parser parser (to_sym "parse_octal_") parse_octal_)
    (add_parser parser (to_sym "parse_hex_") parse_hex_)
    (add_parser parser (to_sym "parse_integer_") parse_integer_)
    (add_parser parser (to_sym "parse_string_") parse_string_)
    (add_parser parser (to_sym "parse_symbol_") parse_symbol_)
    (add_parser parser (to_sym "parse_atom_") parse_atom_)
    (add_parser parser (to_sym "parse_node_") parse_node_)
    (add_parser parser (to_sym "parse_expr_") parse_expr_)
    (add_parser parser (to_sym "parse_statement_") parse_statement_)

    (add_parser parser (to_sym "parse_any") parse_any_char)
    (add_parser parser (to_sym "parse_blank") parse_blank)
    (add_parser parser (to_sym "parse_decimal") parse_decimal)
    (add_parser parser (to_sym "parse_binary") parse_binary)
    (add_parser parser (to_sym "parse_octal") parse_octal)
    (add_parser parser (to_sym "parse_hex") parse_hex)
    (add_parser parser (to_sym "parse_integer") parse_integer)
    (add_parser parser (to_sym "parse_string") parse_string)
    (add_parser parser (to_sym "parse_symbol") parse_symbol)
    (add_parser parser (to_sym "parse_atom") parse_atom)
    (add_parser parser (to_sym "parse_node") parse_node)
    (add_parser parser (to_sym "parse_expr") parse_expr)
    (add_parser parser (to_sym "parse_statement") parse_statement)
    ))

(export fun output_syntax_errors (e) (
    (output_string stderr "Syntax Error ")
    (var errors (expr_args e))
    (var multi @FALSE)
    (if (!= (list_len errors) 1) (do
        (= multi @TRUE)
        (output_char stderr '\n'))
        )
    (while errors (do
        (if multi (output_char stderr '\t'))
        (output_loc stderr (caar errors))
        (output_string stderr " : ")
        (output_string stderr (cadar errors))
        (output_char stderr '\n')
        (= errors (cdr errors))
        ))
    ))

    ))
