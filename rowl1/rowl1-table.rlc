;
; rowl - 1st generation
; Copyright (C) 2012 nineties
;
; $Id: rowl1-table.rlc 2013-01-25 05:15:00 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-error")
(import "rowl1-pprint")

(extern object current_mod)
(extern object current_loc)

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

; Fields of hashtable
; 0: TableE
; 1: bucket
; 2: hash-function
; 3: equal-function to compare key
; 4: kill-function to detect entries which can be killed.
; 5: list of entries
; 6: depth of stacking
; 7: # of entries

; Fields of hash entries
; 0: the key
; 1: the value
; 2: pointer to the next entry in bucket
; 3: pointer to the next entry in list of entries
; 4: the depth
; 5: the hash value

(fun ht_new_with_hint (hint hash equal kill) (
    (var size (array_get int prime_numbers (bsr hint)))
    (var tbl (variant @TableE 5 (allocate_array size) hash equal kill 0 0 0))
    (ht_enter tbl)
    (return tbl)
    ))

(export fun ht_new () (
    (return (ht_new_with_hint 10
        (lookup_func current_mod (to_sym "hash"))
        (lookup_func current_mod (to_sym "equal"))
        0
        ))
    ))

(export fun ht_new2 (hash equal) (
    (= hash  (get_bytecode hash))
    (= equal (get_bytecode equal))
    (return (ht_new_with_hint 10 hash equal 0))
    ))

(export fun ht_new3 (hash equal kill) (
    (= hash  (get_bytecode hash))
    (= equal (get_bytecode equal))
    (= kill (get_bytecode kill))
    (return (ht_new_with_hint 10 hash equal kill))
    ))

(fun ht_enter (tbl) (
    (field_set tbl 6 (+ (field_get tbl 6) 1))
    (return @C_NIL)
    ))

(fun ht_exit (tbl) (
    (var bucket (field_get tbl 1))
    (var bucket_size (seq_size bucket))
    (var entry (field_get tbl 5))
    (var depth (field_get tbl 6))
    (if (== depth 0) (throw
        (exception current_loc (string "Depth of table is zero"))
        ))
    (var count 0)
    (while entry (do
        (if (!= (field_get entry 4) depth) break)
        ; remove the ehtry
        (var h (% (field_get entry 5) bucket_size))
        (array_set object bucket h (field_get entry 2))
        (+= count 1)
        (= entry (field_get entry 3))
        ))
    (field_set tbl 5 entry)
    (field_set tbl 6 (- (field_get tbl 6) 1))
    (field_set tbl 7 (- (field_get tbl 7) count))
    (return @C_NIL)
    ))

; Remove entries iff kill-function returns true.
(fun cleanup_table (tbl) (
    (var kill (field_get tbl 4))
    (var bucket (field_get tbl 1))
    (var bucket_size (seq_size bucket))
    (var entry (field_get tbl 5))
    (var prev 0)
    (var count 0)
    (while entry (do
        (var key (field_get entry 0))
        (var val (field_get entry 1))
        (var v (byterun kill key val))
        (if (== v @C_TRUE) (do
            (+= count 1)
            (var h (% (field_get entry 5) bucket_size))
            (var e (array_get object bucket h))
            (var p 0)
            (while e (do
                (if (== e entry) (do
                    (if p
                        (field_set p 2 (field_get e 2))
                        (array_set object bucket h (field_get e 2))
                        )
                    break
                    ))
                (= p e)
                (= e (field_get e 2))
                ))

            (if prev
                (field_set prev 3 (field_get entry 3))
                (field_set tbl 5 (field_get entry 3))
                )
            (= entry (field_get entry 3))
            continue
            ))
        (= entry (field_get entry 3))
        (= prev entry)
        ))
    (field_set tbl 7 (- (field_get tbl 7) count))
    (return @C_NIL)
    ))

; resize bucket
(fun rehash (tbl) (
    (var num_ent (field_get tbl 7))
    (if (field_get tbl 4) (do
        (cleanup_table tbl)
        (var old_size (seq_size (field_get tbl 1)))
        (= num_ent (field_get tbl 7))
        (if (< num_ent old_size) return)
        ))
    (var new_size (array_get int prime_numbers (bsr num_ent)))
    (if (! new_size)(throw
        (exception current_loc (string "rehash: too many entries"))))
    (var bucket (allocate_array new_size))
    (var entry (field_get tbl 5))
    (while entry (do
        (var h (% (field_get entry 5) new_size))
        (field_set entry 2 (array_get object bucket h))
        (array_set object bucket h entry)
        (= entry (field_get entry 3))
        ))
    (field_set tbl 1 bucket)
    ))

(fun ht_add (tbl h key val hash) (
    (var buf_size (seq_size (field_get tbl 1)))
    (var num_ent  (field_get tbl 7))
    (if (>= num_ent buf_size) (rehash tbl))
    
    (var bucket (field_get tbl 1))
    (var size   (seq_size bucket))
    (var depth  (field_get tbl 6))
    (var entry (struct 4 key val 0 0 depth h))
    (%= h size)

    ; add new entry to the list
    (field_set entry 3 (field_get tbl 5))
    (field_set tbl 5 entry)

    ; add new entry to the bucket
    (field_set entry 2 (array_get object bucket h))
    (array_set object bucket h entry)

    ; increment the counter
    (field_set tbl 7 (+ (field_get tbl 7) 1))
    ))

(fun ht_store (tbl key val) (
    (var bucket (field_get tbl 1))
    (var hash (field_get tbl 2))
    (var eql  (field_get tbl 3))
    (var depth (field_get tbl 6))
    (var size (seq_size bucket))

    (var hash_value (unbox (byterun hash key)))
    (var h (% hash_value size))
    (var entry (array_get object bucket h))
    (while entry (do    
        (if (&& (== (byterun eql (field_get entry 0) key) @C_TRUE)
                (== depth (field_get entry 4))) (do
            (field_set entry 1 val)
            (return val)
            ))
        (= entry (field_get entry 2))
        ))
    (ht_add tbl hash_value key val hash)
    (return val)
    ))

(fun ht_at (tbl key) (
    (var hash (field_get tbl 2))
    (var eql  (field_get tbl 3))
    (var bucket (field_get tbl 1))
    (var size (seq_size bucket))
    (var h (unbox (byterun hash key)))
    (%= h size)
    (var entry (array_get object bucket h))
    (while entry (do
        (var e_key (field_get entry 0))
        (if (== (byterun eql e_key key) @C_TRUE)
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return @C_UNDEF)
    ))

(fun ht_keys (tbl) (
    (var keys 0)
    (var entries (field_get tbl 5))
    (while entries (do
        (= keys (cons (field_get entries 0) keys))
        (= entries (field_get entries 3))
        ))
    (return keys)
    ))

(fun ht_values (tbl) (
    (var values 0)
    (var entries (field_get tbl 5))
    (while entries (do
        (= values (cons (field_get entries 1) values))
        (= entries (field_get entries 3))
        ))
    (return values)
    ))

(extern fun tuple2)
(fun ht_entries (tbl) (
    (var es 0)
    (var entry (field_get tbl 5))
    (while entry (do
        (= es (cons (tuple2 (field_get entry 0)
            (field_get entry 1)) es))
        (= entry (field_get entry 3))
        ))
    (return es)
    ))

(export fun pp_table (ochan tbl) (
    (var entries (ht_entries tbl))
    (output_string ochan "Table{")
    (while entries (do
        (var pair (car entries))
        (pprint ochan (array_get object pair 0))
        (output_string ochan " => ")
        (pprint ochan (array_get object pair 1))
        (= entries (cdr entries))
        (if entries (output_string ochan ", "))
        ))
    (output_string ochan "}")
    ))

(fun ht_from_list (list) (
    (var orig list)
    (var tbl (ht_new))
    (while list (do
        (var ent (car list))
        (if (|| (!= (node_head ent) Tuple) (!= (node_size ent) 2))
            (throw (invalid_argument current_loc (string "Table::create requires list of pairs") orig))
            )
        (ht_store tbl (node_arg ent 0) (node_arg ent 1))
        (= list (cdr list))
        ))
    (return tbl)
    ))

(export fun setup_table (std) (
    (var mod (find_module no_loc std (to_sym "Table") @TRUE))
    (add_function0 mod (to_sym "new") ht_new 0)
    (add_function2 mod (to_sym "new") funT funT ht_new2 0)
    (add_function3 mod (to_sym "new") funT funT funT ht_new3 0)
    (add_function1 mod (to_sym "from_list") listT ht_from_list 0)
    (add_function2 std (to_sym "at") tableT DontCare ht_at 0)
    (add_function3 std (to_sym "store") tableT DontCare DontCare ht_store 0)

    (add_function1 std (to_sym "keys") tableT ht_keys 0) 
    (add_function1 std (to_sym "values") tableT ht_values 0)
    (add_function1 std (to_sym "entries") tableT ht_entries 0)

    (add_function1 std (to_sym "enter") tableT ht_enter 0)
    (add_function1 std (to_sym "exit") tableT ht_exit 0)
    (add_function1 std (to_sym "cleanup") tableT cleanup_table 0)
    ))

    ))
