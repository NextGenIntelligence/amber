;
; rowl - 1st generation
; Copyright (C) 2012 nineties
;
; $Id: rowl1-table.rlc 2013-02-23 14:39:32 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-error")
(import "rowl1-pprint")

(extern object current_mod)
(extern object current_loc)

(array int prime_numbers (
    5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    ))

; Fields of hashtable
; 0: TableE
; 1: bucket
; 2: hash-function
; 3: equal-function to compare keys
; 4: list of entries
; 5: # of entries

; Fields of hash entries
; 0: the key
; 1: the value
; 2: pointer to the next entry in bucket
; 3: pointer to the next entry in list of entries
; 4: the hash value

(fun table_new_with_hint (hint hash equal) (
    (var size (array_get int prime_numbers (bsr hint)))
    (return (variant @TableE 4 (allocate_array size) hash equal 0 0))
    ))

(export fun table_new () (
    (return (table_new_with_hint 10
        (lookup_func current_mod (to_sym "hash"))
        (lookup_func current_mod (to_sym "equal"))
        ))
    ))

(export fun table_new2 (hash equal) (
    (= hash  (get_bytecode hash))
    (= equal (get_bytecode equal))
    (return (table_new_with_hint 10 hash equal))
    ))

(export fun table_size (tbl) (
    (return (box (field_get tbl 5)))
    ))

; resize bucket
(fun rehash (tbl) (
    (var num_ent (field_get tbl 5))
    (var new_size (array_get int prime_numbers (bsr num_ent)))
    (if (! new_size)(throw
        (exception current_loc (string "rehash: too many entries"))))
    (var bucket (allocate_array new_size))
    (var entry (field_get tbl 4))
    (while entry (do
        (var h (% (field_get entry 4) new_size))
        (field_set entry 2 (array_get object bucket h))
        (array_set object bucket h entry)
        (= entry (field_get entry 3))
        ))
    (field_set tbl 1 bucket)
    ))

(fun table_add (tbl h key val hash) (
    (var buf_size (seq_size (field_get tbl 1)))
    (var num_ent  (field_get tbl 5))
    (if (>= num_ent buf_size) (rehash tbl))
    
    (var bucket (field_get tbl 1))
    (var size   (seq_size bucket))
    (var entry (struct 4 key val 0 0 h))
    (%= h size)

    ; add new entry to the list
    (field_set entry 3 (field_get tbl 4))
    (field_set tbl 4 entry)

    ; add new entry to the bucket
    (field_set entry 2 (array_get object bucket h))
    (array_set object bucket h entry)

    ; increment the counter
    (field_set tbl 5 (+ (field_get tbl 5) 1))
    ))

(fun table_store (tbl key val) (
    (var bucket (field_get tbl 1))
    (var hash (field_get tbl 2))
    (var eql  (field_get tbl 3))
    (var size (seq_size bucket))

    (var hash_value (unbox (byterun hash key)))
    (var h (% hash_value size))
    (var entry (array_get object bucket h))
    (while entry (do    
        (if (== (byterun eql (field_get entry 0) key) @C_TRUE) (do
            (field_set entry 1 val)
            (return val)
            ))
        (= entry (field_get entry 2))
        ))
    (table_add tbl hash_value key val hash)
    (return val)
    ))

(fun table_at (tbl key) (
    (var hash (field_get tbl 2))
    (var eql  (field_get tbl 3))
    (var bucket (field_get tbl 1))
    (var size (seq_size bucket))
    (var h (unbox (byterun hash key)))
    (%= h size)
    (var entry (array_get object bucket h))
    (while entry (do
        (var e_key (field_get entry 0))
        (if (== (byterun eql e_key key) @C_TRUE)
            (return (field_get entry 1))
            )
        (= entry (field_get entry 2))
        ))
    (return @C_UNDEF)
    ))

(fun table_keys (tbl) (
    (var keys 0)
    (var entries (field_get tbl 4))
    (while entries (do
        (= keys (cons (field_get entries 0) keys))
        (= entries (field_get entries 3))
        ))
    (return keys)
    ))

(fun table_values (tbl) (
    (var values 0)
    (var entries (field_get tbl 4))
    (while entries (do
        (= values (cons (field_get entries 1) values))
        (= entries (field_get entries 3))
        ))
    (return values)
    ))

(export fun pp_table (ochan tbl) (
    (var entries (table_to_list tbl))
    (output_string ochan "Table{")
    (while entries (do
        (var pair (car entries))
        (pprint ochan (array_get object pair 0))
        (output_string ochan " => ")
        (pprint ochan (array_get object pair 1))
        (= entries (cdr entries))
        (if entries (output_string ochan ", "))
        ))
    (output_string ochan "}")
    ))

(export fun list_to_table (list) (
    (var orig list)
    (var tbl (table_new))
    (while list (do
        (var ent (car list))
        (if (|| (!= (node_head ent) Tuple) (!= (node_size ent) 2))
            (throw (invalid_argument current_loc (string "Arguments of Table must be list of pairs") orig))
            )
        (table_store tbl (node_arg ent 0) (node_arg ent 1))
        (= list (cdr list))
        ))
    (return tbl)
    ))

(extern fun tuple2)
(export fun table_to_list (tbl) (
    (var list 0)
    (var entry (field_get tbl 4))
    (while entry (do
        (= list (cons (tuple2 (field_get entry 0)
            (field_get entry 1)) list))
        (= entry (field_get entry 3))
        ))
    (return list)
    ))


(export fun table_restof (tbl i) (
    (var num (field_get tbl 5))
    (-= num i)
    (var entry (field_get tbl 4))
    (while (&& entry (> num 0)) (do
        (= entry (field_get entry 3))
        ))
    (var list 0)
    (while entry (do
        (= list (cons (tuple2 (field_get entry 0)
            (field_get entry 1)) list))
        (= entry (field_get entry 3))
        ))
    (return list)
    ))

(export fun setup_table (std) (
    (var ModTbl (create_module std (to_sym "Table")))
    (var ModList  (create_module std (to_sym "List")))
    (add_function0 ModTbl (to_sym "new") table_new 0)
    (add_function2 ModTbl (to_sym "new") funT funT table_new2 0)
    (add_function1 ModTbl (to_sym "from_list") listT list_to_table 0)
    (add_function2 std (to_sym "at") tableT DontCare table_at 0)
    (add_function3 std (to_sym "store") tableT DontCare DontCare table_store 0)
    (add_function1 std (to_sym "size") tableT table_size 0)

    (add_function1 ModList (to_sym "from_table") tableT table_to_list 0)

    (add_function1 std (to_sym "keys") tableT table_keys 0) 
    (add_function1 std (to_sym "values") tableT table_values 0)
    (add_function1 std (to_sym "pairs") tableT table_to_list 0)
    ))

    ))
