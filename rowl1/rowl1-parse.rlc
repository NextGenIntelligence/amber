;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-parse.rlc 2011-12-14 00:44:01 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-lex")
(import "rowl1-node")
(import "rowl1-module")

; Prog      ::= Expr*
; Expr      ::= Secondary
;             | prefix Expr
;             | Expr postfix
;             | Expr infix Expr
;             | constr Expr*
; Secondary ::= Primary
;             | Secondary '(' Expr, ... ')'
;             | Secondary '[' Expr, ... ']'
;             | Secondary '{' Expr, ... '}'
; Primary   ::= Symbol
;             | Literal
;             | '(' Expr, ... ')'
;             | '[' Expr, ... ']'
;             | '{' Expr ... '}'
;
; NB:
; - postfix operator must be unique

(extern object current_mod)
(extern fun set_current_module)

(var comma_op (variant @OP_INFIX 1 (to_sym "Comma") "," @FALSE @ASSOC_COMMA))

(export fun init_parser (file ichan) (
    (init_lexer file ichan)
    ))

(export fun push_parser (file ichan) (
    (push_lexer file ichan)
    ))

(export fun pop_parser () (
    (pop_lexer)
    ))

(export fun parse () (
    (var es 0)
    (var t (lex))
    (while (!= t @TOK_EOF) (do
        (var begin (get_loc))
        (var e (parse_expr_top t (get_clmn)))
        (var end (get_loc))
        (= es (cons (make_located (merge_loc begin end) e) es))
        (= t (lex))
        ))
    (return (list_reverse es))
    ))

(fun parse_expr_top (tok offs) (
    (if (== tok @TOK_COMMAND) (do
        (var op (get_token_boxed))
        (var head (field_get op 1))
        (= tok (lex_sub offs))
        (if (== tok @TOK_END)
            (return (make_expr_user head 0))
            (return (make_expr_user head (list1 (parse_expr tok offs @FALSE))))
            )
        ))
    (var e (parse_expr tok offs @FALSE))
    (evaluate_parser_command e)
    (return e)
    ))

(fun evaluate_parser_command (e) (
    (var ty (expr_head e))
    (if (== ty DefInfixL)
        (add_infixl (expr_arg_symbol e 0) (expr_arg_string e 1) (expr_arg_int e 2))
    (if (== ty DefInfixR)
        (add_infixr (expr_arg_symbol e 0) (expr_arg_string e 1) (expr_arg_int e 2))
    (if (== ty DefPrefix)
        (add_prefix (expr_arg_symbol e 0) (expr_arg_string e 1) (expr_arg_int e 2))
    (if (== ty DefPostfix)
        (add_postfix (expr_arg_symbol e 0) (expr_arg_string e 1) (expr_arg_int e 2))
    (if (== ty DefConstr)
        (add_constr (expr_arg_symbol e 0) (expr_arg_string e 1))
    (if (== ty DefCommand)
        (add_command (expr_arg_symbol e 0) (expr_arg_string e 1))
        ))))))
    ))

(fun parse_expr (tok offs in_seq) (
    (var expr_stack 0)  ; list of expressions
    (var op_stack 0)    ; list of (operator . location)
    (var next_op 0)

    (= op_stack (list1 (cons (variant @OP_START 0) (get_loc))))

    (label parse_expr_front)
    (if (== tok @TOK_PREFIX) (do
        (= op_stack (cons (cons (get_token_boxed) (get_loc)) op_stack))
        (= tok (lex_sub offs))
        (goto parse_expr_front)
        ))
    (= expr_stack (cons (parse_primary tok) expr_stack))

    (label parse_expr_middle)
    (= next_op (parse_successive_operator offs in_seq))

    (while 1 (do
        (var comp (compare_associativity (car op_stack) next_op))
        (if (== comp 0) (goto parse_expr_end)
        (if (> comp 0)
            (do
                (var op (car op_stack))
                (if (== (car op) comma_op)
                    (do
                        (var elems (list1 (car expr_stack)))
                        (= expr_stack (cdr expr_stack))
                        (while (== (caar op_stack) comma_op) (do
                            (= elems (cons (car expr_stack) elems))
                            (= expr_stack (cdr expr_stack))
                            (= op_stack (cdr op_stack))
                            ))
                        (= expr_stack (cons (make_expr_user Tuple elems) expr_stack))
                    )
                    (do
                        (= op_stack (cdr op_stack))
                        (= expr_stack (reduce op expr_stack))
                    ))
                continue
            )
            (do
                (= op_stack (cons next_op op_stack))
                break
            )
            ))
        ))

    (var type (field_get (car next_op) 0))
    (if (== type @OP_INFIX)
        (do (= tok (lex_sub offs)) (goto parse_expr_front))
    (if (|| (== type @OP_POSTFIX) (|| (== type @OP_APPLICATIVE) (== type @OP_OBJECT)))
        (goto parse_expr_middle)
        ))
    
    (output_loc stderr (get_loc))
    (output_string stderr "expect an infix or a postfix operator\n")
    (exit 1)

    (label parse_expr_end)

    (var len (list_len expr_stack))
    (if (== len 0) (return 0))
    (if (> len 1) (do
        (output_loc stderr (get_loc))
        (output_string stderr "irreducible expression\n")
        (exit 1)
        ))
    (return (car expr_stack))
    ))

(fun parse_successive_operator (offs in_seq) (
    (var tok (lex_infix offs))
    (if (|| (== tok @TOK_INFIX) (== tok @TOK_POSTFIX))
        (return (cons (get_token_boxed) (get_loc)))
        )
    (if (&& (! in_seq) (== tok ','))
        (return (cons comma_op (get_loc)))
        )
    (if (== tok '(') (do
        (var args (parse_comma_list (lex) ')'))
        (return (cons
            (variant @OP_APPLICATIVE 2 Apply args @ASSOC_SECONDARY)
            (get_loc)
            ))
        ))
    (if (== tok '[') (do
        (var args (parse_comma_list (lex) ']'))
        (return (cons
            (variant @OP_APPLICATIVE 2 Subscript args @ASSOC_SECONDARY)
            (get_loc)
            ))
        ))
    (if (== tok '{') (do
        (var args (parse_comma_list (lex) '}'))
        (return (cons
            (variant @OP_OBJECT 1 args)
            (get_loc)
            ))
        ))
    (if (&& (!= tok @TOK_EOF) (&& (!= tok @TOK_END)
        (&& (!= tok ',') (&& (!= tok ')') (&& (!= tok '}') (!= tok ']')))))) (do
        (output_loc stderr (get_loc))
        (output_string stderr "infix or postfix operator is required before `")
        (output_string stderr (get_token_text))
        (output_string stderr "'\n")
        (exit 1)
        ))
    (if (!= tok @TOK_END) (unput))
    (return (cons (variant @OP_END 0) (get_loc)))
    ))

(fun parse_primary (t) ((return (parse_primary_main t @TRUE))))

(fun parse_primary_main (t force) (
    (if (== t @TOK_CHAR)   (return (get_token_boxed))
    (if (== t @TOK_INT)    (return (box (get_token_unboxed)))
    (if (== t @TOK_FLOAT)  (return (make_float_from_string (get_token_text)))
    (if (== t @TOK_STRING) (return (get_token_boxed))
    (if (== t @TOK_SYMBOL) (return (get_token_boxed))
    (if (== t @TOK_CONSTR) (do
        (var op (get_token_boxed))
        (var head (field_get op 1))
        (if (== head DefModule) (return (parse_module)))
        (var offs (get_clmn))
        (var args 0)
        (while 1 (do
            (var e (try_parse_primary (lex_sub offs) offs))
            (if (! e) break)
            (= args (cons e args))
            ))
        (return (make_expr_user head (list_reverse args)))
        )
    (if (== t '(') (return (parse_tuple (lex)))
    (if (== t '[') (return (parse_list (lex)))
    (if (== t '{') (do
        (push_lextable current_mod)
        (var e (parse_block (lex)))
        (pop_lextable current_mod)
        (return e)
        )
        )))))))))

    (if force
        (do
            (output_loc stderr (get_loc))
            (output_string stderr "expect a literal expression")
            (exit 1)
        ))
    (unput)
    (return 0)
    ))

(fun try_parse_primary (tok offs) (
    (var expr_stack 0)
    (var op_stack 0)
    (var next_op 0)

    (= op_stack (list1 (cons (variant @OP_START 0) (get_loc))))

    (label try_parse_primary_front)
    (if (== tok @TOK_PREFIX) (do
        (var op (get_token_boxed))
        (if (!= (associativity op) @ASSOC_PRIMARY) (do
            (unput)
            (return 0)
            ))
        (= tok (lex_sub offs))
        (goto try_parse_primary_front)
        ))
    (if (cdr op_stack) ; length(op_stack) != 1
        (= expr_stack (cons (parse_primary tok) expr_stack))
        (do
            (var e (parse_primary_main tok @FALSE))
            (if (! e) (return 0))
            (= expr_stack (cons e expr_stack))
        ))
    
    (label try_parse_primary_middle)
    (= next_op (parse_primary_infix_operator offs))

    (while 1 (do
        (var comp (compare_associativity (car op_stack) next_op))
        (if (== comp 0) (goto try_parse_primary_end)
        (if (> comp 0)
            (do
                (var op (car op_stack))
                (= op_stack (cdr op_stack))
                (= expr_stack (reduce op expr_stack))
                continue
            )
            (do
                (= op_stack (cons next_op op_stack))
                break
            )
            ))
        ))

    (var type (field_get (car next_op) 0))
    (if (== type @OP_INFIX)
        (do (= tok (lex_sub offs)) (goto try_parse_primary_front))
    (if (== type @OP_POSTFIX)
        (goto try_parse_primary_middle)
        ))
    
    (output_loc stderr (get_loc))
    (output_string stderr "expect an infix or a postfix operator\n")
    (exit 1)

    (label try_parse_primary_end)

    (var len (list_len expr_stack))
    (if (== len 0) (return 0))
    (if (> len 1) (do
        (output_loc stderr (get_loc))
        (output_string stderr "irreducible expression\n")
        (exit 1)
        ))
    (return (car expr_stack))
    ))

(fun parse_primary_infix_operator (offs) (
    (var tok (lex_infix offs))
    (if (|| (== tok @TOK_INFIX) (== tok @TOK_POSTFIX)) (do
        (var op (get_token_boxed))
        (if (!= (associativity op) @ASSOC_PRIMARY) (do
            (unput)
            (return 0)
            ))
        (return (cons op (get_loc)))
        ))
    (if (!= tok @TOK_END) (unput))
    (return (cons (variant @OP_END 0) (get_loc)))
    ))

(fun parse_module () (
    (var offs (get_clmn))
    (var modsig (try_parse_primary (lex_sub offs) offs))
    (if (! modsig) (goto parse_module_error))
    (var module (find_module (get_loc) current_mod modsig))
    (if (!= (lex_sub offs) '{') (goto parse_module_error))
    (var save_current_mod current_mod)
    (set_current_module module)
    (var body (parse_block (lex)))
    (set_current_module save_current_mod)
    (return (make_expr_user DefModule (list2 modsig body)))

    (label parse_module_error)
    (output_loc stderr (get_loc))
    (output_string stderr "invalid syntax of module definition\n")
    (exit 1)
    ))

(fun parse_tuple (t) (
    (var elems (parse_comma_list t ')'))
    (if (&& elems (== (cdr elems) 0)) (return (car elems)))
    (return (make_expr_user Tuple elems))
    ))

(fun parse_list (t) (
    (var elems (parse_comma_list t ']'))
    (return elems)
    ))

(fun parse_comma_list (t end) (
    (if (== t end) (return 0))

    (var elems 0)
    (label parse_comma_list_loop)
    (var e (parse_expr t 0 @TRUE))
    (= elems (cons e elems))
    (= t (lex))
    (if (== t ',') (do
        (= t (lex))
        (goto parse_comma_list_loop)
        ))
    (eat t end)
    (return (list_reverse elems))
    ))

(fun parse_block (t) (
    (var elems 0)
    (if (!= t '}') (do
        (label parse_block_loop)

        (var begin (get_loc))
        (var e (parse_expr_top t (get_clmn)))
        (var end (get_loc))

        (= elems (cons (make_located (merge_loc begin end) e) elems))
        (= t (lex))
        (if (!= t '}') (goto parse_block_loop))
        ))
    (return (make_expr_user Block (list_reverse elems)))
    ))

(fun eat (tok expect) (
    (if (!= tok expect) (do
        (output_loc stderr (get_loc))
        (output_string stderr "expect '")
        (output_char stderr expect)
        (output_string stderr "' but got unknown token '")
        (output_string stderr (get_token_text))
        (output_string stderr "'\n")
        (exit 1)
        ))
    ))

(fun associativity (op) (
    (var type (field_get op 0))
    (if (== type @OP_PREFIX) (return (field_get op 3))
    (if (== type @OP_POSTFIX) (return (field_get op 3))
    (if (== type @OP_INFIX) (return (field_get op 4))
    (if (== type @OP_CONSTR) (return (field_get op 3))
    (if (== type @OP_APPLICATIVE) (return (field_get op 3))
    (if (== type @OP_OBJECT) (return @ASSOC_PRIMARY)
    (if (== type @OP_START) (return @ASSOC_MAX)
    (if (== type @OP_END) (return @ASSOC_MAX)
        ))))))))
    ))

(fun reduce (opinfo exprs) (
    (var op (car opinfo))
    (var type (field_get op 0))
    (if (|| (== type @OP_PREFIX) (== type @OP_POSTFIX))
        (do
            (var arg (car exprs))
            (var expr (make_expr_user (field_get op 1) (list1 arg)))
            (return (cons expr (cdr exprs)))
        )
    (if (== type @OP_INFIX)
        (do
            (var lhs (cadr exprs))
            (var rhs (car exprs))
            (var expr (make_expr_user (field_get op 1) (list2 lhs rhs)))
            (return (cons expr (cddr exprs)))
        )
    (if (== type @OP_APPLICATIVE)
        (do
            (var lhs (car exprs))
            (var expr (make_expr_user (field_get op 1) (list2 lhs (field_get op 2))))
            (return (cons expr (cdr exprs)))
        )
    (if (== type @OP_OBJECT)
        (do
            (var hd (car exprs))
            (if (!= (node_type hd) @SymbolE) (do
                (output_loc stderr (cdr opinfo))
                (output_string stderr "object header must be a Symbol\n")
                (exit 1)
                ))
            (var expr (make_expr_user hd (field_get op 1)))
            (return (cons expr (cdr exprs)))
        )))))
    ))

(fun compare_associativity (lop_info rop_info) (
    (var lop (car lop_info))
    (var rop (car rop_info))
    (var lassoc (associativity lop))
    (var rassoc (associativity rop))
    (if (!= lassoc rassoc) (return (- rassoc lassoc)))
    (var ltype (field_get lop 0))
    (var rtype (field_get rop 0))
    (if (== ltype @OP_START) (return 0))
    (if (&& (== ltype @OP_INFIX) (== rtype @OP_INFIX)) (do
        (var is_left_l (field_get lop 3))
        (var is_left_r (field_get rop 3))
        (if (== is_left_l is_left_r) (if is_left_l (return 1) (return -1)))
        ))
    (output_loc stderr (merge_loc (cdr lop_info) (cdr rop_info)))
    (output_string stderr "undetermined associativity ")
    (output_symbol stderr (field_get lop 1))
    (output_string stderr " <-> ")
    (output_symbol stderr (field_get rop 1))
    (output_char stderr '\n')
    (exit 1)
    ))

    ))
