;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-module.rlc 2013-05-28 10:17:47 nineties $
;

; Module
; Fields:
; - 1:vtbl       : variable table
; - 2:delegatees : list of modules
; - 3:delegators : list of modules
; - 4:count      : local variable index counter
; - 5:mark       : visited mark

; ModuleVariable{disp, ture iff this is not a display}
; disp = (value, location of definition)

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-error")

(extern object current_loc)

(export fun make_module (outer sym) (
    (var mod (variant @ModuleE 4
        (make_symtable 10)  ; variable table
        0   ; delegatees
        0   ; delegators
        (list1 (box 0))     ; local variable index counter
        0   ; visited-mark
        ))
    (if outer (do
        (add_delegator mod outer)
        (add_module_variable outer sym @C_FALSE mod)
        ))
    (return mod)
    ))

(export fun get_vartable (mod) (
    (return (field_get mod 1))
    ))

(export fun delegatees (mod) (
    (return (field_get mod 2))
    ))

(fun delegators (mod) (
    (return (field_get mod 3))
    ))

(var visited_mark 0)
(fun fresh_mark () (
    (+= visited_mark 1)
    (return visited_mark)
    ))

(fun get_mark (mod) (
    (return (field_get mod 5))
    ))

(fun set_mark (mod mark) (
    (field_set mod 5 mark)
    ))

(fun add_delegator (from to) (
    (field_set from 2 (cons to (list_delete to (field_get from 2))))
    (field_set to 3 (cons from (list_delete from (field_get to 3))))
    (update_module_variables from)
    ))

(fun del_delegator (from to) (
    (field_set from 2 (list_delete to (field_get from 2)))
    (field_set to 3 (list_delete from (field_get to 3)))
    (update_module_variables from)
    ))

;;; ModuleVariable
(fun is_display (v) (
    (if (&& (== (node_bhead v) ModuleVariable)
            (== (node_arg v 1) @C_FALSE))
        (return @TRUE) ; display
        )
    (return @FALSE)
    ))

(export fun get_module_variable_disp (sym info) (
    (if (!= (node_bhead info) ModuleVariable) (do
        (throw (unexpected_error current_loc
            (string "module variable is required")
            info))
        ))
    (return (node_arg info 0))
    ))

(export fun get_module_variable_value (sym info) (
    (return (car (get_module_variable_disp sym info)))
    ))

(export fun open_module (outer sig) (
    (var inner (find_module outer sig))
    (add_delegator outer inner)
    ))

(export fun close_module (outer sig) (
    (var inner (find_module outer sig))
    (del_delegator outer inner)
    ))

(fun collect_all_delegators (mark mod list) (
    (if (== (get_mark mod) mark) (return list))
    (set_mark mod mark)

    (= list (cons mod list))
    (var mods (delegators mod))
    (while mods (do
        (= list (collect_all_delegators mark (car mods) list))
        (= mods (cdr mods))
        ))
    (return list)
    ))

(fun update_module_variables (mod) (
    (var mods (collect_all_delegators (fresh_mark) mod 0))
    (while mods (do
        (var delegator (car mods))
        (var entries (symtable_entries (get_vartable delegator)))
        (for i 0 (vector_size entries) (do
            (var entry (vector_at entries i))
            (var sym (field_get entry 0))
            (var ent (field_get entry 1))
            (update_variable_entry delegator sym ent)
            ))
        (= mods (cdr mods))
        ))
    ))

(fun update_module_variables_single (mod sym) (
    (var mods (collect_all_delegators (fresh_mark) mod 0))
    (while mods (do
        (var delegator (car mods))
        (var ent (symtable_find (get_vartable delegator) sym))
        (if ent (update_variable_entry delegator sym ent))
        (= mods (cdr mods))
        ))
    ))

(fun lookup_all_symbols (mod sym) (
    (return (list_reverse (lookup_all_symbols_sub (fresh_mark) mod sym 0)))
    ))

(fun lookup_all_symbols_sub (mark mod sym list) (
    (if (== (get_mark mod) mark) (return list))
    (set_mark mod mark)

    (var vtbl (get_vartable mod))
    (var v (symtable_find vtbl sym))
    (if (&& v (! (is_display v))) (do
        (var disp (get_module_variable_disp sym v))
        (if (! (list_member disp list))
            (= list (cons disp list))
            )
        ))

    (var mods (delegatees mod))
    (while mods (do
        (= list (lookup_all_symbols_sub mark (car mods) sym list))
        (= mods (cdr mods))
        ))
    (return list)
    ))

(fun update_variable_entry (mod sym info) (
    (var mvar (lookup_symbol mod sym @TRUE))
    ; If non-display variable found, update the module variable entry.
    (if mvar
        (node_arg_set info 0 (get_module_variable_disp sym mvar))
        )
    ))

(export fun lookup_symbol (mod sig nodisp) (
    (var hd (node_bhead sig))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module mod (node_arg_symbol sig 0))
            (node_arg sig 1)
            nodisp
            )))
    (if (== hd BSymbol) (do
        (var v (lookup_symbol_iter (fresh_mark) mod sig nodisp))
        (return v)
        ))
    (throw (invalid_argument current_loc
        (string "invalid identifier")
        sig))
    ))

(fun lookup_symbol_iter (mark mod sym nodisp) (
    ; check visited-mark
    (if (== (get_mark mod) mark) (return 0))
    (set_mark mod mark)

    (var vtbl (get_vartable mod))
    (var v (symtable_find vtbl sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))

    (var mods (delegatees mod))
    (while mods (do
        (= v (lookup_symbol_iter mark (car mods) sym nodisp))
        (if (&& v (! (&& nodisp (is_display v)))) (return v))
        (= mods (cdr mods))
        ))
    (return 0)
    ))

(export fun lookup_symbol_current_module (mod sym nodisp) (
    (if (== (node_bhead sym) Qualified)
        (return (lookup_symbol_current_module
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            nodisp
            ))
        )
    (var v (symtable_find (get_vartable mod) sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))
    (return 0)
    ))

(export fun lookup_symbol_current_scope (mod sym nodisp) (
    (if (== (node_bhead sym) Qualified)
        (return (lookup_symbol_current_scope
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            nodisp
            ))
        )
    (var v (symtable_find_local (get_vartable mod) sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))
    (return 0)
    ))

(export fun find_module (curmod sig) (
    (var mod (lookup_symbol curmod sig @FALSE))
    (if (! mod) (throw (not_found current_loc sig)))
    (= mod (get_module_variable_value sig mod))
    (if (!= (node_type mod) @ModuleE)
        (throw (type_error current_loc (string "module") mod))
        )
    (return mod)
    ))

(export fun create_module (curmod sig) (
    (var hd (node_bhead sig))
    (if (== hd Qualified)
        (return (create_module
            (find_module curmod (node_arg sig 0))
            (node_arg sig 1)))
        )
    (if (!= hd BSymbol)
        (throw (invalid_argument current_loc
            (string "invalid identifier")
            sig))
        )

    (var mod (lookup_symbol_current_module curmod sig @TRUE))
    (if mod
        (do
            (= mod (get_module_variable_value sig mod))
            (if (!= (node_type mod) @ModuleE)
                (throw (type_error current_loc (string "module") mod))
                )
            (return mod)
        ))
    (return (make_module curmod sig))
    ))

(export fun add_module_variable (mod sym overwrite val) (
    (if (== (node_bhead sym) Qualified)
        (return (add_module_variable
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            overwrite
            val
        )))
    (var disp 0)
    (var ent (lookup_symbol_current_module mod sym @FALSE))
    (if (! ent) (do
        (= disp (struct 2 val current_loc))
        (= ent (make_object2 ModuleVariable disp @C_TRUE))
        (symtable_add_to_global (get_vartable mod) sym ent)
        (goto finish)
        ))
    (if (&& (== overwrite @C_FALSE) (== (node_arg ent 1) @C_TRUE)) (do
        (var prev_loc (field_get (node_arg ent 0) 1))
        (throw (redefined_var current_loc prev_loc sym))
        ))
    (= disp (struct 2 val current_loc))
    (node_arg_set ent 0 disp)
    (node_arg_set ent 1 @C_TRUE)

    (label finish)

    (update_module_variables_single mod sym)
    (return val)
    ))

(export fun is_local_var (v) (
    (if (== (node_bhead v) ModuleVariable)
        (return @TRUE) ; display
        )
    (return @FALSE)
    ))

(export fun get_variable_count (mod) (
    (return (unbox (car (field_get mod 4))))
    ))

(export fun set_variable_count (mod cnt) (
    (setcar (field_get mod 4) (box cnt))
    ))

(export fun reset_variable_count (mod) (
    (setcar (field_get mod 4) (box 0))
    ))

(export fun incr_variable_count (mod) (
    (var counters (field_get mod 4))
    (setcar counters (+ (car counters) 2)) ; counters are boxed
    ))

(export fun push_varscope (mod) (
    (symtable_push (get_vartable mod))
    (var counters (field_get mod 4))
    (field_set mod 4 (cons (car counters) counters))
    ))

(export fun pop_varscope (mod) (
    (symtable_pop (get_vartable mod))
    (field_set mod 4 (cdr (field_get mod 4)))
    ))

(export fun in_top_scope (mod) (
    (if (== (symtable_depth (get_vartable mod)) 1)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun add_symbol (mod sym v) (
    (symtable_add (get_vartable mod) sym v)
    ))

(export var uninitialized (to_sym "%uninitialized"))
(var uninitialized_disp (struct 2 uninitialized no_loc))
(export fun add_module_variable_display (mod sym) (
    (if (! (is_symbol sym))
        (throw (type_error current_loc (string "a symbol") sym))
        )
    (var ent (lookup_symbol_current_module mod sym @FALSE))
    (if (! ent) (do
        (var mvar (lookup_symbol mod sym @TRUE))
        (var disp 0)
        (if mvar
            (= disp (get_module_variable_disp sym mvar))
            (= disp uninitialized_disp)
            )
        (= ent (make_object2 ModuleVariable disp @C_FALSE))
        (symtable_add_to_global (get_vartable mod) sym ent)
        ))
    (return ent)
    ))

    ))
