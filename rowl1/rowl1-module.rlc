;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-module.rlc 2012-06-16 01:43:42 nineties $
;

; Module can be considered as a re-entrant scope.
; rowl (Amber) has a two kinds of modules; named module and anonymous module.
; 
; Fields:
; - sym       : name of the module (nil for anonymous module)
; - super     : a link to module where this module is defined.
; - imports   : list of imported modules.
; - children  : sub-modules in module hierarchy.
; - vtbl      : variable table
; - count     : local variable index counter
; - mark      : visited mark

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-error")

(extern object current_loc)

(export fun make_module (sym super) (
    (var mod (variant @ModuleE 6
        sym
        super
        0                   ; list of imported modules
        0                   ; children
        (make_symtable 10)  ; variable table
        (list1 (box 0))     ; local variable index counter
        0                   ; visited-mark
        ))
    (if super (do
        (if sym (add_module_variable super sym mod))
        (add_child super mod)
        ))
    (return mod)
    ))

(fun add_child (super sub) (
    (field_set super 4 (cons sub (list_delete sub (field_get super 4))))
    ))

(export fun is_effective_variable (v) (
    (if (! v) (return @FALSE))
    (if (&& (== (expr_head v) ModuleVariable) (== (expr_arg v 1) false))
        (return @FALSE)
        )
    (return @TRUE)
    ))

(var visited_mark 0)
(fun fresh_mark () (
    (+= visited_mark 1)
    (return visited_mark)
    ))

(export fun super_module (mod) (
    (return (field_get mod 2))
    ))

(fun add_module (curmod mod) (
    (field_set curmod 3 (cons mod (list_delete mod (field_get curmod 3))))
    ))

(export fun import_module (loc curmod sig) (
    (var mod (find_module loc curmod sig @FALSE))
    (add_module curmod mod)
    ))

(export fun add_symbol (mod sym v) (
    (symtable_add (field_get mod 5) sym v)
    ))

(export fun delete_symbol (mod sym) (
    (symtable_delete (field_get mod 5) sym)
    ))

(export fun lookup_symbol (mod sig) (
    (var hd (expr_head sig))
    (if (== hd Symbol)
        (return (lookup_symbol_iter (fresh_mark) mod sig @FALSE))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module current_loc mod (expr_arg sig 0) @FALSE) (expr_arg sig 1)))
        ))
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(export fun lookup_effective_symbol (mod sig) (
    (var hd (expr_head sig))
    (if (== hd Symbol)
        (return (lookup_symbol_iter (fresh_mark) mod sig @TRUE))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module current_loc mod (expr_arg sig 0) @FALSE) (expr_arg sig 1)))
        ))
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(fun lookup_symbol_iter (mark mod sym find_effective) (
    (while mod (do
        ; check visited-mark
        (if (== (field_get mod 7) mark) break)
        (field_set mod 7 mark)

        ; First, lookup variable table.
        (var tbl (field_get mod 5))
        (var v (symtable_find tbl sym))
        (if find_effective
            (if (is_effective_variable v) (return v))
            (if v (return v))
            )

        ; Next, lookup imported modules.
        (var imports (field_get mod 3))
        (while imports (do
            (= v (lookup_symbol_iter mark (car imports) sym find_effective))
            (if v (return v))
            (= imports (cdr imports))
            ))

        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun lookup_symbol_local (mod sym) (
    (var tbl (field_get mod 5))
    (return (symtable_find_local tbl sym))
    ))

(export fun lookup_symbol_current_module (mod sym) (
    (var tbl (field_get mod 5))
    (return (symtable_find tbl sym))
    ))

(export fun get_variable_count (mod) (
    (return (unbox (car (field_get mod 6))))
    ))

(export fun reset_variable_count (mod) (
    (setcar (field_get mod 6) (box 0))
    ))

(export fun incr_variable_count (mod) (
    (var counters (field_get mod 6))
    (setcar counters (+ (car counters) 2)) ; counters are boxed
    ))

(export fun push_varscope (mod) (
    (symtable_push (field_get mod 5))
    (var counters (field_get mod 6))
    (field_set mod 6 (cons (car counters) counters))
    ))

(export fun pop_varscope (mod) (
    (symtable_pop (field_get mod 5))
    (field_set mod 6 (cdr (field_get mod 6)))
    ))

; add definition of module variable `sym' to `mod'.
; `val' is a initial value.
(export fun add_module_variable (mod sym val) (
    (var ent (lookup_symbol_local mod sym))
    (if (! ent) (do
        (var box (struct 2 val current_loc))
        (= ent (make_expr ModuleVariable (list2 box true)))
        (symtable_add_to_global (field_get mod 5) sym ent)
        (goto update_displays)
        ))
    (if (== (expr_arg ent 1) true) (do
        (var prev_loc (field_get (expr_arg ent 0) 1))
        (throw (redefined_var current_loc sym))
        ))
    (expr_arg_set ent 1 true)
    (var box (struct 2 val current_loc))
    (expr_arg_set ent 0 box)
    ; update variable-displays
    (label update_displays)
    (var mark (fresh_mark))
    (var children (field_get mod 4))
    (while children (do
        (update_display_iter mark (car children) sym box)
        (= children (cdr children))
        ))
    (return val)
    ))

(export fun add_module_variable_display (mod sym box) (
    (var ent (lookup_symbol_local mod sym))
    (if (! ent) (do
        (= ent (make_expr ModuleVariable (list2 box false)))
        (symtable_add_to_global (field_get mod 5) sym ent)
        ))
    (return ent)
    ))
    
(fun update_display_iter (mark mod sym box) (
    (if (== (field_get mod 7) mark) return)
    (field_set mod 7 mark)
    (var vtbl (field_get mod 5))
    (var display (symtable_find_global vtbl sym))
    (if (&& display (== (expr_arg display 1) false))
        (expr_arg_set display 0 box)
        )
    (var children (field_get mod 4))
    (while children (do
        (update_display_iter mark (car children) sym box)
        (= children (cdr children))
        ))
    ))

(export fun find_module (loc curmod sig createp) (
    (var hd (expr_head sig))
    (if (== hd Symbol) (do
        (var mod (lookup_effective_symbol curmod sig))
        (if mod (return (car (expr_arg mod 0))))
        (if createp
            (return (make_module sig curmod))
            (throw (not_found loc sig))
            )
        ))
    (if (== hd Qualified)
        (return (find_module loc
             (find_module loc curmod (expr_arg_symbol sig 0) createp)
                 (expr_arg sig 1) createp))
        )
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(export fun in_top_scope (mod) (
    (if (== (symtable_depth (field_get mod 5)) 1)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun get_vartable (mod) (
    (return (field_get mod 5))
    ))

(export fun pp_module (ochan obj) (
    (var sym (field_get obj 1))
    (output_string ochan "<#Module:")
    (if sym
        (output_symbol ochan sym)
        (output_string ochan "(anonym)")
        )
    (output_string ochan ":")
    (output_hex ochan obj 8)
    (output_char ochan '>')
    ))

    ))
