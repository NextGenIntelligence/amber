;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-module.rlc 2011-12-14 00:09:58 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; - one file corresponds to one module of same name.
; - structure of module object:
;   (name : symbol,
;    super module : module,
;    variable table : symtable,
;    operator table : idtable,  # string repr -> operator
;    repr table : symtable, # head -> string repr
;   )
;
; XXX: implementation of operator table and repr table is heavy.
;   - try use assoc list

(compile `object `(

(import "rowl1-node")
(import "rowl1-symtable")

(export fun make_module (sym outer) (
    (return (variant @ModuleE 5
        sym
        outer
        (make_symtable 10)
        (make_idtable)
        (make_symtable 10)
        ))
    ))

(export fun super_module (mod) (
    (return (field_get mod 2))
    ))

(export fun vartable_add (mod sym v) (
    (symtable_add (field_get mod 3) sym v)
    ))

(export fun vartable_find (mod sym) (
    (while mod (do
        (var tbl (field_get mod 3))
        (var v (symtable_find tbl sym))
        (if v (return v))
        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun vartable_find_local (mod sym) (
    (var tbl (field_get mod 3))
    (return (symtable_find_local tbl sym))
    ))

(export fun vartable_find_global (mod sym) (
    (while mod (do
        (var tbl (field_get mod 3))
        (var v (symtable_find_global tbl sym))
        (if v (return v))
        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun push_vartable (mod) (
    (symtable_push (field_get mod 3))
    ))

(export fun pop_vartable (mod) (
    (symtable_pop (field_get mod 3))
    ))

(export fun find_module (loc curmod sig) (
	(var hd (expr_head sig))
	(if (== hd Symbol) (do
		(var mod (vartable_find_local curmod sig))
		(if (&& mod (!= (node_type mod) @ModuleE)) (do
			(output_loc stderr loc)
			(output_string stderr "variable ")
			(output_symbol stderr sig)
			(output_string stderr " is already defined\n")
			(exit 1)
			))
        (if (! mod) (do
            (= mod (make_module sig curmod))
            (vartable_add curmod sig mod)
            ))
		(return mod)
		))
    (if (== hd Qualified)
        (return (find_module loc (find_module loc curmod (expr_arg_symbol sig 0))
                    (expr_arg sig 1)))
        )
	(output_loc stderr loc)
	(output_string stderr "invalid module signature\n")
	(exit 1)
    ))

(export fun in_global_scope (mod) (
    (if (== (symtable_depth (field_get mod 3)) 1)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun get_vartable (mod) (
    (return (field_get mod 3))
    ))

(export fun count_local_variable (mod) (
    (return (symtable_count_local (field_get mod 3)))
    ))

(export fun add_operator (mod repr head op) (
    (var optbl (field_get mod 4))
    (var rptbl (field_get mod 5))
    (idtable_add optbl repr op)
    (if head (symtable_add rptbl head op))
    ))

(export fun lookup_operator (mod repr) (
    (while mod (do
        (var tbl (field_get mod 4))
        (var v (idtable_find tbl repr))
        (if v (return v))
        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun lookup_operator_from_head (mod head) (
    (while mod (do
        (var tbl (field_get mod 5))
        (var v (symtable_find tbl head))
        (if v (return v))
        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun push_lextable (mod) (
    (idtable_push (field_get mod 4))
    (symtable_push (field_get mod 5))
    ))

(export fun pop_lextable (mod) (
    (idtable_pop (field_get mod 4))
    (symtable_pop (field_get mod 5))
    ))

(export fun pp_module (ochan obj) (
    (var sym (field_get obj 1))
    (output_string ochan "<#Module:")
    (output_symbol ochan sym)
    (output_string stderr ":")
    (output_hex ochan obj 8)
    (output_char ochan '>')
    ))

    ))
