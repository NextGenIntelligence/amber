;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-module.rlc 2012-11-14 02:49:15 nineties $
;

; Module can be considered as a re-entrant scope.
; rowl (Amber) has a two kinds of modules; named module and anonymous module.
; 
; Fields:
; - 1:sym       : name of the module (nil for anonymous module)
; - 2:super     : a link to module where this module is defined.
; - 3:imports   : list of imported modules.
; - 4:users     : list of modules which import this module
; - 5:children  : sub-modules in module hierarchy.
; - 6:vtbl      : variable table
; - 7:count     : local variable index counter
; - 8:mark      : visited mark

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-error")

(extern object current_loc)

(export fun make_module (sym super) (
    (var mod (variant @ModuleE 7
        sym
        super
        0                   ; list of imported modules
        0                   ; list of modules which import this module
        0                   ; children
        (make_symtable 10)  ; variable table
        (list1 (box 0))     ; local variable index counter
        0                   ; visited-mark
        ))
    (if super (do
        (if (!= sym nil) (add_module_variable super sym mod false))
        (add_child super mod)
        ))
    (return mod)
    ))

(export fun is_anonymous_module (mod) (
    (return (== (field_get mod 1) nil))
    ))

(fun add_child (super sub) (
    (field_set super 5 (cons sub (list_delete sub (field_get super 5))))
    ))

(export fun is_defined_locally (v) (
    (if (! v) (return @FALSE))
    (if (&& (== (expr_head v) ModuleVariable)
        (|| (== (expr_arg v 1) false)
            (== (expr_arg v 2) true)
        ))
        (return @FALSE)
        )
    (return @TRUE)
    ))

(fun is_effective_variable (v) (
    (if (! v) (return @FALSE))
    (if (&& (== (expr_head v) ModuleVariable) (== (expr_arg v 1) false))
        (return @FALSE)
        )
    (return @TRUE)
    ))

(var visited_mark 0)
(fun fresh_mark () (
    (+= visited_mark 1)
    (return visited_mark)
    ))

(export fun super_module (mod) (
    (return (field_get mod 2))
    ))

(export fun opened_modules (mod) (
    (return (field_get mod 3))
    ))

(export fun open_module (loc curmod sig) (
    (var mod (find_module loc curmod sig @FALSE))
    (field_set curmod 3 (cons mod (list_delete mod (field_get curmod 3))))
    (field_set mod 4 (cons curmod (list_delete curmod (field_get mod 4))))

    ; add all definitions in `mod' to `curmod'
    (var entries (symtable_entries (field_get mod 6)))
    (for i 0 (vector_size entries) (do
        (var ent (vector_at entries i))
        (if (! ent) continue)
        (var info (field_get ent 1))
        (if (!= (expr_head info) ModuleVariable) continue)
        (var mark (fresh_mark))
        (update_module_variable mark curmod (field_get ent 0) (expr_arg info 0))
        ))
    ))

(export fun add_symbol (mod sym v) (
    (symtable_add (field_get mod 6) sym v)
    ))

(export fun delete_symbol (mod sym) (
    (symtable_delete (field_get mod 6) sym)
    ))

(export fun lookup_symbol (mod sig) (
    (var hd (expr_head sig))
    (if (== hd Symbol)
        (return (lookup_symbol_iter (fresh_mark) mod sig @FALSE))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module current_loc mod (expr_arg sig 0) @FALSE) (expr_arg sig 1)))
        ))
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(export fun lookup_effective_symbol (mod sig) (
    (var hd (expr_head sig))
    (if (== hd Symbol)
        (return (lookup_symbol_iter (fresh_mark) mod sig @TRUE))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module current_loc mod (expr_arg sig 0) @FALSE) (expr_arg sig 1)))
        ))
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(fun lookup_symbol_iter (mark mod sym find_effective) (
    (while mod (do
        ; check visited-mark
        (if (== (field_get mod 8) mark) break)
        (field_set mod 8 mark)

        (var tbl (field_get mod 6))
        (var v (symtable_find tbl sym))
        (if find_effective
            (if (is_effective_variable v) (return v))
            (if v (return v))
            )

        (= mod (super_module mod))
        ))
    (return 0)
    ))

(export fun lookup_symbol_local (mod sym) (
    (var tbl (field_get mod 6))
    (return (symtable_find_local tbl sym))
    ))

(export fun lookup_symbol_current_module (mod sym) (
    (var tbl (field_get mod 6))
    (return (symtable_find tbl sym))
    ))

(export fun get_variable_count (mod) (
    (return (unbox (car (field_get mod 7))))
    ))

(export fun reset_variable_count (mod) (
    (setcar (field_get mod 7) (box 0))
    ))

(export fun incr_variable_count (mod) (
    (var counters (field_get mod 7))
    (setcar counters (+ (car counters) 2)) ; counters are boxed
    ))

(export fun push_varscope (mod) (
    (symtable_push (field_get mod 6))
    (var counters (field_get mod 7))
    (field_set mod 7 (cons (car counters) counters))
    ))

(export fun pop_varscope (mod) (
    (symtable_pop (field_get mod 6))
    (field_set mod 7 (cdr (field_get mod 7)))
    ))

; add definition of module variable `sym' to `mod'.
; `val' is a initial value.
(export fun add_module_variable (mod sym val overwrite) (
    (var box nil)
    (var ent (lookup_symbol_local mod sym))
    (if (! ent) (do
        (= box (struct 2 val current_loc))
        (= ent (make_expr ModuleVariable (list3 box true false)))
        (symtable_add_to_global (field_get mod 6) sym ent)
        (goto update_displays)
        ))
    (if (&& (== overwrite false)
        (&& (== (expr_arg ent 1) true)
            (== (expr_arg ent 2) false))) (do
        (var prev_loc (field_get (expr_arg ent 0) 1))
        (throw (redefined_var current_loc prev_loc sym))
        ))
    (= box (struct 2 val current_loc))
    (expr_arg_set ent 0 box)
    (expr_arg_set ent 1 true)
    (expr_arg_set ent 2 false)
    ; update variable-displays
    (label update_displays)
    (var mark (fresh_mark))
    (var children (field_get mod 5))
    (while children (do
        (update_display_iter mark (car children) sym box)
        (= children (cdr children))
        ))

    (var users (field_get mod 4))
    (while users (do
        (update_module_variable mark (car users) sym box)
        (= users (cdr users))
        ))
    (return val)
    ))

(export fun add_module_variable_display (mod sym box) (
    (var ent (lookup_symbol_local mod sym))
    (if (! ent) (do
        (= ent (make_expr ModuleVariable (list3 box false false)))
        (symtable_add_to_global (field_get mod 6) sym ent)
        ))
    (return ent)
    ))

(fun update_module_variable (mark mod sym box) (
    (if (== (field_get mod 8) mark) return)
    (field_set mod 8 mark)
    (var vtbl (field_get mod 6))
    (var ent (symtable_find_global vtbl sym))
    (if ent
        (do
            (expr_arg_set ent 0 box)
            (expr_arg_set ent 1 true)
            (expr_arg_set ent 2 true)
        )
        (do
            (= ent (make_expr ModuleVariable (list3 box true true)))
            (symtable_add_to_global (field_get mod 6) sym ent)
        ))
    (var children (field_get mod 5))
    (while children (do
        (update_display_iter mark (car children) sym box)
        (= children (cdr children))
        ))
    ))
    
(fun update_display_iter (mark mod sym box) (
    (if (== (field_get mod 8) mark) return)
    (field_set mod 8 mark)
    (var vtbl (field_get mod 6))
    (var display (symtable_find_global vtbl sym))
    (if (&& display (== (expr_arg display 1) false)) (do
        (expr_arg_set display 0 box)
        ))
    (var children (field_get mod 5))
    (while children (do
        (update_display_iter mark (car children) sym box)
        (= children (cdr children))
        ))
    ))

(extern fun must_be_module_variable)
(export fun find_module (loc curmod sig createp) (
    (var hd (expr_head sig))
    (if (== hd Symbol) (do
        (var mod (lookup_effective_symbol curmod sig))
        (if mod (do
            (must_be_module_variable sig mod)
            (= mod (car (expr_arg mod 0)))
            (if (!= (expr_head mod) Module)
                (throw (type_error (loc (string "module") mod)))
                )
            (return mod)
            ))
        (if createp
            (return (make_module sig curmod))
            (throw (not_found loc sig))
            )
        ))
    (if (== hd Qualified)
        (return (find_module loc
             (find_module loc curmod (expr_arg_symbol sig 0) createp)
                 (expr_arg sig 1) createp))
        )
    (throw (type_error current_loc
        (string "module signature")
        sig
        ))
    ))

(export fun in_top_scope (mod) (
    (var sym (field_get mod 1))
    (if (&& (== (symtable_depth (field_get mod 6)) 1) (!= sym nil))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun get_vartable (mod) (
    (return (field_get mod 6))
    ))

(export fun pp_module (ochan obj) (
    (var sym (field_get obj 1))
    (output_string ochan "<#Module:")
    (if (!= sym nil)
        (output_symbol ochan sym)
        (output_string ochan "(anonym)")
        )
    (output_string ochan ":")
    (output_hex ochan obj 8)
    (output_char ochan '>')
    ))

    ))
