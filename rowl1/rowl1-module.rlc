;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-module.rlc 2013-07-06 19:35:24 nineties $
;

; Modules has pre-ordering relationship (denoted by A -> B).
; Modules X s.t. X -> A are called `lower modules` of A.
; Modules X s.t. A -> X are called `upper modules` of A.

; Properties:
; A -> A
; A -> B, B -> C => A -> C

;lookup(A, x) is redirected to lookup(B, x) when A -> B and lookup(A, x) is undefined.

; Module
; Fields:
; - 1:name       : symbol
; - 2:vtbl       : variable table
; - 3:upper      : list of direct upper modules
; - 4:lower      : list of direct lower modules
; - 5:count      : local variable index counter
; - 6:mark       : visited mark

; ModuleVariable{disp, ture iff this is not a display}
; disp = (value, location of definition)

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-error")

(extern object current_loc)

;; interfaces

(export fun make_module (upper name) (
    (if (!= (node_type name) @SymbolE)
        (throw (type_error current_loc
            (string "symbol") name))
        )
    (var m (variant @ModuleE 5
        name
        (make_symtable 10)  ; variable table
        0   ; list of direct upper modules
        0   ; list of direct lower modules
        (list1 (box 0))     ; local variable index counter
        0   ; visited-mark
        ))
    (if upper (do
        (open_module m upper)
        (add_module_variable upper name @FALSE m)
        ))
    (return m)
    ))

(export fun module_name (mod) (
    (return (field_get mod 1))
    ))

(export fun pp_module (ochan mod) (
    (output_string ochan "<#")
    (output_symbol ochan (module_name mod))
    (output_string ochan ":0x")
    (output_hex ochan mod 8)
    (output_char ochan '>')
    (return @C_NIL)
    ))

(export fun variable_table (mod) (
    (return (field_get mod 2))
    ))

(fun upper_modules (mod) (
    (return (field_get mod 3))
    ))

(fun set_upper_modules (mod upper_list) (
    (field_set mod 3 upper_list)
    ))

(fun lower_modules (mod) (
    (return (field_get mod 4))
    ))

(fun set_lower_modules (mod lower_list) (
    (field_set mod 4 lower_list)
    ))

(var visited_mark 0)
(fun fresh_mark () (
    (+= visited_mark 1)
    (return visited_mark)
    ))

(fun variable_counters (mod) (
    (return (field_get mod 5))
    ))

(fun set_variable_counters (mod cnt) (
    (field_set mod 5 cnt)
    ))

(fun get_mark (mod) (
    (return (field_get mod 6))
    ))

(fun set_mark (mod mark) (
    (field_set mod 6 mark)
    ))

(export fun open_module (lower upper) (
    (set_lower_modules upper (cons lower (list_delete lower (lower_modules upper))))
    (set_upper_modules lower (cons upper (list_delete upper (upper_modules lower))))
    (update_module_variable_disps lower)
    (return @C_NIL)
    ))

(export fun extend_module (lower upper) (
    (var entries (symtable_entries (variable_table lower)))
    (for i 0 (vector_size entries) (do
        (var entry (vector_at entries i))
        (var sym (field_get entry 0))
        (var ent (field_get entry 1))
        (extend_module_variable_entry ent sym upper)
        ))
    (return @C_NIL)
    ))

(extern fun fusion_function)
(fun extend_module_variable_entry (mvar1 sym mod) (
    (if (is_display mvar1) return)
    (var val1 (get_module_variable_value sym mvar1))
    (if (! (is_function val1)) return)
    (var mvar2 (lookup_symbol mod sym @TRUE))
    (if (! mvar2) return)
    (var val2 (get_module_variable_value sym mvar2))
    (modify_module_variable mvar1 (fusion_function val2 val1))
    ))

(fun modify_module_variable (mvar val) (
    (field_set (node_arg mvar 0) 0 val)
    return
    ))

(fun update_module_variable_disps (mod) (
    (var mods (collect_reachable_modules mod 0 (fresh_mark)))
    (while mods (do
        (= mod (car mods))
        (var entries (symtable_entries (variable_table mod)))
        (for i 0 (vector_size entries) (do
            (var entry (vector_at entries i))
            (var sym (field_get entry 0))
            (var ent (field_get entry 1))
            (update_module_variable_entry mod sym ent)
            ))
        (= mods (cdr mods))
        ))
    return
    ))

(fun update_module_variable_disp (mod sym) (
    (var mods (collect_reachable_modules mod 0 (fresh_mark)))
    (while mods (do
        (= mod (car mods))
        (var ent (symtable_find (variable_table mod) sym))
        (if ent (update_module_variable_entry mod sym ent))
        (= mods (cdr mods))
        ))
    return
    ))

(fun update_module_variable_entry (mod sym ent) (
    (if (! (is_display ent)) return)
    (var mvar (lookup_symbol mod sym @TRUE))
    (if mvar
        (node_arg_set ent 0 (get_module_variable_disp sym mvar))
        )
    ))

;;; ModuleVariable
(fun is_display (v) (
    (if (&& (== (node_bhead v) ModuleVariable)
            (== (node_arg v 1) @C_FALSE))
        (return @TRUE) ; display
        )
    (return @FALSE)
    ))

(export fun get_module_variable_disp (sym info) (
    (if (!= (node_bhead info) ModuleVariable) (do
        (throw (unexpected_error current_loc
            (string "module variable is required")
            info))
        ))
    (return (node_arg info 0))
    ))

(export fun get_module_variable_value (sym info) (
    (return (car (get_module_variable_disp sym info)))
    ))

(fun collect_reachable_modules (mod list mark) (
    (if (== (get_mark mod) mark) (return list))
    (set_mark mod mark)

    (= list (cons mod list))
    (var mods (lower_modules mod))
    (while mods (do
        (= list (collect_reachable_modules (car mods) list mark))
        (= mods (cdr mods))
        ))
    (return list)
    ))

(fun lookup_all_symbols (mod sym) (
    (return (list_reverse (lookup_all_symbols_sub (fresh_mark) mod sym 0)))
    ))

(fun lookup_all_symbols_sub (mark mod sym list) (
    (if (== (get_mark mod) mark) (return list))
    (set_mark mod mark)

    (var vtbl (variable_table mod))
    (var v (symtable_find vtbl sym))
    (if (&& v (! (is_display v))) (do
        (var disp (get_module_variable_disp sym v))
        (if (! (list_member disp list))
            (= list (cons disp list))
            )
        ))

    (var mods (upper_modules mod))
    (while mods (do
        (= list (lookup_all_symbols_sub mark (car mods) sym list))
        (= mods (cdr mods))
        ))
    (return list)
    ))

(export fun lookup_symbol (mod sig nodisp) (
    (var hd (node_bhead sig))
    (if (== hd Qualified)
        (return (lookup_symbol
            (find_module mod (node_arg_symbol sig 0))
            (node_arg sig 1)
            nodisp
            )))
    (if (== hd BSymbol)
        (return (lookup_symbol_iter (fresh_mark) mod sig nodisp))
        )
    (throw (invalid_argument current_loc
        (string "invalid identifier")
        sig))
    ))

(fun lookup_symbol_iter (mark mod sym nodisp) (
    ; check visited-mark
    (if (== (get_mark mod) mark) (return 0))
    (set_mark mod mark)

    (var vtbl (variable_table mod))
    (var v (symtable_find vtbl sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))

    (var mods (upper_modules mod))
    (while mods (do
        (= v (lookup_symbol_iter mark (car mods) sym nodisp))
        (if (&& v (! (&& nodisp (is_display v)))) (return v))
        (= mods (cdr mods))
        ))
    (return 0)
    ))

(export fun lookup_symbol_current_module (mod sym nodisp) (
    (if (== (node_bhead sym) Qualified)
        (return (lookup_symbol_current_module
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            nodisp
            ))
        )
    (var v (symtable_find (variable_table mod) sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))
    (return 0)
    ))

(export fun lookup_symbol_current_scope (mod sym nodisp) (
    (if (== (node_bhead sym) Qualified)
        (return (lookup_symbol_current_scope
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            nodisp
            ))
        )
    (var v (symtable_find_local (variable_table mod) sym))
    (if (&& v (! (&& nodisp (is_display v)))) (return v))
    (return 0)
    ))

(export fun find_module (curmod sig) (
    (var mod (lookup_symbol curmod sig @FALSE))
    (if (! mod) (throw (not_found current_loc sig)))
    (= mod (get_module_variable_value sig mod))
    (if (!= (node_type mod) @ModuleE)
        (throw (type_error current_loc (string "module") mod))
        )
    (return mod)
    ))

(export fun create_module (curmod sig) (
    (var hd (node_bhead sig))
    (if (== hd Qualified)
        (return (create_module
            (find_module curmod (node_arg sig 0))
            (node_arg sig 1)))
        )
    (if (!= hd BSymbol)
        (throw (invalid_argument current_loc
            (string "invalid identifier")
            sig))
        )

    (var mod (lookup_symbol_current_module curmod sig @TRUE))
    (if mod
        (do
            (= mod (get_module_variable_value sig mod))
            (if (!= (node_type mod) @ModuleE)
                (throw (type_error current_loc (string "module") mod))
                )
            (return mod)
        ))
    (return (make_module curmod sig))
    ))

(export fun add_module_variable (mod sym overwrite val) (
    (if (== (node_bhead sym) Qualified)
        (return (add_module_variable
            (find_module mod (node_arg_symbol sym 0))
            (node_arg sym 1)
            overwrite
            val
        )))
    (var disp 0)
    (var ent (lookup_symbol_current_module mod sym @FALSE))
    (if (! ent) (do
        (= disp (struct 2 val current_loc))
        (= ent (make_object2 ModuleVariable disp @C_TRUE))
        (symtable_add_to_global (variable_table mod) sym ent)
        (goto finish)
        ))
    (if (&& (== overwrite @C_FALSE) (== (node_arg ent 1) @C_TRUE)) (do
        (var prev_loc (field_get (node_arg ent 0) 1))
        (throw (redefined_var current_loc prev_loc sym))
        ))
    (= disp (struct 2 val current_loc))
    (node_arg_set ent 0 disp)
    (node_arg_set ent 1 @C_TRUE)

    (label finish)

    (update_module_variable_disp mod sym)
    (return val)
    ))

(export fun is_local_var (v) (
    (if (== (node_bhead v) ModuleVariable)
        (return @TRUE) ; display
        )
    (return @FALSE)
    ))

(export fun get_variable_count (mod) (
    (return (unbox (car (variable_counters mod))))
    ))

(export fun set_variable_count (mod cnt) (
    (setcar (variable_counters mod) (box cnt))
    ))

(export fun reset_variable_count (mod) (
    (setcar (variable_counters mod) (box 0))
    ))

(export fun incr_variable_count (mod) (
    (var counters (variable_counters mod))
    (setcar counters (+ (car counters) 2)) ; NB: counters are boxed
    ))

(export fun push_varscope (mod) (
    (symtable_push (variable_table mod))
    (var counters (variable_counters mod))
    (set_variable_counters mod (cons (car counters) counters))
    ))

(export fun pop_varscope (mod) (
    (symtable_pop (variable_table mod))
    (set_variable_counters mod (cdr (variable_counters mod)))
    ))

(export fun in_top_scope (mod) (
    (if (== (symtable_depth (variable_table mod)) 1)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun add_symbol (mod sym v) (
    (symtable_add (variable_table mod) sym v)
    ))

(export var uninitialized (to_sym "%uninitialized"))
(var uninitialized_disp (struct 2 uninitialized no_loc))
(export fun add_module_variable_display (mod sym) (
    (if (! (is_symbol sym))
        (throw (type_error current_loc (string "a symbol") sym))
        )
    (var ent (lookup_symbol_current_module mod sym @FALSE))
    (if (! ent) (do
        (var mvar (lookup_symbol mod sym @TRUE))
        (var disp 0)
        (if mvar
            (= disp (get_module_variable_disp sym mvar))
            (= disp uninitialized_disp)
            )
        (= ent (make_object2 ModuleVariable disp @C_FALSE))
        (symtable_add_to_global (variable_table mod) sym ent)
        ))
    (return ent)
    ))

    ))
