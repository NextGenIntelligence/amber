;
; rowl - 1st generation
; Copyright (C) 2012 nineties
;
; $Id: rowl1-float.rlc 2013-11-26 09:19:56 nineties $
;

; Since Amber has no 64-bit integer, this source code uses bignums instead.
; It will be refined in newer version of Amber.

(import "rlvm-compile")
(import "rowl1-types")

(var FORMAT_KMIN -4)

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")
(import "rowl1-base")
(import "rowl1-bigint")

(extern object current_loc)

(export fun pp_float (ochan f) (
    (output_string ochan (float_to_s f))
    ))

(export fun float_sign (f) (
    (if (< (field_get f 1) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun float_is_zero (f) (
    (if (&& (== (& (field_get f 1) 0x7fffffff) 0)
            (== (field_get f 0) 0))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun float_positive (f) (
    (if (&& (! (float_sign f)) (! (float_is_zero f)))
        (return @TRUE)
        (return @FALSE)
        )
    ))

; ==== translate ascii-string to floating-point number ====
; Bellorphon-method
; (cf. William D Clinger, "How to Read Floating Point Numbers Accurately")

(var ten^9 (uint_to_bint 1000000000))

(export fun float_from_s (str) (
    ; "XXXX.YYYYeZZZZ" => f*10^e
    (var p 0)
    (var slen (strlen str))
    (var sign 0)
    (if (== (array_get char str 0) '-') (do
        (= sign 1)
        (+= p 1)
        ))
    (var f (box 0))
    (var e 0)

    (var mlen 0)
    (var ndigit 0)
    (while (< mlen slen) (do
        (var c (array_get char str mlen))
        (if (== c 'e') break)
        (if (&& (!= c '.') (|| (> ndigit 0) (&& (<= '1' c) (<= c '9')))) (+= ndigit 1))
        (+= mlen 1)
        ))

    (var mlen slen)
    (while (&& (> mlen 0) (!= (array_get char str (- mlen 1)) 'e')) (-= mlen 1))
    (if (== mlen 0)
        (= mlen slen)
        (-= mlen 1)
        )

    (var r (umod (- (- mlen p) 1) 9))
    (while (< p mlen) (do
        (var w 0)
        (while (> r 0) (do
            (var c (array_get char str p))
            (if (== c '.') (do
                (= e 0)
                (+= p 1)
                continue
                ))
            (if (|| (< c '0') (< '9' c))
                (throw (invalid_format current_loc (string str)))
                )
            (= w (+ (* 10 w) (- c '0')))
            (-= r 1)
            (+= p 1)
            (-= e 1)
            ))
        (if (!= f 1)
            (= f (mul f ten^9))
            )
        (= f (add f (box w)))
        (= r 9)
        ))
    (if (== (array_get char str p) 'e') (do
        (+= p 1)
        (var neg @FALSE)
        (if (== (array_get char str p) '-') (do (+= p 1) (= neg @TRUE)))
        (var d 0) 
        (while (< p slen) (do
            (var c (array_get char str p))
            (if (|| (< c '0') (< '9' c))
                (throw (invalid_format current_loc (string str)))
                )
            (= d (+ (* 10 d) (- c '0')))
            (+= p 1)
            ))
        (if neg (= d (- d)))
        (+= e d)
        ))

    (if (== f 1) (do (= ndigit 0) (= e 0)))
    
    (return (encode_float sign f ndigit e))
    ))

;; translate f*10^e to IEEE754 floating point
(var two^10 (bigshl (uint_to_bint 1) 10))
(var two^11 (bigshl (uint_to_bint 1) 11))
(var two^52 (bigshl (uint_to_bint 1) 52))
(var two^53 (bigshl (uint_to_bint 1) 53))
(var two^63 (bigshl (uint_to_bint 1) 63))
(var two^64 (bigshl (uint_to_bint 1) 64))

; This implementation is not efficient.
(fun encode_float (sign f n e) (
    (if (bint_is_zero f) (return (float_zero)))

    (= f (to_bint f))
    (if (>= e 0)
        (do
            (while (>= e 9) (do
                (= f (mul f ten^9))
                (-= e 9)
                ))
            (while (> e 0) (do
                (= f (mul f (box 10)))
                (-= e 1)
                ))
            (= f (to_bint f))
            (var nbits (bint_ndigits2 f))
            (var exp (- nbits 1))
            (var Rbit 0)
            (var Gbit 0)
            (if (> exp 1024) (if sign (return (float_uminus (float_infinity))) (return (float_infinity))))
            (if (> nbits 53)
                (do
                    ; check R and G bit
                    (var w (- nbits 54))
                    (var i 0)
                    (while (>= w 32) (do
                        (if (!= (bint_digit f i) 0) (= Rbit 1))
                        (+= i 1)
                        (-= w 32)
                        ))
                    (if (& (bint_digit f i) (- (<< 1 w) 1)) (= Rbit 1))
                    (if (& (bint_digit f i) (<< 1 w)) (= Gbit 1))

                    (bigshr f (- nbits 53))
                )
            (if (< nbits 53) (bigshr f (- nbits 53))))
            (var lo (bint_digit f 0))
            (var ulp (& lo 1))
            (if (&& Gbit (|| ulp Rbit))
                (= f (to_bint (add f (box 1))))
                )
            (= nbits (bint_ndigits2 f))
            (if (!= nbits 53) (bigshr f (- nbits 53)))
            (= lo (bint_digit f 0))
            (var hi (bint_digit f 1))
            (= hi (| (& hi 0xfffff) (<< (& (+ exp 1023) 0x7ff) 20)))
            (if sign (= hi (| hi 0x80000000)))
            (var float (allocate_float))
            (field_set float 0 lo)
            (field_set float 1 hi)
            (return float)
        )
        (do
            (= e (- e))
            (var n (bint_ndigits2 f))
            (var p (+ (- 55 (- n 1)) (* e 4)))
            (var Rbit 0)
            (var Gbit 0)
            (bigshl f p)

            ; create 10^e
            (var b (box 1))
            (while (>= e 9) (do
                (= b (mul b ten^9))
                (-= e 9)
                ))
            (while (> e 0) (do
                (= b (mul b (box 10)))
                (-= e 1)
                ))
            (if (! (bint_is_zero (bigdiv f (to_bint b)))) (= Rbit 1))
            (var nbits (bint_ndigits2 f))
            (if (> nbits 53) (do
                ; check R and G bit
                (var w (- nbits 54))
                (var i 0)
                (while (>= w 32) (do
                    (if (!= (bint_digit f i) 0) (= Rbit 1))
                    (+= i 1)
                    (-= w 32)
                    ))
                (if (& (bint_digit f i) (- (<< 1 w) 1)) (= Rbit 1))
                (if (& (bint_digit f i) (<< 1 w)) (= Gbit 1))

                (bigshr f (- nbits 53))
                (-= p (- nbits 53))
                ))
            (var lo (bint_digit f 0))
            (var ulp (& lo 1))
            (if (&& Gbit (|| ulp Rbit)) (do
                (= f (to_bint (add f (box 1))))
                ))
            (= nbits (bint_ndigits2 f))
            (if (!= nbits 53) (bigshr f (- nbits 53)))
            (var exp (- (- nbits  p) 1))
            (if (< exp -1022) (do
                ; denormal number
                (if (<= exp -1075) (return (float_zero)))
                (var w (- (+ exp 1022)))
                (= Rbit 0)
                (= Gbit 0)
                (= ulp 0)
                (if (& (- (<< 1 (- w 1)) 1) (bint_digit f 0)) (= Rbit 1))
                (if (& (<< 1 (- w 1)) (bint_digit f 0)) (= Gbit 1))
                (if (& (<< 1 w) (bint_digit f 0)) (= ulp 1))
                (bigshr f w)
                (if (&& Gbit (|| ulp Rbit)) (= f (to_bint (add f (box 1)))))
                (= exp -1023)
                ))
            (= lo (bint_digit f 0))
            (var hi (bint_digit f 1))
            (= hi (| (& hi 0xfffff) (<< (& (+ exp 1023) 0x7ff) 20)))
            (if sign (= hi (| hi 0x80000000)))
            (var float (allocate_float))
            (field_set float 0 lo)
            (field_set float 1 hi)
            (return float)
        ))
    ))

; ==== translate floating-point number to ascii-string ====

(fun float_to_s (v) (
    (var s 0)
    (var f0 (field_get v 0))
    (var f1 (field_get v 1))
    (if (&& (! f0) (! f1)) (do
        (return (string "0.0"))
        ))
    (if (& f1 0x80000000) (do
        (= s 1)
        (= v (float_uminus v))
        ))
    (var e (- (& (>> f1 20) 0x7ff) 1023))
    (= f1 (& f1 0xfffff))
    
    (if (== e 1024)
        (if (&& (== f1 0) (== f0 0))
            (if s
                (return (string "-infinity"))
                (return (string "infinity"))
                )
            (return (string "NaN"))
            )
        )

    (var f (allocate_bint 2))
    (field_set f 1 2)
    (bint_set_digit f 0 f0)

    (if (== e -1023)
        (do
            (bint_set_digit f 1 f1)
            (= e -1022)
        )
        (bint_set_digit f 1 (| f1 (<< 1 20)))
        )
    (return (decode_float s f e))
    ))

; v: abs of input floating-point number.
; f: mantissa (bigint)
; e: exponent
(var ten (int_to_bint 10))
(fun decode_float (sign f e) (
    (-= e 52)

    ; find k s.t. 10^k <= f*2^e < 10^(k+1) by linear search.
    ; It is not efficient.
    (var f_save (copy_bint f))
    (var k 0)
    (if (>= e 0)
        (do
            (bigshl f e)
            (var b (int_to_bint 1))
            (while (>= (bigcmp f b) 0) (do
                (bigmul b ten)
                (+= k 1)
                ))
            (-= k 1)
        )
        (do
            (var b (int_to_bint 1))
            (bigshl b (- e))
            (if (>= (bigcmp f b) 0)
                (do
                    (while (>= (bigcmp f b) 0) (do
                        (bigmul b ten)
                        (+= k 1)
                        ))
                    (-= k 1)
                )
                (do
                    (while (< (bigcmp f b) 0) (do
                        (bigmul f ten)
                        (-= k 1)
                        ))
                ))
        ))
    (= f f_save)

    ; find integer m (10^15 <= m < 10^16) s.t. by binary search
    ; m * 10^(k-15) <= f*2^e < (m+1) * 10^(k-15)
    (var left  (parse_bint "1000000000000000"))
    (var right (parse_bint "10000000000000000"))
    (var b (int_to_bint 1))
    (var kk (- k 15))
    (if (< kk 0) (= kk (- kk)))
    (while (> kk 0) (do (bigmul b ten) (-= kk 1)))
    (while (!= (bint_sub right left) (box 1)) (do
        (var m (bint_shiftR (bint_add left right) (box 1)))
        (var m2 (copy_bint m))
        (var f2 (copy_bint f))
        (if (>= e 0)
            (bigshl f2 e)
            (bigshl m2 (- e))
            )
        (if (>= k 15)
            (bigmul m2 b)
            (bigmul f2 b)
            )
        (if (<= (bigcmp m2 f2) 0)
            (= left m)
            (= right m)
            )
        ))

    ; select left or right
    (var r (bint_mod left (box 10)))
    (var m left)
    (if (== r (box 9)) (= m right))

    (var digits (bint_to_s m))
    (var exp (- k 15))
    (rfor i 0 (strlen digits) (do
        (if (== (array_get char digits i) '0')
            (do
                (array_set char digits i '\0')
                (+= exp 1)
            )
            break
            )
        ))
    (var n (strlen digits))
    (return (format_float sign (+ exp n) digits n))
    ))

; v: abs of input floating-point number.
; f: mantissa (bigint)
; e: exponent
;(fun decode_float (sign f e) (
;    (-= e 52)
;    (var b (int_to_bint 1))
;    (var B (int_to_bint 10))
;    (var round_p (bint_even f))
;    (if (>= e 0)
;        (if (== (bint_eq f (bigshl (copy_bint b) 52)) @C_FALSE)
;            (do
;                (var be (bigshl (copy_bint b) e))
;                (var fbe2 (bigshl (bigmul f be) 1))
;                (return (scale sign fbe2 (int_to_bint 2) be be 0 B round_p round_p))
;            )
;            (do
;                (var be (bigshl (copy_bint b) e))
;                (var be1 (bigshl (copy_bint be) 1))
;                (var fbe12 (bigshl (bigmul f be1) 1))
;                (return (scale sign fbe12 (int_to_bint 4) be1 be 0 B round_p round_p))
;            ))
;        (if (|| (== e -1022) (== (bint_eq f (bigshl (copy_bint b) 52)) @C_FALSE))
;            (return (scale sign (bigshl f 1) (bigshl b (- 1 e)) (int_to_bint 1) (int_to_bint 1) 0 B round_p round_p))
;            (return (scale sign (bigshl f 2) (bigshl b (- 2 e)) (int_to_bint 2) (int_to_bint 1) 0 B round_p round_p))
;            ))
;    ))
;
;(fun scale (sign r s mp mm k B low_ok high_ok) (
;    (var rmp (bigadd (copy_bint r) mp))
;    (if (|| (&& high_ok (>= (bigcmp rmp s) 0))
;            (&& (! high_ok) (> (bigcmp rmp s) 0))) (do
;        (return (scale sign r (bigmul s B) mp mm (+ k 1) B low_ok high_ok)))
;        )
;    (bigmul rmp B)
;    (if (|| (&& high_ok (< (bigcmp rmp s) 0))
;            (&& (! high_ok) (<= (bigcmp rmp s) 0)))
;        (return (scale sign (bigmul r B) s (bigmul mp B) (bigmul mm B) (- k 1)
;                    B low_ok high_ok)))
;
;    ; the precision of IEEE 64-bit floating point number is
;    ; less than or equal 16 digits in base 10.
;    (var digits (allocate_carray 16))
;    (var n (generate digits 0 r s mp mm B low_ok high_ok))
;    (return (format_float sign k digits n))
;    ))
;
; Format  0.d1 d2 ... dn 10^k to
; d1 d2 ..... dn . 0           (when n = k)
; d1 d2 ... dk . d(k+1) ... dn (when k > 0 and n > k)
; d1 . d2 ... dn e(k-1)        (when k > 0 and n < k) 
; 0.0 0 0 0 d1 ... dn          (when kmin < k <= 0)
; d1 . d2 ... dn e(k-1)        (when k <= kmin)
(fun format_float (sign k ds n) (
    (var len n)
    (if sign (+= len 1))
    (if (== n k) (do
        (var s (allocate_string (+ len n)))
        (var i 0)
        (if sign (do (array_set char s 0 '-') (+= i 1)))
        (for j 0 n (do
            (array_set char s i (array_get char ds j))
            (+= i 1)
            ))
        (array_set char s i '.')
        (array_set char s (+ i 1) '0')
        (return s)
        ))
    (if (&& (> k 0) (> n k))
        (do
            (var s (allocate_string (+ len 1)))
            (var i 0)
            (if sign (do (array_set char s 0 '-') (+= i 1)))
            (for j 0 n (do
                (if (== j k) (do
                    (array_set char s i '.')
                    (+= i 1)
                    ))
                (array_set char s i (array_get char ds j))
                (+= i 1)
                ))
            (return s)
        )
    (if (|| (&& (> k 0) (< n k)) (<= k @FORMAT_KMIN))
        (do
            (var s (allocate_string (+ len 8)))
            (var i 0)
            (if sign (do (array_set char s 0 '-') (+= i 1)))
            (array_set char s i (array_get char ds 0))
            (array_set char s (+ i 1) '.')
            (+= i 2)
            (if (== n 1)
                (do (array_set char s i '0') (+= i 1))
                (for j 1 n (do
                    (array_set char s i (array_get char ds j))
                    (+= i 1)
                    ))
                )
            (array_set char s i 'e')
            (+= i 1)
            
            (-= k 1)
            (if (< k 0) (do
                (array_set char s i '-')
                (+= i 1)
                (= k (- k))))
            (var d 1000)
            (while (== (/ k d) 0) (/= d 10))
            (while (> d 0) (do
                (array_set char s i (+ (/ k d) '0'))
                (%= k d)
                (/= d 10)
                (+= i 1)
                ))
            (return s)
        )))
    (var s (allocate_string (+ (+ len (- k)) 2)))
    (var i 0)
    (if sign (do (array_set char s 0 '-') (+= i 1)))
    (array_set char s i '0')
    (array_set char s (+ i 1) '.')
    (+= i 2)
    (= k (- k))
    (while (> k 0) (do
        (array_set char s i '0')
        (+= i 1)
        (-= k 1)
        ))
    (for j 0 n (do
        (array_set char s i (array_get char ds j))
        (+= i 1)
        ))
    (return s)
    ))

;(fun generate (ds i r s mp mm B low_ok high_ok) (
;    (var d (bigmul (copy_bint r) B))
;    (= r (bigdiv d s))
;    (= mp (bigmul mp B))
;    (= mm (bigmul mm B))
;    (var rmp (bigadd (copy_bint r) mp))
;    (var tc1 (|| (&& low_ok (<= (bigcmp r mm) 0))
;                 (&& (! low_ok) (< (bigcmp r mm) 0))))
;    (var tc2 (|| (&& high_ok (>= (bigcmp rmp s) 0))
;                 (&& (! high_ok) (> (bigcmp rmp s) 0))))
;    (if (! tc1)
;        (if (! tc2)
;            (do
;                (array_set char ds i (+ (bint_digit d 0) '0'))
;                (return (generate ds (+ i 1) r s mp mm B low_ok high_ok))
;            )
;            (do
;                (array_set char ds i (+ (bint_digit d 0) '1'))
;                (return (+ i 1))
;            ))
;        (if (! tc2)
;            (do
;                (array_set char ds i (+ (bint_digit d 0) '0'))
;                (return (+ i 1))
;            )
;            (if (< (bigcmp (bigshl r 1) s) 0)
;                (do
;                    (array_set char ds i (+ (bint_digit d 0) '0'))
;                    (return (+ i 1))
;                )
;                (do
;                    (array_set char ds i (+ (bint_digit d 0) '1'))
;                    (return (+ i 1))
;                ))
;            ))
;    ))

(export fun float_zero () (
    (var float (allocate_float))
    (field_set float 0 0)
    (field_set float 1 0)
    (return float)
    ))

(export fun float_infinity () (
    (return (fdiv (itof 1) (itof 0)))
    ))

(fun float_uplus (f) (
    (return f)
    ))

(export fun float_uminus (f) (
    (return (f- (copy_float f)))
    ))

(fun float_hash (f) (
    (var w0 (field_get f 0))
    (var w1 (field_get f 1))
    (return (box (+ w1 (* 7 w0))))
    ))

(fun float_to_i (f) (
    (var w0 (field_get f 0))
    (var w1 (field_get f 1))
    (var sign 0)
    (if (& w1 0x80000000) (= sign 1))
    (var e (- (& (>> w1 20) 0x7ff) 1023))
    (= w1 (| (& w1 0xfffff) 0x100000))
    (if (< e 0) (return (box 0)))
    (var shift (- 52 e))
    (var b (allocate_bint 2))
    (bint_set_digit b 0 w0)
    (bint_set_digit b 1 w1)
    (field_set b 1 2)
    (if sign (bigneg b))
    (return (bint_shiftR b (box shift)))
    ))

(export fun uitof (n) (
    (if (>= n 0) (return (itof n)))
    (var f (allocate_float))
    (&= n 0x7fffffff)
    ; exp = 31 because n >= 2^31
    (field_set f 1 (| @(<< (+ 31 1023) 20) (>> n 11)))
    (field_set f 0 (<< n 21))
    (return f)
    ))

(fun int_to_f (n) (
    (return (itof (unbox n)))
    ))

(fun float_add (a b) (
    (= a (copy_float a))
    (return (fadd a b))
    ))
(fun float_sub (a b) (
    (= a (copy_float a))
    (return (fsub a b))
    ))
(fun float_mul (a b) (
    (= a (copy_float a))
    (return (fmul a b))
    ))
(fun float_div (a b) (
    (= a (copy_float a))
    (return (fdiv a b))
    ))
(fun float_lt (a b) ((if (f< a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_gt (a b) ((if (f> a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_le (a b) ((if (f<= a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_ge (a b) ((if (f>= a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_eq (a b) ((if (f== a b) (return @C_TRUE) (return @C_FALSE))))

(fun float_abs (n) (
    (return (fabs n))
    ))

(fun float_ipow (f n) (
    (var v (itof 1))
    (= n (unbox n))
    (var m 0x40000000)
    (while (! (& n m)) (>>= m 1))
    (while (> m 0) (do
        (fmul v v)
        (if (& n m) (fmul v f))
        (>>= m 1)
        ))
    (return v)
    ))

(export fun if_coerce (a b) ((return (list2 (itof (unbox a)) b))))
(export fun fi_coerce (a b) ((return (list2 a (itof (unbox b))))))

(export fun setup_float (global) (
    (set_slot global (to_sym "infinity") (float_infinity))

    (add_function1 global (to_sym "uplus") floatT float_uplus 0)
    (add_function1 global (to_sym "uminus") floatT float_uminus 0)
    (add_function1 global (to_sym "to_s") floatT float_to_s 0)
    (add_function1 global (to_sym "hash") floatT float_hash 0)
    (add_function1 global (to_sym "to_i") stringT float_to_i 0)
    (add_function1 global (to_sym "to_f") intT int_to_f 0)
    (add_function1 global (to_sym "to_f") floatT _id 0)
    
    (add_function2 global (to_sym "add") floatT floatT float_add 0)
    (add_function2 global (to_sym "sub") floatT floatT float_sub 0)
    (add_function2 global (to_sym "mul") floatT floatT float_mul 0)
    (add_function2 global (to_sym "div") floatT floatT float_div 0)
    (add_function2 global (to_sym "lt") floatT floatT float_lt 0)
    (add_function2 global (to_sym "gt") floatT floatT float_gt 0)
    (add_function2 global (to_sym "le") floatT floatT float_le 0)
    (add_function2 global (to_sym "ge") floatT floatT float_ge 0)
    (add_function2 global (to_sym "equal") floatT floatT float_eq 0)
    (add_function1 global (to_sym "abs") floatT float_abs 0)
    (add_function2 global (to_sym "pow") floatT intT float_ipow 0)

    (add_function2 global (to_sym "coerce") intT floatT if_coerce 0)
    (add_function2 global (to_sym "coerce") floatT intT fi_coerce 0)
    ))

   ))
