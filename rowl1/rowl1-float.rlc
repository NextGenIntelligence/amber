;
; rowl - 1st generation
; Copyright (C) 2012 nineties
;
; $Id: rowl1-float.rlc 2013-02-08 11:47:55 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(var FORMAT_KMIN -4)

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")
(import "rowl1-numeric")
(import "rowl1-bigint")

(extern object current_loc)

(export fun pp_float (ochan f) (
    (output_string ochan (float_to_s f))
    ))

; ==== utilities ===
(fun add (x y) (
    (if (&& (& x 1) (& y 1)) (return (int_add2 x y)))
    (return (bint_add x y))
    ))
(fun sub (x y) (
    (if (&& (& x 1) (& y 1)) (return (int_sub2 x y)))
    (return (bint_sub x y))
    ))
(fun mul (x y) (
    (if (&& (& x 1) (& y 1)) (return (int_mul2 x y)))
    (return (bint_mul x y))
    ))

(export fun float_sign (f) (
    (if (< (field_get f 0) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun float_is_zero (f) (
    (if (&& (== (& (field_get f 0) 0x7fffffff) 0)
            (== (field_get f 1) 0))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun float_positive (f) (
    (if (&& (! (float_sign f)) (! (float_is_zero f)))
        (return @TRUE)
        (return @FALSE)
        )
    ))

; ==== translate ascii-string to floating-point number ====
; Bellorphon-method
; (cf. William D Clinger, "How to Read Floating Point Numbers Accurately")

(var ten^9 (uint_to_bint 1000000000))

(export fun float_from_s (str) (
    ; "XXXX.YYYYeZZZZ" => f*10^e
    (var p 0)
    (var slen (strlen str))
    (var sign 0)
    (if (== (array_get char str 0) '-') (do
        (= sign 1)
        (+= p 1)
        ))
    (var f (box 0))
    (var e 0)

    (var mlen 0)
    (var ndigit 0)
    (while (< mlen slen) (do
        (var c (array_get char str mlen))
        (if (== c 'e') break)
        (if (&& (!= c '.') (|| (> ndigit 0) (&& (<= '1' c) (<= c '9')))) (+= ndigit 1))
        (+= mlen 1)
        ))

    (var mlen slen)
    (while (&& (> mlen 0) (!= (array_get char str (- mlen 1)) 'e')) (-= mlen 1))
    (if (== mlen 0)
        (= mlen slen)
        (-= mlen 1)
        )

    (var r (umod (- (- mlen p) 1) 9))
    (while (< p mlen) (do
        (var w 0)
        (while (> r 0) (do
            (var c (array_get char str p))
            (if (== c '.') (do
                (= e 0)
                (+= p 1)
                continue
                ))
            (if (|| (< c '0') (< '9' c))
                (throw (invalid_format current_loc (string str)))
                )
            (= w (+ (* 10 w) (- c '0')))
            (-= r 1)
            (+= p 1)
            (-= e 1)
            ))
        (if (!= f 1)
            (= f (mul f ten^9))
            )
        (= f (add f (box w)))
        (= r 9)
        ))
    (if (== (array_get char str p) 'e') (do
        (+= p 1)
        (var neg @FALSE)
        (if (== (array_get char str p) '-') (do (+= p 1) (= neg @TRUE)))
        (var d 0) 
        (while (< p slen) (do
            (var c (array_get char str p))
            (if (|| (< c '0') (< '9' c))
                (throw (invalid_format current_loc (string str)))
                )
            (= d (+ (* 10 d) (- c '0')))
            (+= p 1)
            ))
        (if neg (= d (- d)))
        (+= e d)
        ))

    (if (== f 1) (do (= ndigit 0) (= e 0)))
    
    (return (encode_float sign f ndigit e))
    ))

;; translate f*10^e to IEEE754 floating point
(var two^10 (bigshl (uint_to_bint 1) 10))
(var two^11 (bigshl (uint_to_bint 1) 11))
(var two^52 (bigshl (uint_to_bint 1) 52))
(var two^53 (bigshl (uint_to_bint 1) 53))
(var two^63 (bigshl (uint_to_bint 1) 63))
(var two^64 (bigshl (uint_to_bint 1) 64))

(fun encode_float (sign f n e) (
    (if (bint_is_zero f) (do
        (var float (allocate_float))
        (field_set float 0 0)
        (field_set float 1 0)
        (return float)
        ))

    (var shift 0)
    (if (>= (+ n e) 1)
        (= shift (- 56 (* 3 (+ n e))))
        (= shift (- 57 (* 4 (+ n e))))
        )

    (= f (bint_shiftL f (box shift)))

    ; here f has more than 53 bits (so, it is a bigint)
    (var rem 0)
    (if (> e 0) (do
        (var b (uint_to_bint 1))
        (while (> e 0) (do
            (= b (mul b (box 10)))
            (-= e 1)
            ))
        (= f (mul f b)) 
        )
    (if (< e 0) (do
        (var b (uint_to_bint 1))
        (while (< e 0) (do
            (= b (mul b (box 10)))
            (+= e 1)
            ))
        (var r (bigdiv f (to_bint b)))
        (if (! (bint_is_zero r)) (= rem 1))
        )))

    (var nd (bint_ndigits2 f))
    (var exp (- (- nd 1) shift))
    (var offs (- nd 53))

    (var w (bint_digit f 0))
    (var ulp (& (>> w offs) 1))
    (var G (& (>> w (- offs 1)) 1))
    (var R 0)
    (if (|| rem (& w (- (<< 1 offs) 1))) (= R 1))
    (= f (bint_shiftR f (box offs)))
    (if (&& G (|| ulp R))
        (= f (add f (box 1)))
        (if (== (bint_digit f 1) 0x00200000)
            (+= exp 1) ; carry
            )
        )

    (= w (bint_digit f 1))
    (= w (| (& w 0xfffff) (<< (& (+ exp 1023) 0x7ff) 20)))
    (if sign (= w (| w 0x80000000)))
    (bint_set_digit f 1 w)

    (var float (allocate_float))
    (field_set float 0 (bint_digit f 0))
    (field_set float 1 (bint_digit f 1))
    (return float)
    ))

; ==== translate floating-point number to ascii-string ====
; This implementation is base on folloing paper.
; Robert G. Burger: "Printing Floating-Point Numbers Quickly and Accurately"

(fun float_to_s (v) (
    (var s 0)
    (var f0 (field_get v 0))
    (var f1 (field_get v 1))
    (if (& f1 0x80000000) (do
        (= s 1)
        (= v (float_uminus v))
        ))
    (if (&& (! f0) (! f1)) (do
        (return (string "0.0"))
        ))
    (var e (- (& (>> f1 20) 0x7ff) 1023))
    (= f1 (& f1 0xfffff))
    
    (if (== e 1024)
        (if (&& (== f1 0) (== f0 0))
            (if s
                (return (string "-Infinity"))
                (return (string "Infinity"))
                )
            (return (string "NaN"))
            )
        )

    (var f (allocate_bint 2))
    (field_set f 1 2)
    (bint_set_digit f 0 f0)

    (if (== e -1023)
        (bint_set_digit f 1 f1)
        (bint_set_digit f 1 (| f1 (<< 1 20)))
        )
    (return (decode_float s f e))
    ))

; v: abs of input floating-point number.
; f: mantissa (bigint)
; e: exponent
(fun decode_float (sign f e) (
    (-= e 52)
    (var b (int_to_bint 1))
    (var B (int_to_bint 10))
    (var round_p (bint_even f))
    (if (>= e 0)
        (if (== (bint_eq f (bigshl (copy_bint b) 52)) @C_FALSE)
            (do
                (var be (bigshl (copy_bint b) e))
                (var fbe2 (bigshl (bigmul f be) 1))
                (return (scale sign fbe2 (int_to_bint 2) be be 0 B round_p round_p))
            )
            (do
                (var be (bigshl (copy_bint b) e))
                (var be1 (bigshl (copy_bint be) 1))
                (var fbe12 (bigshl (bigmul f be1) 1))
                (return (scale sign fbe12 (int_to_bint 4) be1 be 0 B round_p round_p))
            ))
        (if (|| (== e -1022) (== (bint_eq f (bigshl (copy_bint b) 52)) @C_FALSE))
            (return (scale sign (bigshl f 1) (bigshl b (- 1 e)) (int_to_bint 1) (int_to_bint 1) 0 B round_p round_p))
            (return (scale sign (bigshl f 2) (bigshl b (- 2 e)) (int_to_bint 2) (int_to_bint 1) 0 B round_p round_p))
            ))
    ))

(fun scale (sign r s mp mm k B low_ok high_ok) (
    (var rmp (bigadd (copy_bint r) mp))
    (if (|| (&& high_ok (>= (bigcmp rmp s) 0))
            (&& (! high_ok) (> (bigcmp rmp s) 0))) (do
        (return (scale sign r (bigmul s B) mp mm (+ k 1) B low_ok high_ok)))
        )
    (bigmul rmp B)
    (if (|| (&& high_ok (< (bigcmp rmp s) 0))
            (&& (! high_ok) (<= (bigcmp rmp s) 0)))
        (return (scale sign (bigmul r B) s (bigmul mp B) (bigmul mm B) (- k 1)
                    B low_ok high_ok)))

    ; the precision of IEEE 64-bit floating point number is
    ; less than or equal 16 digits in base 10.
    (var digits (allocate_carray 16))
    (var n (generate digits 0 r s mp mm B low_ok high_ok))

    (return (format_float sign k digits n))
    ))

; Format  0.d1 d2 ... dn 10^k to
; d1 d2 ..... dn . 0           (when n = k)
; d1 d2 ... dk . d(k+1) ... dn (when k > 0 and n > k)
; d1 . d2 ... dn e(k-1)        (when k > 0 and n < k) 
; 0.0 0 0 0 d1 ... dn          (when kmin < k <= 0)
; d1 . d2 ... dn e(k-1)        (when k <= kmin)
(fun format_float (sign k ds n) (
    (var len n)
    (if sign (+= len 1))
    (if (== n k) (do
        (var s (allocate_string (+ len n)))
        (var i 0)
        (if sign (do (array_set char s 0 '-') (+= i 1)))
        (for j 0 n (do
            (array_set char s i (array_get char ds j))
            (+= i 1)
            ))
        (array_set char s i '.')
        (array_set char s (+ i 1) '0')
        (return s)
        ))
    (if (&& (> k 0) (> n k))
        (do
            (var s (allocate_string (+ len 1)))
            (var i 0)
            (if sign (do (array_set char s 0 '-') (+= i 1)))
            (for j 0 n (do
                (if (== j k) (do
                    (array_set char s i '.')
                    (+= i 1)
                    ))
                (array_set char s i (array_get char ds j))
                (+= i 1)
                ))
            (return s)
        )
    (if (|| (&& (> k 0) (< n k)) (<= k @FORMAT_KMIN))
        (do
            (var s (allocate_string (+ len 8)))
            (var i 0)
            (if sign (do (array_set char s 0 '-') (+= i 1)))
            (array_set char s i (array_get char ds 0))
            (array_set char s (+ i 1) '.')
            (+= i 2)
            (if (== n 1)
                (do (array_set char s i '0') (+= i 1))
                (for j 1 n (do
                    (array_set char s i (array_get char ds j))
                    (+= i 1)
                    ))
                )
            (array_set char s i 'e')
            (+= i 1)
            
            (-= k 1)
            (if (< k 0) (do
                (array_set char s i '-')
                (+= i 1)
                (= k (- k))))
            (var d 1000)
            (while (== (/ k d) 0) (/= d 10))
            (while (> k 0) (do
                (array_set char s i (+ (/ k d) '0'))
                (%= k d)
                (/= d 10)
                (+= i 1)
                ))
            (return s)
        )))
    (var s (allocate_string (+ (+ len (- k)) 2)))
    (var i 0)
    (if sign (do (array_set char s 0 '-') (+= i 1)))
    (array_set char s i '0')
    (array_set char s (+ i 1) '.')
    (+= i 2)
    (= k (- k))
    (while (> k 0) (do
        (array_set char s i '0')
        (+= i 1)
        (-= k 1)
        ))
    (for j 0 n (do
        (array_set char s i (array_get char ds j))
        (+= i 1)
        ))
    (return s)
    ))

(fun generate (ds i r s mp mm B low_ok high_ok) (
    (var d (bigmul (copy_bint r) B))
    (= r (bigdiv d s))
    (= mp (bigmul mp B))
    (= mm (bigmul mm B))
    (var rmp (bigadd (copy_bint r) mp))
    (var tc1 (|| (&& low_ok (<= (bigcmp r mm) 0))
                 (&& (! low_ok) (< (bigcmp r mm) 0))))
    (var tc2 (|| (&& high_ok (>= (bigcmp rmp s) 0))
                 (&& (! high_ok) (> (bigcmp rmp s) 0))))
    (if (! tc1)
        (if (! tc2)
            (do
                (array_set char ds i (+ (bint_digit d 0) '0'))
                (return (generate ds (+ i 1) r s mp mm B low_ok high_ok))
            )
            (do
                (array_set char ds i (+ (bint_digit d 0) '1'))
                (return (+ i 1))
            ))
        (if (! tc2)
            (do
                (array_set char ds i (+ (bint_digit d 0) '0'))
                (return (+ i 1))
            )
            (if (< (bigcmp (bigshl r 1) s) 0)
                (do
                    (array_set char ds i (+ (bint_digit d 0) '0'))
                    (return (+ i 1))
                )
                (do
                    (array_set char ds i (+ (bint_digit d 0) '1'))
                    (return (+ i 1))
                ))
            ))
    ))

(fun float_uplus (f) (
    (return f)
    ))

(fun float_uminus (f) (
    (return (f- (copy_float f)))
    ))

(fun float_hash (f) (
    (var w0 (field_get f 0))
    (var w1 (field_get f 1))
    (return (box (+ w1 (* 7 w0))))
    ))

(fun float_to_i (f) (
    (var w0 (field_get f 0))
    (var w1 (field_get f 1))
    (var sign 0)
    (if (& w1 0x80000000) (= sign 1))
    (var e (- (& (>> w1 20) 0x7ff) 1023))
    (= w1 (| (& w1 0xfffff) 0x100000))
    (if (< e 0) (return (box 0)))
    (var shift (- 52 e))
    (var b (allocate_bint 2))
    (bint_set_digit b 0 w0)
    (bint_set_digit b 1 w1)
    (field_set b 1 2)
    (if sign (bigneg b))
    (return (bint_shiftR b (box shift)))
    ))

(fun int_to_f (n) (
    (return (itof (unbox n)))
    ))

(fun float_add (a b) (
    (= a (copy_float a))
    (return (fadd a b))
    ))
(fun float_sub (a b) (
    (= a (copy_float a))
    (return (fsub a b))
    ))
(fun float_mul (a b) (
    (= a (copy_float a))
    (return (fmul a b))
    ))
(fun float_div (a b) (
    (= a (copy_float a))
    (return (fdiv a b))
    ))
(fun float_lt (a b) ((if (f< a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_gt (a b) ((if (f> a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_le (a b) ((if (f<= a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_ge (a b) ((if (f>= a b) (return @C_TRUE) (return @C_FALSE))))
(fun float_eq (a b) ((if (f== a b) (return @C_TRUE) (return @C_FALSE))))

(fun float_abs (n) (
    (return (fabs n))
    ))

(fun float_ipow (f n) (
    (var v (itof 1))
    (= n (unbox n))
    (var m 0x40000000)
    (while (! (& n m)) (>>= m 1))
    (while (> m 0) (do
        (fmul v v)
        (if (& n m) (fmul v f))
        (>>= m 1)
        ))
    (return v)
    ))

(fun if_coerce (a b) ((return (list2 (itof (unbox a)) b))))
(fun fi_coerce (a b) ((return (list2 a (itof (unbox b))))))

(export fun setup_float (std) (
    (add_function1 std (to_sym "uplus") floatT float_uplus 0)
    (add_function1 std (to_sym "uminus") floatT float_uminus 0)
    (add_function1 std (to_sym "to_s") floatT float_to_s 0)
    (add_function1 std (to_sym "hash") floatT float_hash 0)
    (add_function1 std (to_sym "to_i") stringT float_to_i 0)
    (add_function1 std (to_sym "to_f") intT int_to_f 0)
    
    (add_function2 std (to_sym "add") floatT floatT float_add 0)
    (add_function2 std (to_sym "sub") floatT floatT float_sub 0)
    (add_function2 std (to_sym "mul") floatT floatT float_mul 0)
    (add_function2 std (to_sym "div") floatT floatT float_div 0)
    (add_function2 std (to_sym "lt") floatT floatT float_lt 0)
    (add_function2 std (to_sym "gt") floatT floatT float_gt 0)
    (add_function2 std (to_sym "le") floatT floatT float_le 0)
    (add_function2 std (to_sym "ge") floatT floatT float_ge 0)
    (add_function2 std (to_sym "equal") floatT floatT float_eq 0)
    (add_function1 std (to_sym "abs") floatT float_abs 0)
    (add_function2 std (to_sym "pow") floatT intT float_ipow 0)

    (add_function2 std (to_sym "coerce") intT floatT if_coerce 0)
    (add_function2 std (to_sym "coerce") floatT intT fi_coerce 0)
    ))

   ))
