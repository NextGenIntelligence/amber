;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-integer.rlc 2014-03-11 08:37:34 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-compile")
(import "rowl1-util")
(import "rowl1-error")
(import "rowl1-bigint")
(import "rowl1-float")

(extern object global)
(extern fun tuple2)

(fun int_uplus (x) (
    (return x)
    ))

(fun int_uminus (x) (
    (return (+ (- x) 2))
    ))

(fun int_add (x y) (
    (return (- (+ x y) 1))
    ))

(fun int_sub (x y) (
    (return (+ (- x y) 1))
    ))

(fun int_mul (x y) (
    (return (box (* (unbox x) (unbox y))))
    ))

(fun int_pow (x y) (
    (var v 1)
    (= x (unbox x))
    (= y (unbox y))
    (if (< y 0) (return (fpow (itof x) (itof y))))
    (var m 0x40000000)
    (while (! (& y m)) (>>= m 1))
    (while (> m 0) (do
        (*= v v)
        (if (& y m) (*= v x))
        (>>= m 1)
        ))
    (return (box v))
    ))

; compute x^y mod z
(fun int_powmod (x y z) (
    (var v 1)
    (= x (unbox x))
    (= y (unbox y))
    (= z (unbox z))
    (if (< y 0) (throw (invalid_argument (string "Negative exponent") (box y))))
    (if (< z 0) (throw (invalid_argument (string "Negative modulus") (box z))))
    (var m 0x40000000)
    (while (! (& y m)) (>>= m 1))
    (while (> m 0) (do
        (*= v v)
        (if (& y m) (*= v x))
        (%= v z)
        (>>= m 1)
        ))
    (return (box v))
    ))

(fun nonzero_check (x) (
    (if (== x 1) ; box(0) == 1
        (throw (division_by_zero))
        )
    ))

(fun int_quo (x y) (
    (nonzero_check y)
    (return (fdiv (itof (unbox x)) (itof (unbox y))))
    ))

(fun int_quo2 (x y) (
    (nonzero_check y)
    (return (fdiv (copy_float x) (itof (unbox y))))
    ))

(fun int_div (x y) (
    (nonzero_check y)
    (if (> y 0)
        (return (box (/ (unbox x) (unbox y))))
        (return (box (- (/ (unbox x) (- (unbox y))))))
        )
    ))

(fun int_mod (x y) (
    (nonzero_check y)
    (if (> y 0)
        (return (box (% (unbox x) (unbox y))))
        (return (box (% (unbox x) (- (unbox y)))))
        )
    ))

(fun int_divmod (x y) (
    (nonzero_check y)
    (= x (unbox x))
    (= y (unbox y))
    (return (tuple2 (box (/ x y)) (box (% x y))))
    ))

(fun int_shiftL (x y) (
    (if (< y 0) (return (int_shiftR x (+ (- y) 2))))
    (= y (unbox y))
    (if (>= y 32) (return (box 0)))
    (= x (unbox x))
    (if (> x 0)
        (return (box (<< x y)))
        (return (box (- (<< (- x) y))))
        )
    ))

(fun int_shiftR (x y) (
    (if (< y 0) (return (int_shiftL x (+ (- y) 2))))
    (= y (unbox y))
    (if (>= y 32) (return (box 0)))
    (= x (unbox x))
    (if (> x 0)
        (return (box (>> x y)))
        (return (box (- (>> (- x) y))))
        )
    ))

(fun int_compare (x y) (
    (if (< x y) (return (box -1))
    (if (== x y) (return (box 0))
        (return (box 1))
        ))
    ))
(fun int_lt (x y) ((if (< x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_gt (x y) ((if (> x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_le (x y) ((if (<= x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_ge (x y) ((if (>= x y) (return @C_TRUE) (return @C_FALSE))))

(fun int_abs (n) (
    (if (> n 0)
        (return n)
        (return (+ (- n) 2))
        )
    ))

(export fun int_to_str (n base prec prefix) (
    (= base (unbox base))
    (if (|| (< base 2) (> base 36))
        (throw (invalid_argument (string "Invalid radix") (box base)))
        )
    (if (!= prec @C_NIL)
        (do
            (if (|| (!= (node_type prec) @IntE) (< (unbox prec) 0))
                (throw (invalid_argument (string "Invalid precision") prec))
                )
            (= prec (unbox prec))
        )
        (= prec 0)
        )
    (return (itos (unbox n) base prec (!= prefix @C_FALSE)))
    ))

(export fun int_hash (n) (
    (return (box (hashnext 0 n)))
    ))

(extern fun is_0_9)
(fun str_to_int (s) (
    (var sign 1)
    (var big_p @FALSE)
    (var n (strlen s))
    (var i 0)
    (var c (array_get char s i))
    (if (== c '-') (do
        (= sign -1)
        (+= i 1)
        (= c (array_get char s i))
        ))
    (var v 0)
    (while (is_0_9 c) (do
        (= c (- c '0'))
        (if (> v (/ (- @INTEGER_MAX c) 10))
            (= big_p @TRUE)
            )
        (= v (+ (* v 10) c))
        (+= i 1)
        (= c (array_get char s i))
        ))
    (if (!= i n) (goto str_to_int_error))
    (if big_p
        (return (parse_bint s))
        (return (box (* sign v)))
        )
    (label str_to_int_error)
    (throw (value_error (string "Invalid integer format") s))
    ))

(fun int_lnot (a) (
    (return (| 1 (~ a)))
    ))

(fun int_land (a b) (
    (return (| 1 (& a b)))
    ))
(fun int_lor (a b) (
    (return (| 1 (| a b)))
    ))
(fun int_lxor (a b) (
    (return (| 1 (^ a b)))
    ))
(fun int_lshift (a m) (
    (= m (unbox m))
    (if (< m 0) (throw (out_of_domain (to_sym "lshift") m)))
    (return (box (<< (unbox a) m)))
    ))
(fun int_rshift (a m) (
    (= m (unbox m))
    (if (< m 0) (throw (out_of_domain (to_sym "rshift") m)))
    (return (box (>> (unbox a) m)))
    ))
(fun int_logic_rshift (a m) (
    (= m (unbox m))
    (if (< m 0) (throw (out_of_domain (to_sym "logic_rshift") m)))
    (return (box (shr a (+ m 1))))
    ))

(export fun setup_numeric (mod) (
    (add_function1 mod (to_sym "int_uplus") intT int_uplus 0)
    (add_function1 mod (to_sym "int_uminus") intT int_uminus 0)
    (add_function2 mod (to_sym "int_add") intT intT int_add 0)
    (add_function2 mod (to_sym "int_sub") intT intT int_sub 0)
    (add_function2 mod (to_sym "int_mul") intT intT int_mul 0)
    (add_function2 mod (to_sym "int_quo") intT intT int_quo 0)
    (add_function2 mod (to_sym "int_quo") floatT intT int_quo2 0)
    (add_function2 mod (to_sym "int_div") intT intT int_div 0)
    (add_function2 mod (to_sym "int_mod") intT intT int_mod 0)
    (add_function2 mod (to_sym "int_divmod") intT intT int_divmod 0)
    (add_function2 mod (to_sym "int_pow") intT intT int_pow 0)
    (add_function3 mod (to_sym "int_powmod") intT intT intT int_powmod 0)
    (add_function2 mod (to_sym "int_compare") intT intT int_compare 0)
    (add_function2 mod (to_sym "int_less_than?") intT intT int_lt 0)
    (add_function2 mod (to_sym "int_greater_than?") intT intT int_gt 0)
    (add_function2 mod (to_sym "int_less_equal?") intT intT int_le 0)
    (add_function2 mod (to_sym "int_greater_equal?") intT intT int_ge 0)
    (add_function2 mod (to_sym "int_shiftL") intT intT int_shiftL 0)
    (add_function2 mod (to_sym "int_shiftR") intT intT int_shiftR 0)

    (add_function1 mod (to_sym "int_abs") intT int_abs 0)
    (add_function3 mod (to_sym "int_to_string") intT intT DontCare int_to_str 0)
    (set_slot mod (to_sym "INTEGER_WIDTH") (box @FIXNUM_WIDTH))
    (set_slot mod (to_sym "INTEGER_MIN") (box @FIXNUM_MIN))
    (set_slot mod (to_sym "INTEGER_MAX") (box @FIXNUM_MAX))

    (add_function1 mod (to_sym "string_to_int") stringT str_to_int 0)

    (add_function1 mod (to_sym "int_lnot") intT int_lnot 0)
    (add_function2 mod (to_sym "int_land") intT intT int_land 0)
    (add_function2 mod (to_sym "int_lor") intT intT int_lor 0)
    (add_function2 mod (to_sym "int_lxor") intT intT int_lxor 0)
    (add_function2 mod (to_sym "int_lshift") intT intT int_lshift 0)
    (add_function2 mod (to_sym "int_rshift") intT intT int_rshift 0)
    (add_function2 mod (to_sym "int_logic_rshift") intT intT int_logic_rshift 0)
    ))

    ))
