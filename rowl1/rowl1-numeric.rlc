;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-numeric.rlc 2013-08-19 20:03:12 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-compile")
(import "rowl1-util")
(import "rowl1-error")
(import "rowl1-bigint")
(import "rowl1-float")

(extern object current_loc)
(extern object global)

(var coerce (to_sym "coerce"))
(export fun do_coerce (a b) (
    (var r (runcode (lookup_func global coerce) a b))
    (if (== r @C_UNDEF) (return r))
    (if (|| (!= (node_type r) @ListE) (!= (list_len r) 2)) (do
        (throw (exception current_loc (string "coerce must returns [a, b]")))
        ))
    (return r)
    ))


(export fun binary_coerce (sym a b) (
    (var r (do_coerce a b))
    (if (== r @C_UNDEF)
        (throw (make_object5 Exception current_loc
            (string "Unknown binary operation")
            (make_object1 (to_sym "method") sym)
            (make_object1 (to_sym "lhs") a)
            (make_object1 (to_sym "rhs") b)
            ))
        )
    (return (runcode (lookup_func global sym) (car r) (cadr r)))
    ))

(export fun do_coerce_internal (a b) (
    (var lty (node_type a))
    (var rty (node_type b))
    (if (== lty rty) (return (list2 a b)))
    (if (== lty @IntE) 
        (if (== rty @BigIntE) (return (ib_coerce a b))
        (if (== rty @FloatE)  (return (if_coerce a b))
            (return @C_UNDEF)
            ))
    (if (== lty @BigIntE)
        (if (== rty @IntE)   (return (bi_coerce a b))
        (if (== rty @FloatE) (return (bf_coerce a b))
            (return @C_UNDEF)
            ))
    (if (== lty @FloatE)
        (if (== rty @IntE)    (return (fi_coerce a b))
        (if (== rty @BigIntE) (return (fb_coerce a b))
            (return @C_UNDEF)
            )))))
    (return @C_UNDEF)
    ))

(fun num_add (a b) ((return (binary_coerce (to_sym "add") a b))))
(fun num_sub (a b) ((return (binary_coerce (to_sym "sub") a b))))
(fun num_mul (a b) ((return (binary_coerce (to_sym "mul") a b))))
(fun num_div (a b) ((return (binary_coerce (to_sym "div") a b))))
(fun num_mod (a b) ((return (binary_coerce (to_sym "mod") a b))))
(fun num_lt (a b) ((return (binary_coerce (to_sym "lt") a b))))
(fun num_gt (a b) ((return (binary_coerce (to_sym "gt") a b))))
(fun num_le (a b) ((return (binary_coerce (to_sym "le") a b))))
(fun num_ge (a b) ((return (binary_coerce (to_sym "ge") a b))))

(fun int_uplus (x) (
    (return x)
    ))

(fun int_uminus (x) (
    (return (+ (- x) 2))
    ))

(fun int_add (x y) (
    (return (- (+ x y) 1))
    ))

(fun int_sub (x y) (
    (return (+ (- x y) 1))
    ))

(fun int_mul (x y) (
    (return (box (* (unbox x) (unbox y))))
    ))

(fun int_pow (x y) (
    (var v 1)
    (= x (unbox x))
    (= y (unbox y))
    (if (< y 0) (throw (invalid_argument current_loc
        (string "negative exponent") (box y))))
    (var m 0x40000000)
    (while (! (& y m)) (>>= m 1))
    (while (> m 0) (do
        (*= v v)
        (if (& y m) (*= v x))
        (>>= m 1)
        ))
    (return (box v))
    ))

(fun nonzero_check (x) (
    (if (== x 1) ; box(0) == 1
        (throw (division_by_zero current_loc))
        )
    ))

(fun int_div (x y) (
    (nonzero_check y)
    (return (box (/ (unbox x) (unbox y))))
    ))

(fun int_mod (x y) (
    (nonzero_check y)
    (return (box (% (unbox x) (unbox y))))
    ))

(fun int_shiftL (x y) (
    (if (< y 0) (return (int_shiftR x (+ (- y) 2))))
    (= y (unbox y))
    (if (>= y 32) (return (box 0)))
    (= x (unbox x))
    (if (> x 0)
        (return (box (<< x y)))
        (return (box (- (<< (- x) y))))
        )
    ))

(fun int_shiftR (x y) (
    (if (< y 0) (return (int_shiftL x (+ (- y) 2))))
    (= y (unbox y))
    (if (>= y 32) (return (box 0)))
    (= x (unbox x))
    (if (> x 0)
        (return (box (>> x y)))
        (return (box (- (>> (- x) y))))
        )
    ))

(fun int_lt (x y) ((if (< x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_gt (x y) ((if (> x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_le (x y) ((if (<= x y) (return @C_TRUE) (return @C_FALSE))))
(fun int_ge (x y) ((if (>= x y) (return @C_TRUE) (return @C_FALSE))))

(fun int_abs (n) (
    (if (> n 0)
        (return n)
        (return (+ (- n) 2))
        )
    ))

(export fun int_to_s (n) (
    (return (itos (unbox n)))
    ))

(fun int_hash (n) (
    (return n)
    ))

(fun int_times (n f) (
    (var code (get_bytecode f))
    (for i 0 (unbox n) (do
        (runcode code (box i))
        ))
    (return @C_NIL)
    ))

(export fun setup_numeric (global) (
    ; default implementations using coerce
    (add_function2 global (to_sym "add") DontCare DontCare num_add 0) 
    (add_function2 global (to_sym "sub") DontCare DontCare num_sub 0)
    (add_function2 global (to_sym "mul") DontCare DontCare num_mul 0)
    (add_function2 global (to_sym "div") DontCare DontCare num_div 0)
    (add_function2 global (to_sym "mod") DontCare DontCare num_mod 0)
    (add_function2 global (to_sym "lt") DontCare DontCare num_lt 0)
    (add_function2 global (to_sym "gt") DontCare DontCare num_gt 0)
    (add_function2 global (to_sym "le") DontCare DontCare num_le 0)
    (add_function2 global (to_sym "ge") DontCare DontCare num_ge 0)

    ; integer arithmetic
    (add_function1 global (to_sym "uplus") intT int_uplus 0)
    (add_function1 global (to_sym "uminus") intT int_uminus 0)
    (add_function2 global (to_sym "add") intT intT int_add 0)
    (add_function2 global (to_sym "sub") intT intT int_sub 0)
    (add_function2 global (to_sym "mul") intT intT int_mul 0)
    (add_function2 global (to_sym "pow") intT intT int_pow 0)
    (add_function2 global (to_sym "div") intT intT int_div 0)
    (add_function2 global (to_sym "mod") intT intT int_mod 0)
    (add_function2 global (to_sym "shiftL") intT intT int_shiftL 0)
    (add_function2 global (to_sym "shiftR") intT intT int_shiftR 0)
    (add_function2 global (to_sym "lt") intT intT int_lt 0)
    (add_function2 global (to_sym "gt") intT intT int_gt 0)
    (add_function2 global (to_sym "le") intT intT int_le 0)
    (add_function2 global (to_sym "ge") intT intT int_ge 0)
    (add_function1 global (to_sym "abs") intT int_abs 0)
    (add_function1 global (to_sym "to_s") intT int_to_s 0)
    (add_function1 global (to_sym "hash") intT int_hash 0)

    (add_function2 global (to_sym "times") intT funT int_times 0) 

    (set_slot global (to_sym "INTEGER_MIN") (box @FIXNUM_MIN))
    (set_slot global (to_sym "INTEGER_MAX") (box @FIXNUM_MAX))
    ))

    ))
