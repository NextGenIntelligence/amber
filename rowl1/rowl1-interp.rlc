;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2014-01-22 23:48:44 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-error")
(import "rowl1-object")
(import "rowl1-symtable")
(import "rowl1-compile")
(import "rowl1-packrat")
(import "rowl1-pprint")

(export var global null)
(export var variables null)
(export var current_loc null)

(export fun set_loc (loc) (
    (= current_loc loc)
    (set_slot global (to_sym "LOCATION") loc)
    ))

(export fun eval_shell () (
    (set_shell_mode)
    (try
        (return (eval_main "amber" stdin 0 0))
        (catch e (do
            (output_string stderr "Uncaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(export fun eval_file (path argc argv) (
    (var r 0)
    (var ichan (open_in path))
    (try
        (= r (eval_main path ichan argc argv))
        (catch e (do
            (output_string stderr "Unaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (= r 1)
        )))
    (close_in ichan)
    (return r)
    ))

(fun eval_main (file ichan argc argv) (
    (= current_loc no_loc)
    (= global (make_object1 Module Amber))
    (= variables (make_symtable 10))
    (set_slot global Amber global)
    (set_slot global Syntax (make_object1 Module Syntax))

    (setup_argv argc argv)
    (setup_globals)
    (setup_builtin_compilers)
    (init_lib)
    (init_parser_funcs (get_slot global Syntax))
    (set_loc no_loc)

    (add_import_dir "/usr/lib/amber")
    (import_lib (list1 (string "Syntax")))

    ;(import_lib "amber/syntax.ab")
    ;(import_lib "std/string.ab")
    ;(import_lib "std/numeric.ab")
    ;(import_lib "std/format.ab")
    ;(import_lib "std/list.ab")
    ;(import_lib "std/array.ab")
    ;(import_lib "std/table.ab")
    ;(import_lib "std/io/io.ab")

    (add_import_dir (get_directory file))
    (add_import_dir (get_env "PWD"))

    (pre_import_lib)

    (var p (make_parser file ichan))

    (if (in_shell_mode)
        (interpret_shell p)
        (do
            (var fd (open "."))
            (var dir (get_directory file))
            (chdir dir)
            (interpret p)
            (fchdir fd)
        )
        )
    (eval_exit @C_NIL)

    (return 0)
    ))

(fun eval (expr) (
    (return (runcode (lookup_func global Eval) expr))
    ))

(fun rewrite (expr) (
    (var new_expr (runcode (lookup_func (get_slot global Syntax) Rewrite) expr))
    (if (!= new_expr expr) (return (rewrite new_expr)))
    (= expr new_expr)
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (rewrite_qquote (node_arg expr 0) 0))
        (return expr)
        ))

    ; Don't rewrite patterns but rewrite guard expressions
    (if (== hd Define) (do
        (var lhs (node_arg expr 0))
        (if (== (node_head lhs) Apply) (do
            (var guard (node_arg lhs 1))
            (if (== (node_head guard) When)
                (node_arg_set guard 1 (rewrite (node_arg guard 1)))
                )
            ))
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (node_arg expr 0))
        (if (== (node_bhead lhs) When)
            (node_arg_set lhs 1 (rewrite (node_arg lhs 1)))
            )
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))

    (for i 0 (node_size expr) (do
        (node_arg_set expr i (rewrite (node_arg expr i)))
        ))
    (return expr)
    ))

(fun rewrite_qquote (expr level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite_qquote (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0)
            (node_arg_set expr 0 (rewrite (node_arg expr 0)))
            (node_arg_set expr 0
                (rewrite_qquote (node_arg expr 0) (- level 1)))
            )
        (return expr)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))

    (for i 0 (node_size expr)
        (node_arg_set expr i
            (rewrite_qquote (node_arg expr i) level))
        )
    (return expr)
    ))

(fun interpret (p) (
    (while 1 (do
        (parse_toplevel p)
        (if (! (parse_success p)) (do
            (if (end_of_file p) break)
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))
        (eval (parsed_token p))
        ))
    (= current_loc no_loc)
    ))

(extern fun ary_new)
(extern fun ary_store)
(extern fun ary_push)
(fun interpret_shell (p) (
    (var outputs (ary_new))
    (import_lib (list2 (string "Syntax") (string "Shell")))
    (set_slot global (to_sym "shell_outputs") outputs)
    (ary_push outputs @C_UNDEF)
    (while 1 (do
        (try 
            (while 1 (do
                (parse_shell p)
                (if (! (parse_success p)) (do
                    (output_syntax_error (get_loc p) (parser_error p))
                    (flush_parser p @TRUE)
                    continue
                    ))
                (var ret (eval (parsed_token p)))
                (print_result ret)
                (ary_store outputs (box 0) ret)
                (ary_push outputs ret)
                (increment_line p)
                ))
        (catch e (do
            (output_string stderr "Error: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (flush_parser p @TRUE)
        )))))
    ))

(fun print_result (val) (
    (output_string stdout "=> ")
    (pprint stdout val)
    (output_char stdout '\n')
    ))

(fun default_eval (expr) (
    (return (runcode (compile_main (rewrite expr))))
    ))

(fun eval_located (expr) (
    (set_loc (node_arg expr 0))
    (return (eval (node_arg expr 1)))
    ))

(fun rewrite_donothing (expr) ((return expr)))

(fun rewrite_located (expr) (
    (node_arg_set expr 1 (rewrite (node_arg expr 1)))
    (return expr)
    ))

(fun eval_define_syntax (expr) (
    (var lhs (node_arg expr 0))
    (var elm (node_arg expr 1))
    (eval (compile_define_syntax lhs elm))
    (return @C_NIL)
    ))

(fun eval_reserve_symbol (expr) (
    (for i 0 (node_size expr)
        (add_reserve_symbol (node_arg expr i))
        )
    (return @C_NIL)
    ))

(fun eval_seq (expr) (
    (var stmts (node_arg expr 0))
    (var v @C_NIL)
    (while stmts (do
        (= v (eval (car stmts)))
        (= stmts (cdr stmts))
        ))
    (return v)
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(fun exit_ (status) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit (unbox status))
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return @C_NIL)
    ))

(export fun enter_module (sym) (
    (var mod (get_slot_norec global sym))
    (if (== mod @C_UNDEF)
        (= mod (make_object1 Module sym))
        )
    (if (== mod global)
        (throw (make_object3 Exception current_loc (string "recursive dependency detected") mod))
        )
    (if (!= (node_bhead mod) Module)
        (throw (type_error current_loc (string "Module") mod))
        )
    (set_slot mod proto global)
    (set_slot global sym mod)
    (= global mod)
    (return global)
    ))

(export fun exit_module () (
    (var mod (get_slot global proto))
    (if (!= (node_bhead mod) Module)
        (throw (type_error current_loc (string "Module") mod))
        )
    (= global mod)
    (return global)
    ))

(var import_dirs null)
(var imported_files null)

; XXX: fix this
(fun add_import_dir (path) (
    (if (!= (array_get char path 0) '/')
        (= path (strcat (strcat (get_env "PWD") "/") path))
        )
    
    (= import_dirs (cons path import_dirs))
    ))

(fun pop_import_dir () (
    (= import_dirs (cdr import_dirs))
    ))

(fun add_imported_file (path) (
    ; XXX: fixme. canonicalize the `path'
    (= imported_files (cons (string path) imported_files))
    ))

(fun is_already_imported (path) (
    (var list imported_files)
    (while list (do
        (if (streq path (car list))
            (return @TRUE)
            )
        (= list (cdr list))
        ))
    (return @FALSE)
    ))

(fun import_lib (list) (
    (return (import_lib_rec list @TRUE))
    ))

(fun import_lib_rec (list top) (
    (var dirs (list1 (string ".")))
    (if top (= dirs (list_append dirs import_dirs)))
    (if (cdr list)
        (do
            ; ;; import A.B...
            ; change working directory to A then import B...
            (var dir (car list))
            (while dirs (do
                (var fullpath (join (list3 (car dirs) (string "/") dir)))
                (if (file_exists fullpath) (do
                    (var fd (open "."))
                    (chdir fullpath)
                    (var mod_sym (to_sym dir))
                    (enter_module mod_sym)
                    (var r (import_lib_rec (cdr list) @FALSE))
                    (exit_module)
                    (fchdir fd)
                    (set_loc no_loc)
                    (return r)
                    ))
                (= dirs (cdr dirs))
                ))
        )
        (do
            (var file (strcat (car list) ".ab"))
            (while dirs (do
                (var fullpath (join (list3 (car dirs) (string "/") file)))
                (if (file_exists fullpath) (do
                    (var mod_sym (to_sym (car list)))
                    (var ichan (open_in fullpath))
                    (var fd (open "."))
                    (chdir (car dirs))

                    (enter_module mod_sym)

                    (var p (make_parser fullpath ichan))
                    (set_loc (get_loc p))

                    (var save_shell_mode_p (in_shell_mode))
                    (unset_shell_mode)
                    (interpret p)
                    (if save_shell_mode_p (set_shell_mode))

                    (exit_module)
                    (fchdir fd)
                    (close_in ichan)
                    (set_loc no_loc)
                    (return @C_TRUE)
                    ))
                (= dirs (cdr dirs))
                ))
        ))
        (throw (not_found current_loc (car list)))
    ))

;(fun import_lib (path) (
;    (= path (add_extension ".ab" path))
;    (var dir import_dirs)
;    (while dir (do
;        (var fullpath (build_path (car dir) path ""))
;        (if (file_exists fullpath) (do
;            (if (is_already_imported fullpath)
;                (return @C_FALSE)
;                )
;            (add_imported_file fullpath)
;
;            (var ichan (open_in fullpath))
;            (var fd (open "."))
;            (var dir (get_directory fullpath))
;            (chdir dir)
;            (add_import_dir dir)
;
;            (var p (make_parser fullpath ichan))
;            (set_loc (get_loc p))
;
;            (var save_shell_mode_p (in_shell_mode))
;            (unset_shell_mode)
;            (interpret p)
;            (if save_shell_mode_p (set_shell_mode))
;
;            (pop_import_dir)
;
;            (fchdir fd)
;            (close_in ichan)
;
;            (set_loc no_loc)
;            (return @C_TRUE)
;            ))
;        (= dir (cdr dir))
;        ))
;    (throw (not_found current_loc (string path)))
;    ))

(var pre_imports null)
(export fun set_pre_imports (sym) (
    (= pre_imports (string sym))
    ))

(fun pre_import_lib () (
    (if (! pre_imports) return)
    (import_lib pre_imports)
    ))

(fun eval_import (expr) (
    (var path (node_arg expr 0))
    (if (== (node_bhead path) List) (do
        (var syms path)
        (= path (string ""))
        (while syms (do
            (= path (strcat path (symbol_name (car syms))))
            (= syms (cdr syms))
            (if syms (= path (strcat path "/")))
            ))
        (= path (add_extension ".ab" path))
        ))
    (return (import_lib path))
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (set_slot global (to_sym "ARGV") ARGV)
    (if (== argc 0) return)
    (for i 1 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(export fun prompt_string () (
    (var v (get_slot global (to_sym "PROMPT")))
    (if (!= (node_type v) @StringE)
        (return (string "<invalid prompt string>"))
        )
    (return v)
    ))

(fun load_ (path) (
    (var dir import_dirs)
    (while dir (do
        (var fullpath (build_path (car dir) path ""))
        (if (file_exists fullpath) (do
            (var ichan (open_in fullpath))
            (var fd (open "."))
            (var dir (get_directory fullpath))
            (chdir dir)
            (add_import_dir dir)

            (var p (make_parser fullpath ichan))
            (set_loc (get_loc p))

            (var save_shell_mode_p (in_shell_mode))
            (unset_shell_mode)
            (interpret p)
            (if save_shell_mode_p (set_shell_mode))

            (pop_import_dir)

            (fchdir fd)
            (close_in ichan)

            (set_loc no_loc)
            (return @C_NIL)
            ))
        (= dir (cdr dir))
        ))
    (throw (not_found current_loc (string path)))
    ))

(fun setup_globals () (
    (set_slot global (to_sym "LOCATION") current_loc)
    (set_slot global (to_sym "PROMPT") (string "amber"))

    (if (in_shell_mode)
        (set_slot global (to_sym "shell_mode") @C_TRUE)
        (set_slot global (to_sym "shell_mode") @C_FALSE)
        )
    (var syntax (get_slot global Syntax)) 
    (add_function1 syntax Rewrite DontCare rewrite_donothing 0)
    (add_function1 syntax Rewrite (domainP Located) rewrite_located 0)
    (add_function1 global Eval DontCare default_eval 0)
    (add_function1 global Eval (domainP Located) eval_located 0)
    (add_function1 global Eval (make_object1 Import listT) eval_import 0)
    (add_function1 global Eval (make_object1 Import stringT) eval_import 0)

    (add_function1 global Eval (make_object1 Seq listT) eval_seq 0)

    (add_function1 global Eval (make_object2 DefSyntax DontCare DontCare) eval_define_syntax 0)
    (add_function1 global Eval (domainP ReserveSymbol) eval_reserve_symbol 0)

    (add_function1 global Eval (quote (to_sym "exit")) eval_exit 0)

    (add_function1 global (to_sym "load") stringT load_ 0)
    (add_function1 global (to_sym "import") stringT import_lib 0)
    (add_function1 global (to_sym "exit") intT exit_ 0)
    (add_function1 global (to_sym "atexit") funT at_exit 0)
    (add_function1 global (to_sym "enter_module") symT enter_module 0)
    (add_function0 global (to_sym "exit_module") exit_module 0)
    ))

(extern fun setup_pprint)
(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_random)
(extern fun setup_math)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_tuple)
(extern fun setup_array)
(extern fun setup_table)
;(extern fun setup_gc)

(fun init_lib () (
    (setup_base global)
    (setup_pprint global)
    (setup_symbol global)
    (setup_object global)

    (setup_math global)
    (setup_numeric global)
    (setup_string global)
    (setup_bigint global)
    (setup_float global)
    (setup_random global)
    (setup_io global)
    (setup_list global)
    (setup_tuple global)
    (setup_array global)
    (setup_table global)
;    (setup_gc)
    ))

    ))
