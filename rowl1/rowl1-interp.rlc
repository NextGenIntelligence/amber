;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2014-04-08 16:22:37 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-error")
(import "rowl1-object")
(import "rowl1-symtable")
(import "rowl1-compile")
(import "rowl1-packrat")
(import "rowl1-pprint")
(import "rowl1-tuple")
(import "rowl1-array")

(extern object preparse_p)

(export var amber null)
(export var global null)
(export var variables null)

(var current_loc null)
(var module_stack null)

(export fun set_loc (loc) (
    (= current_loc loc)
    (set_slot global (to_sym "LOCATION") loc)
    ))

(fun version_string () (
    (return (strcat (strcat
        (itos10 @VERSION_MAJOR) ".")
        (itos10 @VERSION_MINOR)))
    ))

(export fun eval_main (argc argv) (
    (try
        (return (eval_main_ argc argv))
        (catch e (do
            (= global amber)
            (pp_loc stderr  current_loc)
            (output_string stderr " Error: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(fun eval_main_ (argc argv) (
    (if preparse_p
        (output_string stdout "Generating pre-parsed libs...\n")
        )

    (= current_loc no_loc)

    ; Local variable table
    (= variables (make_symtable 10))

    ; enable set_slot and get_slot
    (setup_object_pre)

    ; Global Module
    (= global @C_NIL)
    (= amber (create_module Amber))
    (set_slot amber Amber amber)
    (remove_parent amber)
    (= global amber)

    (remove_parent @C_NIL)

    ; prim Module
    (var prim (create_module Prim)) ; prim functions
    (set_slot global Prim prim)

    ; Setup built-in objects and functions.
    (setup_argv argc argv)
    (setup_builtin_compilers prim)
    (init_lib prim)
    (init_parser_funcs prim) 

    ; Boot Amber
    (set_loc no_loc)
    (var cwd (getcwd))
    (if (! cwd) (throw (io_error (string "Failed to get current working directory"))))
    (set_slot amber (to_sym "INVOKE_PATH") cwd)

    (var load_path (ary_new)) 
    (set_slot amber (to_sym "AMBER_PATH") load_path)
    (set_slot amber (to_sym "ALREADY_LOADED") (ary_new))
    (set_slot amber (to_sym "VERSION") (version_string))
    (ary_push load_path (tuple2 (string "/usr/lib/amber") amber))
    (var cwdir (realpath (string ".")))
    (if (! cwdir) (throw (io_error (string "Failed to get absolute path of current working directory"))))
    (ary_push load_path (tuple2 cwdir amber))
    (setup_minimal_interpreter prim)
    (load_file "boot.ab")
    (eval_exit @C_NIL)
    (return 0)
    ))

(fun evalfull (expr) (
    (var f (lookup_func_nocheck global (to_sym "before_eval")))
    (if f (= expr (runcode f expr)))
    (var v (runcode (lookup_func global Eval) expr))
    (var g (lookup_func_nocheck global (to_sym "after_eval")))
    (if g (= v (runcode g v)))
    (return v)
    ))

(fun evalfull_with_self (self expr) (
    (var f (lookup_func_nocheck global (to_sym "before_eval")))
    (if f (= expr (runcode f expr)))
    (var v (runcode_with_self self (lookup_func global Eval) expr))
    (var g (lookup_func_nocheck global (to_sym "after_eval")))
    (if g (= v (runcode g v)))
    (return v)
    ))

(fun eval (expr) (
    (return (runcode (lookup_func global Eval) expr))
    ))

(fun eval_with_self (self expr) (
    (return (runcode_with_self self (lookup_func global Eval) expr))
    ))

(extern fun fullform)
(fun interpret (p path) (
    (var ochan 0)
    (if (&& preparse_p path) (do
        ; change .ab to .abc
        (output_string stdout path)
        (= path (strcat path "c"))
        (output_string stdout " => ")
        (output_string stdout path)
        (output_string stdout "\n")
        (= ochan (open_out path @(| O_WRONLY O_CREAT O_TRUNC)))
        (if (! ochan) (throw (io_error1 (string "Open failed") path)))
        ))

    (while 1 (do
        (set_loc (get_loc p))
        (parse_toplevel p)
        (if (! (parse_success p)) (do
            (if (end_of_file p) break)
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))

        (if ochan (do
            (output_string ochan (fullform (parsed_token p)))
            (output_string ochan "\n")
            ))

        (evalfull (parsed_token p))
        ))
    (if ochan (close_out ochan))
    ))

(fun builtin_eval (expr) (
    (var hd (node_head expr))
    (if (== hd Located) (do
        (set_loc (node_arg expr 0))
        (return (eval (node_arg expr 1)))
        )
    (if (== hd Block) (do
        (var list (node_arg_list expr 0))
        (enter_block)
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (exit_module)
        (return v)
        )
    (if (== hd Seq) (do
        (var list (node_arg_list expr 0))
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (return v)
        ))))
    (return (runcode (compile_main expr)))
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(fun exit_ (status) (
    (if (! (&& (& status 1) (> status 0)))
        (throw (invalid_argument (string "invalid exit status code") status))
        )
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit (unbox status))
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return @C_NIL)
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (set_slot amber (to_sym "ARGV") ARGV)
    (if (== argc 0) return)
    (for i 0 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(fun new_dir (dirs path) (
    (for i 0 (array_size dirs) (do
        (if (streq (tuple_at (array_at dirs i) 0) path)
            (return @FALSE)
            )
        ))
    (return @TRUE)
    ))

(fun load_file (path) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (var loaded (get_slot amber (to_sym "ALREADY_LOADED")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (if (!= (node_type loaded) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (do
            ; multiple load check.
            (var rpath (realpath fullpath))
            (if (! rpath)
                (throw (io_error1 (string "Failed to get absolute path") fullpath)))

            (for i 0 (array_size loaded) (do
                (if (streq (ary_at loaded (box i)) rpath)
                    (return @C_FALSE)
                    )
                ))
            (var fd (open "."))
            (if (< fd 0) (throw (io_error (string "Can not open '.'"))))

            (ary_push loaded rpath)

            (var ichan (open_in rpath @FALSE))
            (if (! ichan) (throw (io_error1 (string "Open failed") fullpath)))
            (var dir (get_directory rpath))
            (var new_dir_p (new_dir dirs dir))
            (if new_dir_p (ary_push dirs
                (tuple2 (string dir) (get_slot global parent))
                ))
            (if (< (chdir dir) 0)
                (throw (io_error (string
                    (strcat "Failed to change directory to " dir)))))

            (var p (make_parser fullpath ichan))
            (set_slot p (to_sym "syntax") (load_global Syntax))
            (set_loc (get_loc p))
            (interpret p fullpath)
            (if new_dir_p (ary_pop dirs))
            (if (< (fchdir fd) 0)
                (throw (io_error (string "Failed to change directory to '.'"))))
            (if (< (close fd) 0)
                (throw (io_error (string "Failed to close '.'")))
                )
            (close_in ichan)
            (return @C_TRUE)
            ))
        ))
    (throw (not_found (string path)))
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(fun exec_file (path) (
    (var fd (open "."))
    (if (< fd 0) (throw (io_error (string "Can not open '.'"))))

    (var ichan (open_in path @FALSE))
    (if (! ichan) (throw (io_error1 (string "Open failed") path)))
    (var dir (get_directory path))
    (if (< (chdir dir) 0)
        (throw (io_error (string
            (strcat "Failed to change directory to " dir)))))

    (var p (make_parser path ichan))
    (set_slot p (to_sym "syntax") (load_global Syntax))
    (set_loc (get_loc p))
    (interpret p 0)
    (if (< (fchdir fd) 0)
        (throw (io_error (string "Failed to change directory to '.'"))))
    (if (< (close fd) 0)
        (throw (io_error (string "Failed to close '.'")))
        )
    (close_in ichan)
    (return @C_TRUE)
    ))

(fun loadable (path) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (var loaded (get_slot amber (to_sym "ALREADY_LOADED")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (if (!= (node_type loaded) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (return @C_TRUE))
        ))
    (return @C_FALSE)
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(fun find_parent (sym) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") 
            (strcat (symbol_name sym) ".ab")))
        (if (file_exists fullpath) (return mod))
        ))
    (return 0)
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(export fun create_module (sym) (
    (if (&& (!= (node_head global) Module) (!= global @C_NIL))
        (throw (invalid_argument
            "1st argument of create_module(sym@Symbol)"
            sym
            ))
        )
    (var mod (make_node1 Module sym))
    (set_slot mod parent global)
    (return mod)
    ))

(fun enter_module (sym) (
    (if (!= (symtable_depth variables) 0)
        (throw (logic_error (string "enter_module() can be called only in top-scope"))))
    (var mod (get_slot_nocheck global sym))
    (if (|| (== mod @C_NIL) (!= (node_head mod) Module)) (do
        (var p (find_parent sym))
        (if (! p) (= p global))
        (= mod (make_node1 Module sym))
        (set_slot p sym mod)
        (set_slot mod parent p)
        ))
    (= module_stack (cons global module_stack))
    (= global mod)
    (return mod)
    ))

(fun enter_block () (
    (if (!= (symtable_depth variables) 0)
        (throw (logic_error (string "enter_module() can be called only in top-scope"))))
    (var mod (make_node1 Module (to_unique_sym "Block")))
    (set_slot mod parent global)
    (= module_stack (cons global module_stack))
    (= global mod)
    (return mod)
    ))

(fun exit_module () (
    (if (! module_stack)
        (throw (logic_error (string "Can not exit from global-module"))))
    (var mod (car module_stack))
    (= global mod)
    (= module_stack (cdr module_stack))
    (return mod)
    ))

(fun change_dir (path) (
    (if (< (chdir path) 0)
        (throw (io_error1 (string "Failed to change directory to") path))
        )
    (return @C_NIL)
    ))

(export fun load_global (sym) (
    (return (get_slot_nocheck amber sym))
    ))

(fun copy_variable (to sym1 from sym2) (
    (var f (get_slot_nocheck from (to_sym sym2)))
    (if (== f @C_NIL)
        (throw (not_found (to_sym sym2)))
        )
    (set_slot to (to_sym sym1) f)
    ))

(fun define_variable (sym val) (
    (return (set_slot global sym val))
    ))

(fun define_variable_fusion (sym val _) (
    (return (set_slot_fusion global sym val))
    ))

(fun gettimeofday_ () (
    (return (gettimeofday))
    ))

(fun timeval_sub_ (t1 t2) (
    (var t (timeval_sub t1 t2))
    (return (tuple2 (box (field_get t 0)) (box (field_get t 1))))
    ))

(fun setup_minimal_interpreter (prim) (
    ; parser
    (var syntax (create_module Syntax))
    (set_slot global Syntax syntax)
    (set_slot syntax parent global)
    
    (copy_variable syntax "any" prim "parse_any")
    (copy_variable syntax "spaces" prim "parse_spaces")
    (copy_variable syntax "comment" prim "parse_comment")
    (copy_variable syntax "decimal" prim "parse_decimal")
    (copy_variable syntax "binary" prim "parse_binary")
    (copy_variable syntax "octal" prim "parse_octal")
    (copy_variable syntax "hex" prim "parse_hex")
    (copy_variable syntax "integer" prim "parse_integer")
    (copy_variable syntax "float" prim "parse_float")
    (copy_variable syntax "string" prim "parse_string")
    (copy_variable syntax "symbol" prim "parse_symbol")
    (copy_variable syntax "any_symbol" prim "parse_any_symbol")
    (copy_variable syntax "identifier" prim "parse_identifier")
    (copy_variable syntax "atom" prim "parse_atom")
    (copy_variable syntax "fullform" prim "parse_fullform")
    (copy_variable syntax "expr" prim "parse_expr")
    (copy_variable syntax "stmt" prim "parse_stmt")
    (copy_variable syntax "toplevel_stmt" prim "parse_toplevel_stmt")

    ; evaluator
    (add_function1 prim Eval DontCare builtin_eval 0)
    (add_function2 prim (to_sym "eval_with_self") DontCare DontCare eval_with_self 0)
    (add_function1 prim (to_sym "eval_full") DontCare evalfull 0)
    (add_function2 prim (to_sym "eval_with_self_full") DontCare DontCare evalfull_with_self 0)

    (add_function1 prim (to_sym "exit") intT exit_ 0)
    (add_function1 prim (to_sym "atexit") funT at_exit 0)
    (add_function1 prim (to_sym "load") stringT load_file 0)
    (add_function1 prim (to_sym "execfile") stringT exec_file 0)
    (add_function1 prim (to_sym "loadable?") stringT loadable 0)
    (add_function1 prim (to_sym "create_module") symT create_module 0)
    (add_function1 prim (to_sym "enter_module") symT enter_module 0)
    (add_function0 prim (to_sym "exit_module") exit_module 0)
    (add_function2 prim (to_sym "define_variable") symT DontCare define_variable 0)
    (add_function3 prim (to_sym "define_variable") symT DontCare (quote (to_sym "fusion")) define_variable_fusion 0)
    (add_function0 prim (to_sym "gettimeofday") gettimeofday_ 0)
    (add_function2 prim (to_sym "timeval_sub") DontCare DontCare timeval_sub_ 0)
    (add_function1 prim (to_sym "chdir") stringT change_dir 0)
    (add_function1 prim (to_sym "debugpf") DontCare debugpf 0)

    ; important functions
    (copy_variable global "compile" prim "compile")
    (copy_variable global "eval" prim "eval")

    (define_variable (to_sym "PROMPT") (string "amber"))
    ))

(extern fun setup_pprint)
(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_encoding)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_random)
(extern fun setup_math)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_tuple)
(extern fun setup_array)
(extern fun setup_table)
;(extern fun setup_gc)

(fun init_lib (mod) (
    (setup_base mod)
    (setup_pprint mod)
    (setup_object mod)
    (setup_encoding mod)
    (setup_symbol mod)
    (setup_math mod)
    (setup_bigint mod)
    (setup_string mod)
    (setup_float mod)
    (setup_random mod)
    (setup_io mod)
    (setup_list mod)
    (setup_tuple mod)
    (setup_array mod)
    (setup_table mod)
;    (setup_gc)
    ))

    ))
