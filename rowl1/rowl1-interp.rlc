;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2014-01-31 18:42:59 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-error")
(import "rowl1-object")
(import "rowl1-symtable")
(import "rowl1-compile")
(import "rowl1-packrat")
(import "rowl1-pprint")

(export var amber null)
(export var global null)
(export var prim null)
(export var variables null)
(export var current_loc null)

(extern fun ary_new)
(extern fun ary_at)
(extern fun ary_store)
(extern fun ary_push)
(extern fun ary_size)

(export fun set_loc (loc) (
    (= current_loc loc)
    (set_slot global (to_sym "LOCATION") loc)
    ))

(export fun eval_shell () (
    (set_shell_mode)
    (try
        (return (eval_main "amber" stdin 0 0))
        (catch e (do
            (= global amber)
            (output_string stderr "Uncaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(export fun eval_file (path argc argv) (
    (var r 0)
    (var ichan (open_in path))
    (try
        (= r (eval_main path ichan argc argv))
        (catch e (do
            (= global amber)
            (output_string stderr "Unaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (= r 1)
        )))
    (close_in ichan)
    (return r)
    ))

(fun eval_main (file ichan argc argv) (
    (= current_loc no_loc)

    ; Local variable table
    (= variables (make_symtable 10))

    ; Global Module
    (= global @C_UNDEF)
    (= amber (create_module Amber))
    (set_slot amber Amber amber)
    (= global amber)

    ; Prim Module
    (= prim (create_module Prim)) ; Prim functions
    (set_slot global Prim prim)

    ; Setup built-in objects and functions.
    (setup_argv argc argv)
    (setup_builtin_compilers prim)
    (init_lib prim)
    (init_parser_funcs prim) 

    ; Boot Amber
    (set_loc no_loc)
    (var load_path (ary_new)) 
    (set_slot amber (to_sym "AMBERPATH") load_path)
    (set_slot amber (to_sym "LOADED") (ary_new))
    (ary_push load_path (string "."))
    (ary_push load_path (string "/usr/lib/amber"))
    (setup_minimal_interpreter prim)
    (load_file "Boot.ab")

    ;; Boot Amber
    ;(load_file "Boot.ab")
    ;(load_file "Syntax.ab")
    ;(load_file "Module.ab")
    ;(load_file "Object.ab")

    ;;(load_file "Syntax.ab")

    ;;(import_lib "amber/syntax.ab")
    ;;(import_lib "std/string.ab")
    ;;(import_lib "std/numeric.ab")
    ;;(import_lib "std/format.ab")
    ;;(import_lib "std/list.ab")
    ;;(import_lib "std/array.ab")
    ;;(import_lib "std/table.ab")
    ;;(import_lib "std/io/io.ab")

    ;(add_load_dir (get_directory file))
    ;(add_load_dir (get_env "PWD"))

    ;(var p (make_parser file ichan))

    ;(if (in_shell_mode)
    ;    (interpret_shell p)
    ;    (do
    ;        (var fd (open "."))
    ;        (var dir (get_directory file))
    ;        (chdir dir)
    ;        (interpret p)
    ;        (fchdir fd)
    ;    )
    ;    )
    (eval_exit @C_NIL)

    (return 0)
    ))

(fun eval_top (expr) (
    (var f (lookup_func_nocheck global (to_sym "before_eval")))
    (if f (= expr (runcode f expr)))
    (var v (eval expr))
    (var g (lookup_func_nocheck global (to_sym "after_eval")))
    (if g (= v (runcode g v)))
    (return v)
    ))

(fun eval (expr) (
    (return (runcode (lookup_func global Eval) expr))
    ))

(fun rewrite (expr) (
    (var new_expr (runcode (lookup_func (get_slot global Syntax) Rewrite) expr))
    (if (!= new_expr expr) (return (rewrite new_expr)))
    (= expr new_expr)
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (rewrite_qquote (node_arg expr 0) 0))
        (return expr)
        ))

    ; Don't rewrite patterns but rewrite guard expressions
    (if (== hd Define) (do
        (var lhs (node_arg expr 0))
        (if (== (node_head lhs) Apply) (do
            (var guard (node_arg lhs 1))
            (if (== (node_head guard) When)
                (node_arg_set guard 1 (rewrite (node_arg guard 1)))
                )
            ))
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (node_arg expr 0))
        (if (== (node_bhead lhs) When)
            (node_arg_set lhs 1 (rewrite (node_arg lhs 1)))
            )
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))

    (for i 0 (node_size expr) (do
        (node_arg_set expr i (rewrite (node_arg expr i)))
        ))
    (return expr)
    ))

(fun rewrite_qquote (expr level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite_qquote (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0)
            (node_arg_set expr 0 (rewrite (node_arg expr 0)))
            (node_arg_set expr 0
                (rewrite_qquote (node_arg expr 0) (- level 1)))
            )
        (return expr)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))

    (for i 0 (node_size expr)
        (node_arg_set expr i
            (rewrite_qquote (node_arg expr i) level))
        )
    (return expr)
    ))

(fun interpret (p) (
    (while 1 (do
        (parse_toplevel p)
        (if (! (parse_success p)) (do
            (if (end_of_file p) break)
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))
        (eval_top (parsed_token p))
        ))
    (= current_loc no_loc)
    ))

(fun interpret_shell (p) (
    (var outputs (ary_new))
    (eval_top (apply (slot (slot (to_sym "Syntax") (to_sym "Shell")) (to_sym "enable_shell_syntax")) 0))
    (set_slot global (to_sym "shell_outputs") outputs)
    (ary_push outputs @C_UNDEF)
    (while 1 (do
        (try 
            (while 1 (do
                (parse_shell p)
                (if (! (parse_success p)) (do
                    (output_syntax_error (get_loc p) (parser_error p))
                    (flush_parser p @TRUE)
                    continue
                    ))
                (var ret (eval_top (parsed_token p)))
                (print_result ret)
                (ary_store outputs (box 0) ret)
                (ary_push outputs ret)
                (increment_line p)
                ))
        (catch e (do
            (output_string stderr "Error: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (flush_parser p @TRUE)
        )))))
    ))

(fun print_result (val) (
    (output_string stdout "=> ")
    (pprint stdout val)
    (output_char stdout '\n')
    ))

(fun builtin_eval (expr) (
    (var hd (node_head expr))
    (if (== hd Located) (do
        (set_loc (node_arg expr 0))
        (return (eval (node_arg expr 1)))
        )
    (if (== hd Block) (do
        (var list (node_arg_list expr 0))
        (enter_module (to_unique_sym "Block"))
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (exit_module)
        (return v)
        )
    (if (== hd Seq) (do
        (var list (node_arg_list expr 0))
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (return v)
        ))))
    (return (runcode (compile_main expr)))
    ))

(fun default_eval (expr) (
    (return (runcode (compile_main (rewrite expr))))
    ))

(fun eval_located (expr) (
    (set_loc (node_arg expr 0))
    (return (eval (node_arg expr 1)))
    ))

(fun rewrite_donothing (expr) ((return expr)))

(fun rewrite_located (expr) (
    (node_arg_set expr 1 (rewrite (node_arg expr 1)))
    (return expr)
    ))

(fun eval_seq (expr) (
    (var stmts (node_arg expr 0))
    (var v @C_NIL)
    (while stmts (do
        (= v (eval (car stmts)))
        (= stmts (cdr stmts))
        ))
    (return v)
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(fun exit_ (status) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit (unbox status))
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return @C_NIL)
    ))

(fun is_already_imported (list file) (
    (if (!= (node_type list) @ListE)
        (throw (type_error current_loc (string "List") list))
        )
    (while list (do
        (if (streq file (car list))
            (return @TRUE)
            )
        (= list (cdr list))
        ))
    (return @FALSE)
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (set_slot amber (to_sym "ARGV") ARGV)
    (if (== argc 0) return)
    (for i 1 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(fun load_file (path) (
    (var dirs (get_slot amber (to_sym "AMBERPATH")))
    (var loaded (get_slot amber (to_sym "LOADED")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (if (!= (node_type loaded) @ArrayE) (goto load_error))
    (for i 0 (unbox (ary_size dirs)) (do
        (var dir (ary_at dirs (box i)))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (do
            ; multiple load check.
            (= fullpath (realpath fullpath))
            (for i 0 (unbox (ary_size loaded)) (do
                (if (streq (ary_at loaded (box i)) fullpath)
                    (return @C_FALSE)
                    )
                ))
            (ary_push loaded fullpath)

            (var ichan (open_in fullpath))
            (var fd (open "."))
            (var dir (get_directory fullpath))
            (chdir dir)

            (var p (make_parser fullpath ichan))
            (set_loc (get_loc p))

            (var save_shell_mode_p (in_shell_mode))
            (unset_shell_mode)
            (interpret p)
            (if save_shell_mode_p (set_shell_mode))

            (fchdir fd)
            (close_in ichan)

            (set_loc no_loc)
            (return @C_TRUE)
            ))
        ))
    (throw (not_found current_loc (string path)))

    (label load_error)
    (throw (logic_error1 current_loc
        (string "AMBERPATH must be an array of strings")
        dirs))
    ))

(fun enter_module (sym) (
    (if (!= (symtable_depth variables) 0)
        (throw (logic_error current_loc
            (string "enter_module() can be called only in top-scope")))
        )
    (var mod (load_global sym))
    (if (== mod @C_UNDEF)
        (= mod (create_module sym))
        )
    (if (!= (get_slot mod proto) global)
        (throw (logic_error current_loc
            (string "The argument of enter_module() must be direct submodule of global-module")))
        )
    (= global mod)
    (return mod)
    ))

(fun exit_module () (
    (var mod (get_slot global proto))
    (if (!= (node_bhead mod) Module)
        (throw (type_error current_loc (string "Module") mod))
        )
    (= global mod)
    (return mod)
    ))

(export fun load_global (sym) (
    (return (get_slot global sym))
    ))

(fun setup_global_methods () (
    ;(var syntax (get_slot global Syntax)) 
    ;(add_function1 syntax Rewrite DontCare rewrite_donothing 0)
    ;(add_function1 syntax Rewrite (domainP Located) rewrite_located 0)
    ;(add_function1 global Eval DontCare default_eval 0)
    ;(add_function1 global Eval (domainP Located) eval_located 0)
    ;(add_function1 global Eval (make_object1 Import listT) eval_import 0)

    ;(add_function1 global Eval (make_object1 Seq listT) eval_seq 0)

    ;(add_function1 global Eval (quote (to_sym "exit")) eval_exit 0)

    ;(add_function1 global (to_sym "exit") intT exit_ 0)
    ;(add_function1 global (to_sym "atexit") funT at_exit 0)
    ))

(fun copy_variable (to sym1 from sym2) (
    (var f (get_slot from (to_sym sym2)))
    (if (== f @C_UNDEF)
        (throw (not_found current_loc (to_sym sym2)))
        )
    (set_slot to (to_sym sym1) f)
    ))

(fun define_variable (sym val) (
    (return (set_slot global sym val))
    ))

(fun define_variable_incremental (sym val _) (
    (return (set_slot_incremental global sym val))
    ))

(fun setup_minimal_interpreter (prim) (
    ; parser
    (var syntax (create_module Syntax))
    (set_slot global Syntax syntax)
    (set_slot syntax proto global)
    
    (copy_variable syntax "word" prim "parse_word")
    (copy_variable syntax "text" prim "parse_text")
    (copy_variable syntax "any" prim "parse_any")
    (copy_variable syntax "blank" prim "parse_blank")
    (copy_variable syntax "spaces" prim "parse_spaces")
    (copy_variable syntax "comment" prim "parse_comment")
    (copy_variable syntax "decimal" prim "parse_decimal")
    (copy_variable syntax "binary" prim "parse_binary")
    (copy_variable syntax "octal" prim "parse_octal")
    (copy_variable syntax "hex" prim "parse_hex")
    (copy_variable syntax "integer" prim "parse_integer")
    (copy_variable syntax "float" prim "parse_float")
    (copy_variable syntax "string" prim "parse_string")
    (copy_variable syntax "string_d" prim "parse_string_d")
    (copy_variable syntax "string_s" prim "parse_string_s")
    (copy_variable syntax "symbol" prim "parse_symbol")
    (copy_variable syntax "reserved_symbol" prim "parse_reserved_symbol")
    (copy_variable syntax "atom" prim "parse_atom")
    (copy_variable syntax "fullform" prim "parse_fullform")
    (copy_variable syntax "expr" prim "parse_expr")
    (copy_variable syntax "stmt" prim "parse_stmt")

    ; compiler
    (copy_variable global "compile" prim "compile")

    ; evaluator
    (add_function1 prim Eval DontCare builtin_eval 0)
    (add_function1 prim (to_sym "load") stringT load_file 0)
    (add_function1 prim (to_sym "create_module") symT create_module 0)
    (add_function1 prim (to_sym "enter_module") symT enter_module 0)
    (add_function0 prim (to_sym "exit_module") exit_module 0)
    (add_function2 prim (to_sym "define_variable") symT DontCare define_variable 0)
    (add_function3 prim (to_sym "define_variable") symT DontCare (quote (to_sym "incremental")) define_variable_incremental 0)
    (add_function1 prim (to_sym "debugpf") DontCare debugpf 0)

    (copy_variable global "eval" prim "eval")
    (copy_variable global "load" prim "load")

    ; important functions
    (copy_variable global "equal?" prim "equal?")
    (copy_variable global "identical?" prim "identical?")
    (copy_variable global "fusion" prim "fusion_function")
    (copy_variable global "create_module" prim "create_module")
    (copy_variable global "enter_module" prim "enter_module")
    (copy_variable global "exit_module" prim "exit_module")
    ))

(extern fun setup_pprint)
(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_random)
(extern fun setup_math)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_tuple)
(extern fun setup_array)
(extern fun setup_table)
;(extern fun setup_gc)

(fun init_lib (mod) (
    (setup_base mod)
    ;(setup_pprint mod)
    (setup_object mod)
    (setup_symbol mod)

    ;(setup_math mod)
    (setup_numeric mod)
    (setup_string mod)
    ;(setup_bigint mod)
    (setup_float mod)
    ;(setup_random mod)
    (setup_io mod)
    (setup_list mod)
    ;(setup_tuple mod)
    ;(setup_array mod)
    ;(setup_table mod)
;    (setup_gc)
    ))

    ))
