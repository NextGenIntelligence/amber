;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2012-11-21 14:48:43 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-packrat")
(import "rowl1-symtable")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-module")
(import "rowl1-error")

(export var global_mod null)
(export var current_loc null)
(export var current_mod null)
(export fun set_loc (loc) (
    (= current_loc loc)
    (add_module_variable global_mod (to_sym "LOCATION") loc true)
    ))

(var module_stack null)

(export fun set_current_module (mod) (
    (= current_mod mod)
    (add_module_variable global_mod (to_sym "MODULE") mod true)
    ))

(export fun eval_shell () (
    (set_shell_mode)
    (try
        (return (eval_main "amber" stdin 0 0))
        (catch e (do
            (output_string stderr "Uncaught exception: ")
            (pretty_print stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(export fun eval_file (path argc argv) (
    (var r 0)
    (var ichan (open_in path))
    (try
        (= r (eval_main path ichan argc argv))
        (catch e (do
            (output_string stderr "Exception: ")
            (pretty_print stderr e)
            (output_string stderr "\n")
            (= r 1)
        )))
    (close_in ichan)
    (return r)
    ))

(export fun eval_main (file ichan argc argv) (
    ;(var start (gettimeofday))

    (= global_mod (make_module (to_sym "%global") 0))
    (= module_stack (cons global_mod 0))

    (= current_loc no_loc)

    (setup_argv argc argv)
    (setup_globals global_mod)
    (setup_builtin_compilers global_mod)
    (init_stdlib global_mod)
    (open_module current_loc global_mod (to_sym "std"))
    (open_module current_loc global_mod (qualified "std" (to_sym "IO")))

    (init_parser_funcs global_mod)

    (= current_mod global_mod)
    (= current_loc no_loc)

    (add_import_dir "/usr/lib/amber/")
    (import_file "amber/syntax.ab")
    (if (in_shell_mode)
        (open_module current_loc global_mod (to_sym "shell_syntax"))
        )
    (import_file "data/string.ab")
    (import_file "io.ab")
    (import_file "data/list.ab")
    (import_file "data/array.ab")
    (import_file "data/struct.ab")
    (import_file "data/table.ab")

    (add_import_dir (get_directory file))
    (add_import_dir "./")

    ;(var end (gettimeofday))
    ;(var diff (timeval_sub end start))
    ;(output_string stderr "startup time : ")
    ;(output_timeval stderr diff)
    ;(output_char stderr '\n')

    (var p (init_parser file ichan))

    (if (in_shell_mode)
        (interpret_shell p)
        (interpret p)
        )

    (eval_exit nil)

    (return 0)
    ))

(fun eval (expr) (
    (return (call1 Eval expr))
    ))

(fun rewrite (expr) (
    (= expr (call1 Rewrite expr))
    (if (is_atom expr)
        (return expr)
        )
    (var hd (expr_head expr))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (expr_arg_set expr 0 (rewrite_qquote (expr_arg expr 0) 0))
        (return expr)
        ))

    ; Don't rewrite patterns
    (if (== hd DefineVariable) (do
        (expr_arg_set expr 1 (rewrite (expr_arg expr 1)))
        (return expr)
        ))
    (if (== hd DefineFunction) (do
        (expr_arg_set expr 1 (rewrite (expr_arg expr 1)))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (expr_arg expr 0))
        (if (== (expr_head lhs) Where)
            (expr_arg_set lhs 1 (rewrite (expr_arg lhs 1)))
            )
        (expr_arg_set expr 1 (rewrite (expr_arg expr 1)))
        (return expr)
        ))

    (var args (expr_args expr))
    (while args (do
        (setcar args (rewrite (car args)))
        (= args (cdr args))
        ))
    (return expr)
    ))

(fun rewrite_qquote (expr level) (
    (if (is_atom expr) (return expr))
    (var hd (expr_head expr))
    (if (== hd Unquote) (do
        (if (== level 0)
            (expr_arg_set expr 0 (rewrite (expr_arg expr 0)))
            (expr_arg_set expr 0
                (rewrite_qquote (expr_arg expr 0) (- level 1)))
            )
        (return expr)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))
    (var args (expr_args expr))
    (while args (do
        (setcar args (rewrite_qquote (car args) level))
        (= args (cdr args))
        ))
    (return expr)
    ))

(fun interpret (p) (
    (while 1 (do
        (parse_statements p)
        (if (! (parse_success p)) (do
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))
        (var es (parsed_token p))
        (if (! es) break)
        (while es (do
            (eval (car es))
            (= es (cdr es))
            ))
        ))
    (= current_loc no_loc)
    ))

(extern fun ary_new)
(extern fun ary_store)
(extern fun ary_push)
(fun interpret_shell (p) (
    (var outputs (ary_new))
    (add_module_variable global_mod (to_sym "shell_outputs") outputs true)
    (ary_push outputs undefined)
    (while 1 (do
        (try 
            (while 1 (do
                (parse_shell_statement p)
                (if (! (parse_success p)) (do
                    (output_syntax_error (get_loc p) (parser_error p))
                    (flush_parser p @TRUE)
                    continue
                    ))
                (parsed_token p)
                (var ret (eval (parsed_token p)))
                (print_result p ret)
                (flush_parser p @FALSE)
                (ary_store outputs (box 0) ret)
                (ary_push outputs ret)
                ))
        (catch e (do
            (output_string stderr "Error: ")
            (pretty_print stderr e)
            (output_string stderr "\n")
            (flush_parser p @TRUE)
            (ary_push outputs e)
        )))))
    ))

(fun print_result (p val) (
    (output_string stdout "=> ")
    (pretty_print stdout val)
    (output_char stdout '\n')
    ))

(fun default_eval (expr) (
    (return (byterun (compile_main current_mod (rewrite expr))))
    ))

(fun eval_located (expr) (
    (set_loc (expr_arg expr 0))
    (return (eval (expr_arg expr 1)))
    ))

(fun eval_begin_module (expr) (
    (if (! (in_top_scope current_mod))
        (throw (exception current_mod (string "module definition in sub-scope is not allowed\n")))
        )
    (var modsig (expr_arg expr 0))
    (var save_current_mod current_mod)
    (var module (find_module current_loc current_mod modsig @TRUE))
    (= module_stack (cons module module_stack))
    (set_current_module module)
    (return module)
    ))

(fun eval_end_module (expr) (
    (if (== current_mod global_mod)
        (throw (exception current_mod (string "there is no module to close")))
        )
    (if (! (in_top_scope current_mod))
        (throw (exception current_mod (string "module definition in sub-scope is not allowed")))
        )
    (= module_stack (cdr module_stack))
    (var module (car module_stack))
    (if (! module) 
        (throw (exception current_mod (string "can not exit global-scope")))
        )
    (var r current_mod)
    (set_current_module module)
    (return r)
    ))

(fun default_rewrite (expr) (
    (return expr)
    ))


(fun rewrite_located (expr) (
    (expr_arg_set expr 1 (rewrite (expr_arg expr 1)))
    (return expr)
    ))

(fun eval_define_syntax (expr) (
    (var sym (expr_arg expr 0))
    (var elm (expr_arg expr 1))
    (var stmts (compile_define_syntax sym elm))
    (while stmts (do
        (eval (car stmts))
        (= stmts (cdr stmts))
        ))
    (return nil)
    ))

(fun eval_seq (expr) (
    (var stmts (expr_arg expr 0))
    (while stmts (do
        (eval (car stmts))
        (= stmts (cdr stmts))
        ))
    (return nil)
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (byterun (get_bytecode (string "argument for atexit") (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return nil)
    ))

(var import_dirs null)
(var importd_modules null)

(fun add_import_dir (path) (
    (= import_dirs (cons path import_dirs))
    ))

(fun add_importd_file (path) (
    ; XXX: fixme. canonicalize the `path'
    (= importd_modules (cons path importd_modules))
    ))

(fun is_already_importd (path) (
    (var list importd_modules)
    (while list (do
        (if (streq path (car list))
            (return @TRUE)
            )
        (= list (cdr list))
        ))
    (return @FALSE)
    ))

(fun import_file (path) (
    (var dir import_dirs)
    (while dir (do
        (var fullpath (build_path (car dir) path ""))
        (if (file_exists fullpath) (do
            (if (is_already_importd fullpath)
                (return nil)
                )
            (add_importd_file fullpath)

            (var ichan (open_in fullpath))
            (var fd (open "."))
            (chdir (get_directory fullpath))
        
            (var p (init_parser fullpath ichan))
            (set_loc (get_loc p))

            (var shell_mode_p (in_shell_mode))
            (unset_shell_mode)
            (interpret p)
            (if shell_mode_p (set_shell_mode))

            (fchdir fd)
            (close_in ichan)

            (set_loc no_loc)
            (return nil)
            ))
        (= dir (cdr dir))
        ))
    (output_error stderr current_loc)
    (output_string stderr "`")
    (output_string stderr path)
    (output_string stderr "' was not found\n")
    (exit 1)
    ))

(fun eval_open (expr) (
    (open_module current_loc current_mod (expr_arg expr 0))
    (return nil)
    ))

(fun eval_import (expr) (
    (var syms (expr_arg expr 0))
    (var path (string ""))
    (while syms (do
        (= path (strcat path (symbol_name (car syms))))
        (= syms (cdr syms))
        (if syms (= path (strcat path "/")))
        ))
    (= path (strcat path ".ab"))
    (import_file path)
    (return nil)
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (add_module_variable global_mod (to_sym "ARGV") ARGV true)
    (if (== argc 0) return)
    (for i 1 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(fun setup_globals (mod) (
    (var symT (domainP Symbol))
    
    (add_module_variable mod (to_sym "LOCATION") current_loc false)
    (add_module_variable mod (to_sym "MODULE") current_mod false)

    (if (in_shell_mode)
        (add_module_variable mod (to_sym "shell_mode") true true)
        (add_module_variable mod (to_sym "shell_mode") false true)
        )
    
    (add_builtin_function1 mod Rewrite DontCare default_rewrite 0)
    (add_builtin_function1 mod Rewrite (domainP Located) rewrite_located 0)
    (add_builtin_function1 mod Eval DontCare default_eval 0)
    (add_builtin_function1 mod Eval (domainP Located) eval_located 0)
    (add_builtin_function1 mod Eval (make_expr Open (list1 DontCare))
        eval_open 0)
    (add_builtin_function1 mod Eval (make_expr Import (list1 listT)) eval_import 0)
    (add_builtin_function1 mod Eval (make_expr BeginModule (list1 symT))
        eval_begin_module 0)
    (add_builtin_function1 mod Eval (make_expr BeginModule (list1 (domainP Qualified)))
        eval_begin_module 0)
    (add_builtin_function1 mod Eval (make_expr EndModule 0)
        eval_end_module 0)
    (add_builtin_function1 mod Eval
        (make_expr DefSyntax (list2 symT DontCare))
        eval_define_syntax 0)
    (add_builtin_function1 mod Eval (make_expr Seq (list1 listT)) eval_seq 0)

    (add_builtin_function1 mod Eval (quote (to_sym "exit"))
        eval_exit 0)

    (add_builtin_function1 mod (to_sym "atexit") funT at_exit 0)
    ))

(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_array)
(extern fun setup_table)

(fun init_stdlib (mod) (
    (var std (find_module no_loc mod (to_sym "std") @TRUE))
    (setup_base std)
    (setup_symbol std)
    (setup_numeric std)
    (setup_string std)
    (setup_float std)
    (setup_bigint std)
    (setup_io std)
    (setup_list std)
    (setup_array std)
    (setup_table std)
    ))

    ))
