;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2010-12-10 04:01:31 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-parse")
(import "rowl1-symtable")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-matching")

(var funtable (make_symtable))
(var vartable (make_symtable))

(export fun add_function (sym args code) (
    (var depth (symtable_depth funtable))
    (var arity (list_length args))
    (var ent (symtable_find funtable sym arity))
    (if (&& ent (== depth (field_get ent 2)))
        (do
            (var pats (cons (cons args code) (cdr ent)))
            (field_set ent 1 pats)
            (field_set ent 0 (compile_matching_hook ent arity))
        )
        (do
            (var pats (cons (cons args code) 0))
            (var ent  (tuple 2 (bytecode 0 0 0 0) pats depth))
            (field_set ent 0 (compile_matching_hook ent arity))
            (symtable_add funtable sym arity ent)
            (register_symbol sym (to_sym "%function"))
        )
        )
    ))

(export fun add_builtin_function1 (sym pat func) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func @TRUE)
    (var code (get_code asm))
    (add_function sym (list1 pat) code)
    ))

(export fun add_builtin_function2 (sym pat1 pat2 func) (
    (var asm (make_assembler))
    (compile_simple_function asm 2 func @TRUE)
    (var code (get_code asm))
    (add_function sym (list2 pat1 pat2) code)
    ))

(export fun interpret (ichan) (
    (while 1 (do
        (var e (parse ichan))
        (if (! e) break)
        (call_eval no_loc e)
        ))
    ))

(fun call_eval (loc expr) (
    (var f (lookup_func eval-sym 2))
    (jitcall f loc expr)
    ))

(export fun builtin_eval (loc expr) (
    (if (! expr) (error "builtin_eval: null expression"))
    (tswitch (node_type expr) (
        (@SymbolE . (return (builtin_eval_symbol loc expr)))
        (@Expr    . (return (builtin_eval_expr loc expr)))
        (default  . (return expr))
        ))
    ))

(fun builtin_eval_symbol (sym) (
    (var value (symtable_find vartable sym 0))
    (if value (return value) (return sym))
    ))

(fun builtin_eval_expr (loc expr) (
    (var head (field_get expr @ExprHead))
    (var args (field_get expr @ExprArgs))

    ; XXX: temporal implementation. should use pattern maching functionality.
    (if (== head Located) (return (builtin_eval (car args) (cadr args))))

    (print_string (field_get head @SymbolName))
    (print_char '\n')
    (not_reachable "builtin_eval_expr")
    ))

(export fun lookup_func (sym arity) (
    (var ent (symtable_find funtable sym arity))
    (if (! ent) (do
        (= ent (tuple 2 (gen_no_declaration_error sym) 0 (symtable_depth funtable)))
        (symtable_add funtable sym arity ent)
        ))
    (return (field_get ent 0))
    ))

;(fun undefined_expression (loc) (
;    (flush stdout)
;    (error_head stderr loc)
;    (output_string stderr "undefined expression\n")
;    (exit 1)
;    ))
;
(fun no_declaration_error (name) (
    (flush stdout)
    (output_string stderr "ERROR: no declaration of ")
    (output_string stderr name)
    (exit 1)
    ))

(fun gen_no_declaration_error (sym) (
    (var asm (make_assembler))
    (put_push asm (field_get sym @SymbolName))
    (compile_simple_call asm 1 no_declaration_error @FALSE)
    (return (get_code asm))
    ))

    ))
