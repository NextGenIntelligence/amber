;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2014-03-05 15:56:28 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-error")
(import "rowl1-object")
(import "rowl1-symtable")
(import "rowl1-compile")
(import "rowl1-packrat")
(import "rowl1-pprint")
(import "rowl1-tuple")
(import "rowl1-array")

(export var amber null)
(export var global null)
(export var prim null)
(export var variables null)

(var current_loc null)
(var module_stack null)

(export fun set_loc (loc) (
    (= current_loc loc)
    (set_slot global (to_sym "LOCATION") loc)
    ))

(export fun eval_shell () (
    (set_shell_mode)
    (try
        (return (eval_main "amber" stdin 0 0))
        (catch e (do
            (= global amber)
            (pp_loc stderr  current_loc)
            (output_string stderr " Uncaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(export fun eval_file (path argc argv) (
    (var r 0)
    (var ichan (open_in path @FALSE))
    (if (! ichan)
        (throw (io_error1 (string "Failed to open") (string path))))
    (try
        (= r (eval_main path ichan argc argv))
        (catch e (do
            (= global amber)
            (pp_loc stderr current_loc)
            (output_string stderr " Unaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (= r 1)
        )))
    (close_in ichan)
    (return r)
    ))

(fun version_string () (
    (return (strcat (strcat (itos @VERSION_MAJOR) ".") (itos @VERSION_MINOR)))
    ))

(fun eval_main (file ichan argc argv) (
    (= current_loc no_loc)

    ; Local variable table
    (= variables (make_symtable 10))

    ; enable set_slot and get_slot
    (setup_object_pre)

    ; Global Module
    (= global @C_NIL)
    (= amber (create_module Amber))
    (set_slot amber Amber amber)
    (remove_parent amber)
    (= global amber)

    (remove_parent @C_NIL)

    ; prim Module
    (= prim (create_module Prim)) ; prim functions
    (set_slot global Prim prim)

    ; Setup built-in objects and functions.
    (setup_argv argc argv)
    (setup_builtin_compilers prim)
    (init_lib prim)
    (init_parser_funcs prim) 

    ; Boot Amber
    (set_loc no_loc)
    (var load_path (ary_new)) 
    (set_slot amber (to_sym "AMBER_PATH") load_path)
    (set_slot amber (to_sym "ALREADY_LOADED") (ary_new))
    (set_slot amber (to_sym "VERSION") (version_string))
    (ary_push load_path (tuple2 (string "/usr/lib/amber") amber))
    (var cwdir (realpath (string ".")))
    (if (! cwdir) (throw (io_error (string "Failed to get absolute path of current working directory"))))
    (ary_push load_path (tuple2 cwdir amber))
    (setup_minimal_interpreter prim)
    (load_file "Boot.ab")
    (eval_exit @C_NIL)
    (return 0)
    ))

(fun evalfull (expr) (
    (var f (lookup_func_nocheck global (to_sym "before_eval")))
    (if f (= expr (runcode f expr)))
    (var v (runcode (lookup_func global Eval) expr))
    (var g (lookup_func_nocheck global (to_sym "after_eval")))
    (if g (= v (runcode g v)))
    (return v)
    ))

(fun evalfull_with_self (self expr) (
    (var f (lookup_func_nocheck global (to_sym "before_eval")))
    (if f (= expr (runcode f expr)))
    (var v (runcode_with_self self (lookup_func global Eval) expr))
    (var g (lookup_func_nocheck global (to_sym "after_eval")))
    (if g (= v (runcode g v)))
    (return v)
    ))

(fun eval (expr) (
    (return (runcode (lookup_func global Eval) expr))
    ))

(fun eval_with_self (self expr) (
    (return (runcode_with_self self (lookup_func global Eval) expr))
    ))

(fun interpret (p) (
    (while 1 (do
        (parse_toplevel p)
        (if (! (parse_success p)) (do
            (if (end_of_file p) break)
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))
        (evalfull (parsed_token p))
        ))
    ))

(fun interpret_shell (p) (
    (var outputs (ary_new))
    (evalfull (apply (slot (slot (to_sym "syntax") (to_sym "shell")) (to_sym "enable_shell_syntax")) 0))
    (set_slot global (to_sym "shell_outputs") outputs)
    (ary_push outputs @C_NIL)
    (while 1 (do
        (try 
            (while 1 (do
                (parse_shell p)
                (if (! (parse_success p)) (do
                    (output_syntax_error (get_loc p) (parser_error p))
                    (flush_parser p)
                    continue
                    ))
                (var ret (evalfull (parsed_token p)))
                (print_result ret)
                (ary_store outputs (box 0) ret)
                (ary_push outputs ret)
                (increment_line p)
                ))
        (catch e (do
            (output_string stderr "Error: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (flush_parser p)
        )))))
    ))

(fun print_result (val) (
    (output_string stdout "=> ")
    (pprint stdout val)
    (output_char stdout '\n')
    ))

(fun builtin_eval (expr) (
    (var hd (node_head expr))
    (if (== hd Located) (do
        (set_loc (node_arg expr 0))
        (return (eval (node_arg expr 1)))
        )
    (if (== hd Block) (do
        (var list (node_arg_list expr 0))
        (enter_module (to_unique_sym "Block"))
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (exit_module)
        (return v)
        )
    (if (== hd Seq) (do
        (var list (node_arg_list expr 0))
        (var v @C_NIL)
        (while list (do
            (= v (eval (car list)))
            (= list (cdr list))
            ))
        (return v)
        ))))
    (return (runcode (compile_main expr)))
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(fun exit_ (status) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit (unbox status))
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return @C_NIL)
    ))

(fun is_already_imported (list file) (
    (if (!= (node_type list) @ListE)
        (throw (type_error (string "List") list))
        )
    (while list (do
        (if (streq file (car list))
            (return @TRUE)
            )
        (= list (cdr list))
        ))
    (return @FALSE)
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (set_slot amber (to_sym "ARGV") ARGV)
    (if (== argc 0) return)
    (for i 0 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(fun new_dir (dirs path) (
    (for i 0 (array_size dirs) (do
        (if (streq (tuple_at (array_at dirs i) 0) path)
            (return @FALSE)
            )
        ))
    (return @TRUE)
    ))

(fun load_file (path) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (var loaded (get_slot amber (to_sym "ALREADY_LOADED")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (if (!= (node_type loaded) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (do
            ; multiple load check.
            (var rpath (realpath fullpath))
            (if (! rpath)
                (throw (io_error1 (string "Failed to get absolute path") fullpath)))

            (for i 0 (array_size loaded) (do
                (if (streq (ary_at loaded (box i)) rpath)
                    (return @C_FALSE)
                    )
                ))
            (var fd (open "."))
            (if (< fd 0) (throw (io_error (string "Can not open '.'"))))

            (ary_push loaded rpath)

            (var ichan (open_in rpath @FALSE))
            (if (! ichan) (throw (io_error1 (string "Open failed") fullpath)))
            (var dir (get_directory rpath))
            (var new_dir_p (new_dir dirs dir))
            (if new_dir_p (ary_push dirs (tuple2 (string dir) global)))
            (if (< (chdir dir) 0)
                (throw (io_error (string
                    (strcat "Failed to change directory to " dir)))))

            (var p (make_parser fullpath ichan))
            (set_loc (get_loc p))

            (var save_shell_mode_p (in_shell_mode))
            (unset_shell_mode)
            (interpret p)
            (if save_shell_mode_p (set_shell_mode))

            (if new_dir_p (ary_pop dirs))
            (if (< (fchdir fd) 0)
                (throw (io_error (string "Failed to change directory to '.'"))))
            (if (< (close fd) 0)
                (throw (io_error (string "Failed to close '.'")))
                )
            (close_in ichan)
            (return @C_TRUE)
            ))
        ))
    (throw (not_found (string path)))
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(fun loadable (path) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (var loaded (get_slot amber (to_sym "ALREADY_LOADED")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (if (!= (node_type loaded) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (return @C_TRUE))
        ))
    (return @C_FALSE)
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(fun find_parent (sym) (
    (var dirs (get_slot amber (to_sym "AMBER_PATH")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (rfor i 0 (array_size dirs) (do
        (var t (ary_at dirs (box i)))
        (var dir (tuple_at t 0))
        (var mod (tuple_at t 1))
        (if (!= (node_type dir) @StringE) (goto load_error))
        (var fullpath (strcat (strcat dir "/") 
            (strcat (symbol_name sym) ".ab")))
        (if (file_exists fullpath) (return mod))
        ))
    (return 0)
    (label load_error)
    (throw (logic_error1 (string "AMBER_PATH must be an array of strings") dirs))
    ))

(export fun create_module (sym) (
    (if (&& (!= (node_head global) Module) (!= global @C_NIL))
        (throw (invalid_argument
            "1st argument of create_module(sym@Symbol)"
            sym
            ))
        )
    (var mod (make_object1 Module sym))
    (set_slot mod parent global)
    (return mod)
    ))

(fun enter_module (sym) (
    (if (!= (symtable_depth variables) 0)
        (throw (logic_error (string "enter_module() can be called only in top-scope"))))
    (var mod (get_slot_nocheck global sym))
    (if (== mod @C_NIL) (do
        (var p (find_parent sym))
        (if (! p) (= p global))
        (= mod (make_object1 Module sym))
        (set_slot p sym mod)
        (set_slot mod parent p)
        ))
    
    (var stack module_stack)
    (while stack (do
        (if (== mod (car stack))
            (throw (exception2 (string "Recursive dependency") global mod)))
        (= stack (cdr stack))
        ))
    (= module_stack (cons global module_stack))
    (= global mod)
    (return mod)
    ))

(fun exit_module () (
    (if (! module_stack)
        (throw (logic_error (string "Can not exit from global-module"))))
    (var mod (car module_stack))
    (= global mod)
    (= module_stack (cdr module_stack))
    (return mod)
    ))

(export fun load_global (sym) (
    (return (get_slot_nocheck global sym))
    ))

(fun copy_variable (to sym1 from sym2) (
    (var f (get_slot_nocheck from (to_sym sym2)))
    (if (== f @C_NIL)
        (throw (not_found (to_sym sym2)))
        )
    (set_slot to (to_sym sym1) f)
    ))

(fun define_variable (sym val) (
    (return (set_slot global sym val))
    ))

(fun define_variable_fusion (sym val _) (
    (return (set_slot_fusion global sym val))
    ))

(fun setup_minimal_interpreter (prim) (
    ; parser
    (var syntax (create_module Syntax))
    (set_slot global Syntax syntax)
    (set_slot syntax parent global)
    
    (copy_variable syntax "word" prim "parse_word")
    (copy_variable syntax "text" prim "parse_text")
    (copy_variable syntax "any" prim "parse_any")
    (copy_variable syntax "spaces" prim "parse_spaces")
    (copy_variable syntax "comment" prim "parse_comment")
    (copy_variable syntax "decimal" prim "parse_decimal")
    (copy_variable syntax "binary" prim "parse_binary")
    (copy_variable syntax "octal" prim "parse_octal")
    (copy_variable syntax "hex" prim "parse_hex")
    (copy_variable syntax "integer" prim "parse_integer")
    (copy_variable syntax "float" prim "parse_float")
    (copy_variable syntax "string" prim "parse_string")
    (copy_variable syntax "symbol" prim "parse_symbol")
    (copy_variable syntax "symbol_without_mark" prim "parse_symbol_without_mark")
    (copy_variable syntax "reserved_symbol" prim "parse_reserved_symbol")
    (copy_variable syntax "atom" prim "parse_atom")
    (copy_variable syntax "fullform" prim "parse_fullform")
    (copy_variable syntax "expr" prim "parse_expr")
    (copy_variable syntax "stmt" prim "parse_stmt")

    ; evaluator
    (add_function1 prim Eval DontCare builtin_eval 0)
    (add_function2 prim (to_sym "eval_with_self") DontCare DontCare eval_with_self 0)
    (add_function1 prim (to_sym "eval_full") DontCare evalfull 0)
    (add_function2 prim (to_sym "eval_with_self_full") DontCare DontCare evalfull_with_self 0)

    (add_function1 prim (to_sym "exit") intT exit_ 0)
    (add_function1 prim (to_sym "atexit") funT at_exit 0)
    (add_function1 prim (to_sym "load") stringT load_file 0)
    (add_function1 prim (to_sym "loadable?") stringT loadable 0)
    (add_function1 prim (to_sym "create_module") symT create_module 0)
    (add_function1 prim (to_sym "enter_module") symT enter_module 0)
    (add_function0 prim (to_sym "exit_module") exit_module 0)
    (add_function2 prim (to_sym "define_variable") symT DontCare define_variable 0)
    (add_function3 prim (to_sym "define_variable") symT DontCare (quote (to_sym "fusion")) define_variable_fusion 0)
    (add_function1 prim (to_sym "debugpf") DontCare debugpf 0)

    ; important functions
    (copy_variable global "compile" prim "compile")
    (copy_variable global "eval" prim "eval")

    (define_variable (to_sym "PROMPT") (string "amber"))
    ))

(extern fun setup_pprint)
(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_encoding)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_random)
(extern fun setup_math)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_tuple)
(extern fun setup_array)
(extern fun setup_table)
;(extern fun setup_gc)

(fun init_lib (mod) (
    (setup_base mod)
    (setup_pprint mod)
    (setup_object mod)
    (setup_encoding mod)
    (setup_symbol mod)
    (setup_math mod)
    (setup_numeric mod)
    (setup_string mod)
    (setup_bigint mod)
    (setup_float mod)
    (setup_random mod)
    (setup_io mod)
    (setup_list mod)
    (setup_tuple mod)
    (setup_array mod)
    (setup_table mod)
;    (setup_gc)
    ))

    ))
