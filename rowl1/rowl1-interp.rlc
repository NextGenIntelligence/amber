;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2011-01-10 14:59:40 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-parse")
(import "rowl1-symtable")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-matching")

(var funtable (make_symtable))
(var vartable (make_symtable))

(export fun add_function (sym args code) (
    (var depth (symtable_depth funtable))
    (var arity (list_length args))
    (var ent (symtable_find funtable sym arity))
    (if (&& ent (== depth (field_get ent 3)))
        (do
            (field_set ent 2 (cons (cons args code) (field_get ent 2)))
            (compile_matching_hook ent arity)
        )
        (do
            (var pats (cons (cons args code) 0))
            (var ent  (tuple 3 (bytecode 0 0 0 0) sym pats depth))
            (compile_matching_hook ent arity)
            (symtable_add funtable sym arity ent)
            (register_symbol sym (to_sym "%function"))
        )
        )
    ))

(fun setup_pat (pat) (
    (if pat
        (return (make_expr HeadP (list2 DontCare pat)))
        (return DontCare)
        )
    ))

(export fun add_builtin_function1 (sym pat func) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func @TRUE)
    (var code (get_code asm))
    (= pat (setup_pat pat))
    (add_function sym (list1 pat) code)
    ))

(export fun add_builtin_function2 (sym pat1 pat2 func) (
    (var asm (make_assembler))
    (compile_simple_function asm 2 func @TRUE)
    (var code (get_code asm))
    (= pat1 (setup_pat pat1))
    (= pat2 (setup_pat pat2))
    (add_function sym (list2 pat1 pat2) code)
    ))

(export fun add_builtin_function3 (sym pat1 pat2 pat3 func) (
    (var asm (make_assembler))
    (compile_simple_function asm 3 func @TRUE)
    (var code (get_code asm))
    (= pat1 (setup_pat pat1))
    (= pat2 (setup_pat pat2))
    (= pat3 (setup_pat pat3))
    (add_function sym (list3 pat1 pat2 pat3) code)
    ))

(export fun add_builtin_function4 (sym pat1 pat2 pat3 pat4 func) (
    (var asm (make_assembler))
    (compile_simple_function asm 4 func @TRUE)
    (var code (get_code asm))
    (= pat1 (setup_pat pat1))
    (= pat2 (setup_pat pat2))
    (= pat3 (setup_pat pat3))
    (= pat4 (setup_pat pat4))
    (add_function sym (list4 pat1 pat2 pat3 pat4) code)
    ))

(export var current_loc null)
(export fun set_loc (loc) (
    (= current_loc loc)
    ))

(export fun interpret () (
    (= current_loc no_loc)
    (while 1 (do
        (var e (parse))
        (if (! e) break)
        (call_eval (rewrite_expr e))
        ))
    ))

(fun call_eval (expr) (
    (var f (lookup_func Eval 1))
    (return (jitcall f expr))
    ))

(export fun call1 (sym arg) (
    (var f (lookup_func sym 1))
    (return (jitcall f arg))
    ))

(export fun lookup_func (sym arity) (
    (var ent (symtable_find funtable sym arity))
    (if (! ent) (do
        (= ent (tuple 3 (undefined_error_hook sym arity) (to_sym "undefined_error") 0
            (symtable_depth funtable)))
        (symtable_add funtable sym arity ent)
        ))
    (return (field_get ent 0))
    ))

(fun undefined_error (sym arity) (
    (output_error stderr)
    (output_string stderr "no definition of `")
    (output_symbol stderr sym)
    (output_string stderr "' whose arity is ")
    (output_int stderr (unbox arity))
    (output_string stderr "\n")
    (exit 1)
    ))

(fun undefined_error_hook (sym arity) (
    (var asm (make_assembler))
    (put_push asm (box arity))
    (put_push asm sym)
    (compile_simple_call asm 2 undefined_error)
    (put_ireturn asm)
    (return (get_code asm))
    ))

(export fun builtin_eval (expr) (
    (var asm (make_assembler))
    (compile_expression asm expr @TRUE)
    (return (jitcall (get_code asm)))
    ))

(export fun builtin_eval_located (expr) (
    (set_loc (expr_arg expr 0))
    (var ret (call_eval (expr_arg expr 1)))
    (return ret)
    ))

(extern fun add_infix)
(extern fun add_prefix)
(extern fun add_postfix)
(extern fun add_constr)
(extern fun add_command)
(export fun builtin_eval_syntax_sugar (expr) (
    (var head (expr_arg_symbol expr 0))
    (var op   (expr_arg expr 1))
    (if (== (node_type op) @Expr) (do
        (var type (expr_head op))
        (if (|| (== type InfixL) (== type InfixR))
            (return (add_infix head op))
        (if (== type Prefix)
            (return (add_prefix head op))
        (if (== type Postfix)
            (return (add_postfix head op))
        (if (== type Constr)
            (return (add_constr head op))
        (if (== type Command)
            (return (add_command head op)))))))
        ))
    (output_error stderr)
    (output_string stderr "invalid syntax specifier `")
    (pretty_print stderr op)
    (output_string stderr "'\n")
    (exit 1)
    ))

(export fun builtin_import (file) (
    ; XXX: should not hard code the path of libraries
    (var script_path (build_path "/usr/lib/rowl/" file ".rl"))
    (if (! (file_exists script_path)) (do
        (output_error stderr)
        (output_string stderr "package `")
        (output_string stderr file)
        (output_string stderr "' was not found\n")
        (exit 1)
        ))
    (var ichan (open_in script_path))
    (push_parser script_path ichan)
    (interpret)
    (pop_parser)
    (close_in ichan)
    (return Nil)
    ))

(export fun builtin_pretty_print (expr) (
    (pretty_print stdout expr)
    (output_char stdout '\n')
    (return Nil)
    ))

(export fun builtin_eval_syntax_sugar_pp (expr) (
    (pretty_print stdout expr)
    (output_char stdout '\n')
    (return (builtin_eval_syntax_sugar expr))
    ))

(fun check_arg_size (name size expr) (
    (if (!= (expr_size expr) size) (do
	(output_error stderr)
	(output_string stderr name)
	(output_string stderr " requires just ")
	(output_int stderr size)
	(output_string stderr " argument")
	(if (> size 1) (output_char stderr 's'))
	(output_char stderr '\n')
	(exit 1)
	))
    ))

(fun rewrite_expr (expr) (
    (var ty (node_type expr))
    (if (== ty @Expr) (do
        (var args (expr_args expr))
        (while args (do
            (setcar args (rewrite_expr (car args)))
            (= args (cdr args))
            ))
        )
    (if (== ty @ListE) (do
        (var vals expr)
        (while vals (do
            (setcar vals (rewrite_expr (car vals)))
            (= vals (cdr vals))
            ))
        )))
    (var f (lookup_func Rewrite 1))
    (var e (jitcall f expr))
    (while (!= e expr) (do
        (= expr e)
        (= e (jitcall f expr))
        ))
    (return e)
    ))

(export fun builtin_rewrite (expr) (
    (return expr)
    ))

(export fun builtin_define_function (expr) (
    (check_arg_size (symbol_name DefineFunction) 2 expr)
    (var lhs (expr_arg expr 0))
    (var body (expr_arg expr 1))
    (var sym (expr_arg_symbol lhs 0))
    (var args (expr_arg_list lhs 1))
    (var compiled (compile_function sym args body))
    (add_function sym (car compiled) (cdr compiled))
    (return Nil)
    ))

    ))
