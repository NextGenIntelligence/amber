;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2010-11-26 05:31:52 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; XXX: experimental implementation

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-assemble")
(import "rowl1-compile")
(import "rowl1-matching")

(var funtable (make_symtable))
(var vartable (make_symtable))

(export fun add_function (sym args code) (
    (var depth (symtable_depth funtable))
    (var arity (list_length args))
    (var ent (symtable_find funtable sym arity))
    (if (&& ent (== depth (field_get ent 2)))
        (do
            (var pats (cons (cons args code) (cdr ent)))
            (field_set ent 1 pats)
            (field_set ent 0 (compile_matching_hook ent arity))
        )
        (do
            (var pats (cons (cons args code) 0))
            (var ent  (tuple 2 (bytecode 0 0 0 0) pats depth))
            (field_set ent 0 (compile_matching_hook ent arity))
            (symtable_add funtable sym arity ent)
            (register_symbol sym GlobalFunctionSym)
        )
        )
    ))

(export fun add_builtin_function (sym arity func) (
    (var asm (make_assembler 10))
    (compile_simple_function asm arity func @TRUE)
    (var code (get_code asm))
    (var pats 0)
    (while (> arity 0) (do
        (= pats (cons AnySym pats))
        (decr arity)
        ))
    (add_function sym pats code)
    ))

(export fun interpret (prog) (
    (check_type "interpret" @List prog)

    (var list (field_get prog @ListValues))
    (while list (do
        (builtin_eval (car list))
        (= list (cdr list))
        ))
    ))

(fun builtin_eval (expr) (
    (if (! expr) (error "builtin_eval: null expression"))
    (var type (node_type expr))
    (tswitch type (
    (@Symbol  . (return (builtin_eval_symbol expr)))
    (@List    . (return (builtin_eval_list expr)))
    (@Tuple   . (not_implemented "builtin_eval"))
    (@Array   . (not_implemented "builtin_eval"))
    (@Node    . (not_implemented "builtin_eval"))
    (@Prefix  . (not_implemented "builtin_eval"))
    (@Postfix . (not_implemented "builtin_eval"))
    (@Infix   . (return (builtin_eval_infix expr)))
    (@Call    . (return (builtin_eval_call expr)))
    (@Subscr  . (not_implemented "builtin_eval"))
    (@Int     . (return expr))
    (@Float   . (return expr))
    (@String  . (return expr))
    (default  . (not_reachable "builtin_eval"))
        ))
    ))

(fun builtin_eval_symbol (sym) (
    (var value (symtable_find vartable sym 0))
    (if value (return value) (return sym))
    ))

(fun builtin_eval_list (expr) (
    (var list (field_get expr @ListValues))
    (symtable_push funtable)
    (while list (do
        (setcar list (builtin_eval (car list)))
        (= list (cdr list))
        ))
    (symtable_pop funtable)
    (return expr)
    ))

(fun builtin_eval_infix (expr) (
    (var op (field_get expr @InfixOp))
    (if (== op DeclOp) (return (builtin_eval_decl expr)))

    (var asm (make_assembler 10))
    (compile_expression asm expr @TRUE)
    (return (jitcall (get_code asm)))

    (undefined_expression (field_get expr 1))
    ))

(fun builtin_eval_decl (expr) (
    (if (== (node_type (field_get expr @InfixLhs)) @Call)
        (return (builtin_eval_fundecl expr))
        )
    (undefined_expression (field_get expr 1))
    ))

(fun builtin_eval_fundecl (expr) (
    (var lhs (field_get expr @InfixLhs))
    (var rhs (field_get expr @InfixRhs))
    (var name (field_get lhs @CallFunc))
    (var args (field_get lhs @CallArgs))
    (if (!= (node_type name) @Symbol) (undefined_expression (field_get expr 1)))

    (var ret (compile_function (field_get expr 1) name args rhs)) ; (argpat . body)
    (add_function name (car ret) (cdr ret))
    ))

(export fun lookup_func (sym arity) (
    (check_type "lookup_func" @Symbol sym)
    (var ent (symtable_find funtable sym arity))
    (if (! ent) (do
        (= ent (tuple 2 (gen_no_declaration_error sym) 0 (symtable_depth funtable)))
        (symtable_add funtable sym arity ent)
        ))
    (return (field_get ent 0))
    ))

(fun builtin_eval_call (expr) (
    (var func (field_get expr @CallFunc))
    (var args (field_get expr @CallArgs))
    (= func (builtin_eval func))

    (var arity 0)
    (var argv (array object 7))
    (while args (do
        (array_set object argv arity (builtin_eval (car args)))
        (= args (cdr args))
        (+= arity 1)
        ))

    (var f (lookup_func func arity))

    (tswitch arity (
    (0 . (return (jitcall f)))
    (1 . (return (jitcall f (array_get object argv 0))))
    (2 . (return (jitcall f (array_get object argv 0) (array_get object argv 1))))
    (3 . (return (jitcall f (array_get object argv 0) (array_get object argv 1) (array_get object argv 2))))
    (4 . (return (jitcall f (array_get object argv 0) (array_get object argv 1) (array_get object argv 2) (array_get object argv 3))))
    (5 . (return (jitcall f (array_get object argv 0) (array_get object argv 1) (array_get object argv 2) (array_get object argv 3) (array_get object argv 4))))
    (6 . (return (jitcall f (array_get object argv 0) (array_get object argv 1) (array_get object argv 2) (array_get object argv 3) (array_get object argv 4) (array_get object argv 5))))
    (7 . (return (jitcall f (array_get object argv 0) (array_get object argv 1) (array_get object argv 2) (array_get object argv 3) (array_get object argv 4) (array_get object argv 5) (array_get object argv 6))))
    (default . (not_implemented "builtin_eval_call"))
        ))
    ))

(fun undefined_expression (loc) (
    (flush stdout)
    (error_head stderr loc)
    (output_string stderr "undefined expression\n")
    (exit 1)
    ))

(fun no_declaration_error (name) (
    (flush stdout)
    (output_string stderr "ERROR: no declaration of ")
    (output_string stderr name)
    (exit 1)
    ))

(fun gen_no_declaration_error (sym) (
    (var asm (make_assembler 10))
    (put_push asm (field_get sym @SymbolName))
    (compile_simple_call asm 1 no_declaration_error @FALSE)
    (return (get_code asm))
    ))

    ))
