;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-interp.rlc 2014-01-28 00:25:15 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-error")
(import "rowl1-object")
(import "rowl1-symtable")
(import "rowl1-compile")
(import "rowl1-packrat")
(import "rowl1-pprint")

(export var amber null)
(export var global null)
(export var builtin null)
(export var variables null)
(export var current_loc null)

(extern fun ary_new)
(extern fun ary_at)
(extern fun ary_store)
(extern fun ary_push)
(extern fun ary_size)

(export fun set_loc (loc) (
    (= current_loc loc)
    (store_variable global (to_sym "LOCATION") loc)
    ))

(export fun eval_shell () (
    (set_shell_mode)
    (try
        (return (eval_main "amber" stdin 0 0))
        (catch e (do
            (= global amber)
            (output_string stderr "Uncaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (return 1)
        )))
    ))

(export fun eval_file (path argc argv) (
    (var r 0)
    (var ichan (open_in path))
    (try
        (= r (eval_main path ichan argc argv))
        (catch e (do
            (= global amber)
            (output_string stderr "Unaught exception: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (= r 1)
        )))
    (close_in ichan)
    (return r)
    ))

(fun eval_main (file ichan argc argv) (
    (= current_loc no_loc)

    ; Local variable table
    (= variables (make_symtable 10))

    ; Global Module
    (= global @C_UNDEF)
    (= amber (create_module Amber))
    (store_variable amber Amber amber)
    (= global amber)

    ; Primitive Module
    (= builtin (create_module Primitive)) ; Primitive functions
    (store_variable global Primitive builtin)

    ; Setup built-in objects and functions.
    (setup_argv argc argv)
    (setup_global)
    (setup_builtin_compilers builtin)
    (init_lib builtin)
    (init_parser_funcs builtin) 

    ; Boot Amber
    (set_loc no_loc)
    (var load_path (ary_new)) 
    (store_variable amber (to_sym "LOADPATH") load_path)
    (ary_push load_path (string "/usr/lib/amber"))
    (ary_push load_path (string "."))
    (setup_minimal_interpreter builtin)
    (load_file "Boot.ab")

    ;; Boot Amber
    ;(load_file "Boot.ab")
    ;(load_file "Syntax.ab")
    ;(load_file "Module.ab")
    ;(load_file "Object.ab")

    ;;(load_file "Syntax.ab")

    ;;(import_lib "amber/syntax.ab")
    ;;(import_lib "std/string.ab")
    ;;(import_lib "std/numeric.ab")
    ;;(import_lib "std/format.ab")
    ;;(import_lib "std/list.ab")
    ;;(import_lib "std/array.ab")
    ;;(import_lib "std/table.ab")
    ;;(import_lib "std/io/io.ab")

    ;(add_load_dir (get_directory file))
    ;(add_load_dir (get_env "PWD"))

    ;(var p (make_parser file ichan))

    ;(if (in_shell_mode)
    ;    (interpret_shell p)
    ;    (do
    ;        (var fd (open "."))
    ;        (var dir (get_directory file))
    ;        (chdir dir)
    ;        (interpret p)
    ;        (fchdir fd)
    ;    )
    ;    )
    (eval_exit @C_NIL)

    (return 0)
    ))

(fun eval (expr) (
    (return (runcode (lookup_func global Eval) expr))
    ))

(fun rewrite (expr) (
    (var new_expr (runcode (lookup_func (get_slot global Syntax) Rewrite) expr))
    (if (!= new_expr expr) (return (rewrite new_expr)))
    (= expr new_expr)
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (rewrite_qquote (node_arg expr 0) 0))
        (return expr)
        ))

    ; Don't rewrite patterns but rewrite guard expressions
    (if (== hd Define) (do
        (var lhs (node_arg expr 0))
        (if (== (node_head lhs) Apply) (do
            (var guard (node_arg lhs 1))
            (if (== (node_head guard) When)
                (node_arg_set guard 1 (rewrite (node_arg guard 1)))
                )
            ))
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (node_arg expr 0))
        (if (== (node_bhead lhs) When)
            (node_arg_set lhs 1 (rewrite (node_arg lhs 1)))
            )
        (node_arg_set expr 1 (rewrite (node_arg expr 1)))
        (return expr)
        ))

    (for i 0 (node_size expr) (do
        (node_arg_set expr i (rewrite (node_arg expr i)))
        ))
    (return expr)
    ))

(fun rewrite_qquote (expr level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (rewrite_qquote (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0)
            (node_arg_set expr 0 (rewrite (node_arg expr 0)))
            (node_arg_set expr 0
                (rewrite_qquote (node_arg expr 0) (- level 1)))
            )
        (return expr)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))

    (for i 0 (node_size expr)
        (node_arg_set expr i
            (rewrite_qquote (node_arg expr i) level))
        )
    (return expr)
    ))

(fun interpret (p) (
    (while 1 (do
        (parse_toplevel p)
        (if (! (parse_success p)) (do
            (if (end_of_file p) break)
            (output_syntax_error (get_loc p) (parser_error p))
            (exit 1)
            ))
        (eval (parsed_token p))
        ))
    (= current_loc no_loc)
    ))

(fun interpret_shell (p) (
    (var outputs (ary_new))
    (eval (apply (slot (slot (to_sym "Syntax") (to_sym "Shell")) (to_sym "enable_shell_syntax")) 0))
    (store_variable global (to_sym "shell_outputs") outputs)
    (ary_push outputs @C_UNDEF)
    (while 1 (do
        (try 
            (while 1 (do
                (parse_shell p)
                (if (! (parse_success p)) (do
                    (output_syntax_error (get_loc p) (parser_error p))
                    (flush_parser p @TRUE)
                    continue
                    ))
                (var ret (eval (parsed_token p)))
                (print_result ret)
                (ary_store outputs (box 0) ret)
                (ary_push outputs ret)
                (increment_line p)
                ))
        (catch e (do
            (output_string stderr "Error: ")
            (pprint stderr e)
            (output_string stderr "\n")
            (flush_parser p @TRUE)
        )))))
    ))

(fun print_result (val) (
    (output_string stdout "=> ")
    (pprint stdout val)
    (output_char stdout '\n')
    ))

(fun builtin_eval (expr) (
    (if (== (node_head expr) Located) (do
        (set_loc (node_arg expr 0))
        (return (eval (node_arg expr 1)))
        ))
    (return (runcode (compile_main expr)))
    ))

(fun default_eval (expr) (
    (return (runcode (compile_main (rewrite expr))))
    ))

(fun eval_located (expr) (
    (set_loc (node_arg expr 0))
    (return (eval (node_arg expr 1)))
    ))

(fun rewrite_donothing (expr) ((return expr)))

(fun rewrite_located (expr) (
    (node_arg_set expr 1 (rewrite (node_arg expr 1)))
    (return expr)
    ))

(fun eval_seq (expr) (
    (var stmts (node_arg expr 0))
    (var v @C_NIL)
    (while stmts (do
        (= v (eval (car stmts)))
        (= stmts (cdr stmts))
        ))
    (return v)
    ))

(var atexit_list null)

(fun eval_exit (expr) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit 0)
    ))

(fun exit_ (status) (
    (= atexit_list (list_reverse atexit_list))
    (while atexit_list (do
        (runcode (get_bytecode (car atexit_list)))
        (= atexit_list (cdr atexit_list))
        ))
    (exit (unbox status))
    ))

(export fun at_exit (fun) (
    (= atexit_list (cons fun atexit_list))
    (return @C_NIL)
    ))

(fun is_already_imported (list file) (
    (if (!= (node_type list) @ListE)
        (throw (type_error current_loc (string "List") list))
        )
    (while list (do
        (if (streq file (car list))
            (return @TRUE)
            )
        (= list (cdr list))
        ))
    (return @FALSE)
    ))

(fun setup_argv (argc argv) (
    (var ARGV (ary_new))
    (store_variable amber (to_sym "ARGV") ARGV)
    (if (== argc 0) return)
    (for i 1 argc (do
        (ary_push ARGV (string (array_get string argv i)))
        ))
    ))

(fun load_file (path) (
    (var dirs (get_slot amber (to_sym "LOADPATH")))
    (if (!= (node_type dirs) @ArrayE) (goto load_error))
    (for i 0 (unbox (ary_size dirs)) (do
        (var dir (ary_at dirs i))
        (if (!= (node_type dir) @StringE) (goto load_error))

        (var fullpath (strcat (strcat dir "/") path))
        (if (file_exists fullpath) (do
            (var ichan (open_in fullpath))
            (var fd (open "."))
            (var dir (get_directory fullpath))
            (chdir dir)

            (var p (make_parser fullpath ichan))
            (set_loc (get_loc p))

            (var save_shell_mode_p (in_shell_mode))
            (unset_shell_mode)
            (interpret p)
            (if save_shell_mode_p (set_shell_mode))

            (fchdir fd)
            (close_in ichan)

            (set_loc no_loc)
            (return @C_NIL)
            ))
        ))
    (throw (not_found current_loc (string path)))

    (label load_error)
    (throw (logic_error1 current_loc
        (string "LOADPATH must be an array of strings")
        dirs))
    ))

(fun enter_module (mod) (
    (if (!= (symtable_depth variables) 0)
        (throw (logic_error current_loc
            (string "enter_module() can be called only in top-scope")))
        )
    (if (!= (get_slot mod proto) global)
        (throw (logic_error current_loc
            (string "The argument of enter_module() must be direct submodule of global-module")))
        )
    (= global mod)
    (return mod)
    ))

(fun exit_module () (
    (var mod (get_slot global proto))
    (if (!= (node_bhead mod) Module)
        (throw (type_error current_loc (string "Module") mod))
        )
    (= global mod)
    (return mod)
    ))

(export fun load_global (sym) (
    (return (get_slot global sym))
    ))

(fun setup_global () (
    ;(store_variable amber (to_sym "LOCATION") current_loc)
    ;(store_variable amber (to_sym "PROMPT") (string "amber"))
    ;(if (in_shell_mode)
    ;    (store_variable amber (to_sym "shell_mode") @C_TRUE)
    ;    (store_variable amber (to_sym "shell_mode") @C_FALSE)
    ;    )

    ))

(fun setup_global_methods () (
    ;(var syntax (get_slot global Syntax)) 
    ;(add_function1 syntax Rewrite DontCare rewrite_donothing 0)
    ;(add_function1 syntax Rewrite (domainP Located) rewrite_located 0)
    ;(add_function1 global Eval DontCare default_eval 0)
    ;(add_function1 global Eval (domainP Located) eval_located 0)
    ;(add_function1 global Eval (make_object1 Import listT) eval_import 0)

    ;(add_function1 global Eval (make_object1 Seq listT) eval_seq 0)

    ;(add_function1 global Eval (quote (to_sym "exit")) eval_exit 0)

    ;(add_function1 global (to_sym "exit") intT exit_ 0)
    ;(add_function1 global (to_sym "atexit") funT at_exit 0)
    ))

(fun copy_variable (to sym1 from sym2) (
    (var f (get_slot from (to_sym sym2)))
    (if (== f @C_UNDEF)
        (throw (not_found current_loc (to_sym sym2)))
        )
    (store_variable to (to_sym sym1) f)
    ))

(fun setup_minimal_interpreter (builtin) (
    ; parser
    (var syntax (create_module Syntax))
    (store_variable global Syntax syntax)
    (store_variable syntax proto global)
    
    (copy_variable syntax "text" builtin "parse_text")
    (copy_variable syntax "any" builtin "parse_any")
    (copy_variable syntax "blank" builtin "parse_blank")
    (copy_variable syntax "spaces" builtin "parse_spaces")
    (copy_variable syntax "comment" builtin "parse_comment")
    (copy_variable syntax "decimal" builtin "parse_decimal")
    (copy_variable syntax "binary" builtin "parse_binary")
    (copy_variable syntax "octal" builtin "parse_octal")
    (copy_variable syntax "hex" builtin "parse_hex")
    (copy_variable syntax "integer" builtin "parse_integer")
    (copy_variable syntax "float" builtin "parse_float")
    (copy_variable syntax "string" builtin "parse_string")
    (copy_variable syntax "string_d" builtin "parse_string_d")
    (copy_variable syntax "string_s" builtin "parse_string_s")
    (copy_variable syntax "symbol" builtin "parse_symbol")
    (copy_variable syntax "atom" builtin "parse_atom")
    (copy_variable syntax "fullform" builtin "parse_fullform")
    (copy_variable syntax "expr" builtin "parse_expr")
    (copy_variable syntax "stmt" builtin "parse_stmt")

    ; compiler
    (copy_variable global "compile" builtin "compile")

    ; evaluator
    (add_function1 builtin Eval DontCare builtin_eval 0)
    (add_function1 builtin (to_sym "load") stringT load_file 0)
    (add_function1 builtin (to_sym "create_module") symT create_module 0)
    (add_function1 builtin (to_sym "enter_module") (domainP Module) enter_module 0)
    (add_function0 builtin (to_sym "exit_module") exit_module 0)

    (copy_variable global "eval" builtin "eval")
    (copy_variable global "load" builtin "load")

    ; important functions
    (copy_variable global "equal" builtin "equal")
    (copy_variable global "identical" builtin "identical")
    (copy_variable global "fusion" builtin "fusion_function")
    (copy_variable global "create_module" builtin "create_module")
    (copy_variable global "enter_module" builtin "enter_module")
    (copy_variable global "exit_module" builtin "exit_module")
    ))

(extern fun setup_pprint)
(extern fun setup_base)
(extern fun setup_symbol)
(extern fun setup_numeric)
(extern fun setup_bigint)
(extern fun setup_float)
(extern fun setup_random)
(extern fun setup_math)
(extern fun setup_string)
(extern fun setup_io)
(extern fun setup_list)
(extern fun setup_tuple)
(extern fun setup_array)
(extern fun setup_table)
;(extern fun setup_gc)

(fun init_lib (mod) (
    (setup_base mod)
    ;(setup_pprint mod)
    ;(setup_symbol mod)
    ;(setup_object mod)

    ;(setup_math mod)
    (setup_numeric mod)
    (setup_string mod)
    ;(setup_bigint mod)
    ;(setup_float mod)
    ;(setup_random mod)
    (setup_io mod)
    ;(setup_list mod)
    ;(setup_tuple mod)
    ;(setup_array mod)
    ;(setup_table mod)
;    (setup_gc)
    ))

    ))
