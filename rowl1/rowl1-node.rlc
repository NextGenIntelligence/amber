;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2013-03-16 17:23:29 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

(extern object current_loc)

; symbol table (symbols are globally unique)
(var symbol_table (init_symbol_table (make_idtable)))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var DontCare    (to_sym "_"))

(export var Symbol      (to_sym "Symbol"))
(export var Int         (to_sym "Int"))
(export var Float       (to_sym "Float"))
(export var String      (to_sym "String"))
(export var Loc         (to_sym "Loc"))
(export var List        (to_sym "List"))
(export var Array       (to_sym "Array"))
(export var Table       (to_sym "Table"))
(export var Tuple       (to_sym "Tuple"))
(export var Range       (to_sym "Range"))

(export var Slot        (to_sym "Slot"))

(export var Block       (to_sym "Block"))
(export var Breakable   (to_sym "BreakableBlock"))
(export var Apply       (to_sym "Apply"))
(export var Subscript   (to_sym "Subscript"))
(export var Located     (to_sym "Located"))
(export var Domain      (to_sym "Domain"))
(export var When        (to_sym "When"))
(export var Ellipsis    (to_sym "Ellipsis"))
(export var Quote       (to_sym "Quote"))
(export var QuasiQuote  (to_sym "QuasiQuote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var IfElse      (to_sym "IfElse"))
(export var While       (to_sym "While"))
(export var For         (to_sym "For"))
(export var RevFor      (to_sym "RevFor"))
(export var Break       (to_sym "Break"))
(export var Continue    (to_sym "Continue"))
(export var Not         (to_sym "Not"))
(export var SeqAnd      (to_sym "SeqAnd"))
(export var SeqOr       (to_sym "SeqOr"))
(export var Equal       (to_sym "Equal"))
(export var NotEqual    (to_sym "NotEqual"))

(export var MakeObject  (to_sym "MakeObject"))

(export var FieldRef  (to_sym "%FieldRef")) ; only for internal use

(export var Import        (to_sym "Import"))
(export var Open          (to_sym "Open"))
(export var DefSyntax     (to_sym "DefineSyntax"))
(export var RepSyntax     (to_sym "ReplaceSyntax"))
(export var ReserveSymbol (to_sym "ReserveSymbol"))
(export var DefVariable   (to_sym "DefineVariable"))
(export var DefFunction   (to_sym "DefineFunction"))
(export var BeginModule   (to_sym "BeginModule"))
(export var EndModule     (to_sym "EndModule"))

(export var Qualified   (to_sym "Qualified"))
(export var Assign      (to_sym "Assign"))
(export var Lambda      (to_sym "Lambda"))
(export var Fusion      (to_sym "Fusion"))
(export var Delegate    (to_sym "Delegate"))
(export var Return      (to_sym "Return"))
(export var Try         (to_sym "Try"))
(export var Throw       (to_sym "Throw"))
(export var Seq         (to_sym "Seq"))

(export var Exception        (to_sym "Exception"))

(export var Eval        (to_sym "eval"))
(export var Compile     (to_sym "compile"))
(export var Rewrite     (to_sym "rewrite"))

; for parser
(export var Parser (to_builtin_sym "Parser"))

(export var OneOf      (to_sym "OneOf"))
(export var NoneOf     (to_sym "NoneOf"))
(export var Option     (to_sym "Option"))
(export var Choice     (to_sym "Choice"))
(export var Many       (to_sym "Many"))
(export var Many1      (to_sym "Many1"))
(export var And        (to_sym "And"))
; Amber's original syntax elements
(export var ParseWith  (to_sym "ParseWith"))
(export var Aligned    (to_sym "Aligned"))
(export var Delimited  (to_sym "Delimited"))
(export var Delimited1 (to_sym "Delimited1"))
(export var Delimited2 (to_sym "Delimited2"))
(export var NoSpace    (to_sym "NoSpace"))

(export var Some   (to_sym "Some"))

; internal nodes
(export var ModuleVariable (to_sym "ModuleVariable"))
(export var LocalVariable  (to_sym "LocalVariable"))
(export var Arity          (to_sym "Arity"))
(export var Argument       (to_sym "Argument"))
(export var ListAt         (to_sym "ListAt"))
(export var ListFrom       (to_sym "ListFrom"))
(export var TupleAt        (to_sym "TupleAt"))
(export var ArrayAt        (to_sym "ArrayAt"))
(export var RestOf         (to_sym "RestOf"))

(export var Assembler        (to_builtin_sym "Assembler"))
(export var Builtin          (to_builtin_sym "Builtin"))
(export var Bytecode         (to_builtin_sym "Bytecode"))
(export var Function         (to_builtin_sym "Function"))
(export var Closure          (to_builtin_sym "Closure"))
(export var InputFileStream  (to_builtin_sym "InputFileStream"))
(export var OutputFileStream (to_builtin_sym "OutputFileStream"))
(export var StringIO         (to_builtin_sym "StringIO"))
(export var Module           (to_builtin_sym "Module"))

(export var Syntax    (to_sym "Syntax"))
(export var Std       (to_sym "Std"))

; Builtin headers
(export var BSymbol (to_builtin_sym "Symbol"))
(export var BInt    (to_builtin_sym "Int"))
(export var BString (to_builtin_sym "String"))
(export var BBigInt (to_builtin_sym "BigInt"))
(export var BFloat  (to_builtin_sym "Float"))
(export var BTable  (to_builtin_sym "Table"))

(extern fun exception)
(extern fun out_of_range)
(extern fun type_error)

(fun init_symbol_table (tbl) (
    (idtable_add tbl (strdup "nil") @C_NIL)
    (idtable_add tbl (strdup "true") @C_TRUE)
    (idtable_add tbl (strdup "false") @C_FALSE)
    (idtable_add tbl (strdup "undef") @C_UNDEF)
    (return tbl)
    ))

(export fun to_builtin_sym (name) (
    (= name (strdup name))
    (var sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(extern fun is_letter)
(extern fun is_identchar)
(extern fun invalid_argument)
(export fun to_sym_user (name) (
    (var len (strlen name))
    (if (! len) (goto to_sym_error))
    (if (! (is_letter (array_get char name 0))) (goto to_sym_error))
    (for i 1 len (do
        (if (! (is_identchar (array_get char name i))) (goto to_sym_error))
        ))
    (return (to_sym name))
    (label to_sym_error)
    (throw (invalid_argument current_loc
        (string "invalid identifier string")
        name
        ))
    ))

(export fun unique_sym () (
    (return (gensym "x"))
    ))

(export fun gensym (name) (
    (return (to_sym (strcat name (itos symbol_index_gen))))
    ))

(export fun is_hidden_sym (sym) (
    (if (is_special sym) (return @FALSE))
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (if (is_special sym) (do
        (if (== sym @C_NIL) (return (string "nil")))
        (if (== sym @C_TRUE) (return (string "true")))
        (if (== sym @C_FALSE) (return (string "false")))
        (return (string "undef"))
        ))
    (return (field_get sym @SymbolName))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (if (is_special obj) (return @SymbolE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_EXPR) (return @ExprE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (if (== tag @TAG_BIGINT) (return @BigIntE))
    (if (== tag @TAG_SEQUENCE) (do
        (if (== (get_sequence_tag obj) @SEQ_TUPLE) (return @TupleE))
        (if (== (get_sequence_tag obj) @SEQ_ARRAY) (return @ArrayE))
        ))
    (return @BuiltinE)
    ))

(export fun is_symbol (obj) (
    (if (== (node_type obj) @SymbolE) (return @TRUE) (return @FALSE))
    ))
(export fun is_int (obj) (
    (if (& obj 1) (return @TRUE) (return @FALSE))
    ))
(export fun is_bigint (obj) (
    (if (== (node_type obj) @BigIntE) (return @TRUE) (return @FALSE))
    ))
(export fun is_string (obj) (
    (if (== (node_type obj) @StringE) (return @TRUE) (return @FALSE))
    ))
(export fun is_float (obj) (
    (if (== (node_type obj) @FloatE) (return @TRUE) (return @FALSE))
    ))
(export fun is_list (obj) (
    (if (== (node_type obj) @ListE) (return @TRUE) (return @FALSE))
    ))
(export fun is_tuple (obj) (
    (if (== (node_type obj) @TupleE) (return @TRUE) (return @FALSE))
    ))
(export fun is_array (obj) (
    (if (== (node_type obj) @ArrayE) (return @TRUE) (return @FALSE))
    ))
(export fun is_table (obj) (
    (if (== (node_type obj) @TableE) (return @TRUE) (return @FALSE))
    ))
(export fun is_expr (obj) (
    (if (== (node_type obj) @ExprE) (return @TRUE) (return @FALSE))
    ))
(export fun is_function (obj) (
    (var ty (node_type obj))
    (if (|| (== ty @FunctionE)
        (|| (== ty @BoundFunctionE)
            (== ty @DelegateFunctionE)))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun is_atom_type (ty) (
    (if (|| (== ty @ExprE) (|| (== ty @ListE) (|| (== ty @TupleE) (== ty @ArrayE))))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom (obj) (
    (return (is_atom_type (node_type obj)))
    ))

(export var no_loc (make_loc (string "<internal>") 0 0 0 0))

(export fun make_loc (file bl bc el ec) (
    (return (variant @LocE 1 file bl bc el ec))
    ))

(export fun loc_file   (loc) ((return (field_get loc 1))))
(export fun loc_beginL (loc) ((return (field_get loc 2))))
(export fun loc_beginC (loc) ((return (field_get loc 3))))
(export fun loc_endL   (loc) ((return (field_get loc 4))))
(export fun loc_endC   (loc) ((return (field_get loc 5))))

(export fun merge_loc (loc1 loc2) (
    (var el (loc_endL loc2))
    (var ec (loc_endC loc2))
    (field_set loc1 4 el)
    (field_set loc1 5 ec)
    (return loc1)
    ))

(export fun pp_loc (ochan loc) (
    (output_char ochan '[')
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_beginL loc))
    (var end   (loc_endL loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ']')
    ))

(export fun node_head (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return Symbol))
        (@ExprE             . (return (field_get node 0)))
        (@ListE             . (return List))
        (@ArrayE            . (return Array))
        (@TableE            . (return Table))
        (@AssemblerE        . (return (to_sym "Assembler")))
        (@BytecodeE         . (return (to_sym "Bytecode")))
        (@FunctionE         . (return (to_sym "Function")))
        (@BoundFunctionE    . (return (to_sym "Function")))
        (@DelegateFunctionE . (return (to_sym "Function")))
        (@InputFileStreamE  . (return (to_sym "InputFileStream")))
        (@OutputFileStreamE . (return (to_sym "OutputFileStream")))
        (@ModuleE           . (return (to_sym "Module")))
        (@ParserE           . (return (to_sym "Parser")))
        (@StringIOE         . (return (to_sym "StringIO")))
        (@BigIntE           . (return Int))
        (@LocE              . (return Loc))
        (@TupleE            . (return Tuple))
        (@IntE              . (return Int))
        (@StringE           . (return String))
        (@FloatE            . (return Float))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "node_head"))
        ))
    ))

(export fun node_bhead (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return BSymbol))
        (@ExprE             . (return (field_get node 0)))
        (@ListE             . (return List))
        (@ArrayE            . (return Array))
        (@TableE            . (return BTable))
        (@AssemblerE        . (return Assembler))
        (@BytecodeE         . (return Bytecode))
        (@FunctionE         . (return Function))
        (@BoundFunctionE    . (return Function))
        (@DelegateFunctionE . (return Function))
        (@InputFileStreamE  . (return InputFileStream))
        (@OutputFileStreamE . (return OutputFileStream))
        (@ModuleE           . (return Module))
        (@ParserE           . (return Parser))
        (@StringIOE         . (return StringIO))
        (@BigIntE           . (return BBigInt))
        (@LocE              . (return Loc))
        (@TupleE            . (return Tuple))
        (@IntE              . (return BInt))
        (@StringE           . (return BString))
        (@FloatE            . (return BFloat))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "node_head"))
        ))
    ))

; number of arguments
(extern fun array_size)
(export fun node_size (expr) (
    (if (is_atom expr) (return 1))
    (if (is_list expr) (return (list_len expr)))
    (if (is_tuple expr) (return (seq_size expr)))
    (if (is_array expr) (return (array_size expr)))
    (return (expr_size expr))
    ))

(extern fun tuple_to_list)
(extern fun ary_to_list)
(export fun node_args (expr) (
    (if (is_atom expr) (return 0))
    (if (is_list expr) (return expr))
    (if (is_tuple expr) (return (tuple_to_list expr)))
    (if (is_array expr) (return (ary_to_list expr)))
    (var args 0)
    (rfor i 0 (node_size expr)
        (= args (cons (node_arg expr i) args))
        )
    (return args)
    ))

(extern fun tuple_restof)
(extern fun array_restof)
(export fun node_restof (expr i) (
    (if (is_atom expr)
        (throw (out_of_range current_loc expr (box i)))
        )
    (if (is_list expr) (do
        (for j 0 i (= expr (cdr expr)))
        (return expr)
        ))
    (if (is_tuple expr) (return (tuple_restof expr i)))
    (if (is_array expr) (return (array_restof expr i)))
    (var args 0)
    (rfor j i (node_size expr)
        (= args (cons (node_arg expr j) args))
        )
    (return args)
    ))

(extern fun list_at_check)
(extern fun tuple_at)
(extern fun array_at)
(export fun node_arg (expr idx) (
    (if (is_atom expr) 
        (throw (out_of_range current_loc expr (box idx)))
        )
    (if (is_list expr)  (return (list_at_check expr idx)))
    (if (is_tuple expr) (return (tuple_at expr idx)))
    (if (is_array expr) (return (array_at expr idx)))

    (if (>= idx (expr_size expr))
        (throw (out_of_range current_loc expr (box idx))))
    (return (array_get object expr (+ idx 1)))
    ))

(export fun check_type (arg type) (
    (if (!= (node_type arg) type)
        (throw (type_error current_loc (type_string type arg) arg))
        )
    ))

(fun node_arg_check (expr type idx) (
    (var arg (node_arg expr idx))
    (check_type arg type)
    (return arg)
    ))

(export fun node_arg_int (expr idx) (
    (var v (node_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun node_arg_symbol (expr idx) (
    (return (node_arg_check expr @SymbolE idx))
    ))

(export fun node_arg_string (expr idx) (
    (return (node_arg_check expr @StringE idx))
    ))

(export fun node_arg_list (expr idx) (
    (return (node_arg_check expr @ListE idx))
    ))

(extern fun list_store_check)
(extern fun tuple_store)
(extern fun array_store)
(export fun node_arg_set (expr idx val) (
    (if (is_atom expr)
        (throw (invalid_argument current_loc
        (string "Can't modify fields of builtin object") expr)))
    (if (is_list expr)  (return (list_store_check expr idx val)))
    (if (is_tuple expr) (return (tuple_store expr idx val)))
    (if (is_array expr) (return (array_store expr idx val)))
    (var n (expr_size expr))
    (if (>= idx n) (throw (out_of_range current_loc expr (box idx))))
    (array_set object expr (+ idx 1) val)
    ))

(export fun make_object0 (head) (
    (var e (allocate_expr 0))
    (field_set e 0 head)
    (return e)
    ))

(export fun make_object1 (head a) (
    (var e (allocate_expr 1))
    (field_set e 0 head)
    (field_set e 1 a)
    (return e)
    ))

(export fun make_object2 (head a b) (
    (var e (allocate_expr 2))
    (field_set e 0 head)
    (field_set e 1 a)
    (field_set e 2 b)
    (return e)
    ))

(export fun make_object3 (head a b c) (
    (var e (allocate_expr 3))
    (field_set e 0 head)
    (field_set e 1 a)
    (field_set e 2 b)
    (field_set e 3 c)
    (return e)
    ))

(export fun make_object4 (head a b c d) (
    (var e (allocate_expr 4))
    (field_set e 0 head)
    (field_set e 1 a)
    (field_set e 2 b)
    (field_set e 3 c)
    (field_set e 4 d)
    (return e)
    ))

(export fun make_object5 (head a b c d e) (
    (var e (allocate_expr 5))
    (field_set e 0 head)
    (field_set e 1 a)
    (field_set e 2 b)
    (field_set e 3 c)
    (field_set e 4 d)
    (field_set e 5 e)
    (return e)
    ))

(extern fun list_to_tuple)
(extern fun list_to_ary)
(export fun make_object (head args) (
    (if (!= (node_type head) @SymbolE)
        (throw (exception current_loc (string "the 1st argument of MakeObject must be a Symbol")))
        )
    (if (!= (node_type args) @ListE)
        (throw (exception current_loc (string "the 2nd argument of MakeObject must be a List")))
        )

    (if (is_hidden_sym head)
        (throw (make_object Exception (list2
            (string "Can not create builtin object")
            head)))
        )

    ; following three objects uses special data structure
    (if (== head List)  (return args))
    (if (== head Tuple) (return (list_to_tuple args)))
    (if (== head Array) (return (list_to_ary args)))

    (var size (list_len args))
    (var expr (allocate_expr size))
    (field_set expr 0 head)
    (for i 1 (+ size 1) (do
        (array_set object expr i (car args))
        (= args (cdr args))
        ))
    (return expr)
    ))

(export fun qualified (outer inner) (
    (return (make_object2 Qualified (to_sym outer) inner))
    ))

(export fun located (loc expr) (
    (return (make_object2 Located loc expr))
    ))

(export fun quote (expr) (
    (return (make_object1 Quote expr))
    ))

(export fun qquote (expr) (
    (return (make_object1 QuasiQuote expr))
    ))

(export fun unquote (expr) (
    (return (make_object1 Unquote expr))
    ))

(export fun mknot (e) (
    (return (make_object1 Not e))
    ))

(export fun ifelse (cnd then else) (
    (return (make_object3 IfElse cnd then else))
	))

(export fun mkif (cnd then) (
    (return (make_object2 If cnd then))
	))

(export fun apply (fun args) (
    (return (make_object2 Apply fun args))
    ))

(export fun block (stmts) (
    (return (make_object1 Block stmts))
    ))

(export fun seq (stmts) (
    (return (make_object1 Seq stmts))
    ))

(export fun breakable (stmts) (
    (return (make_object1 Breakable stmts))
    ))

(export fun lambda (args body) (
    (return (make_object2 Lambda args body))
    ))

(export fun assign (v arg) (
    (return (make_object2 Assign v arg))
    ))

(export fun mkreturn (v) (
    (return (make_object1 Return v))
    ))

(export fun defvar (v arg) (
    (return (make_object2 DefVariable v arg))
    ))

; patterns
(export fun domainP (sym) (
    (return (make_object2 Domain DontCare sym))
    ))

(export fun output_symbol (ochan sym) (
    (if (is_special sym) (do
        (if (== sym @C_NIL) (return (output_string ochan "nil")))
        (if (== sym @C_TRUE) (return (output_string ochan "true")))
        (if (== sym @C_FALSE) (return (output_string ochan "false")))
        (return (output_string ochan "undef"))
        ))
    (output_string ochan (field_get sym @SymbolName))
    ))

; types
(export var symT       (domainP BSymbol))
(export var stringT    (domainP BString))
(export var intT       (domainP BInt))
(export var bintT      (domainP BBigInt))
(export var floatT     (domainP BFloat))
(export var tableT     (domainP BTable))

(export var listT      (domainP List))
(export var arrayT     (domainP Array))
(export var tupleT     (domainP Tuple))
(export var funT       (domainP Function))
(export var irangeT    (make_object2 Range intT intT))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (umod idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun type_string (type node) (
    (tswitch type (
        (@SymbolE           . (return (string "Symbol")))
        (@ExprE             . (return (string "composite expression")))
        (@ListE             . (return (string "List")))
        (@ArrayE            . (return (string "Array")))
        (@TableE            . (return (string "Table")))
        (@AssemblerE        . (return (string "Assembler")))
        (@BytecodeE         . (return (string "Bytecode")))
        (@FunctionE         . (return (string "Function")))
        (@BoundFunctionE    . (return (string "Function")))
        (@DelegateFunctionE . (return (string "Function")))
        (@InputFileStreamE  . (return (string "InputFileStream")))
        (@OutputFileStreamE . (return (string "OutputFileStream")))
        (@ModuleE           . (return (string "Module")))
        (@ParserE           . (return (string "Parser")))
        (@StringIOE         . (return (string "StringIO")))
        (@BigIntE           . (return (string "BigInt")))
        (@LocE              . (return (string "Loc")))
        (@TupleE            . (return (string "Tuple")))
        (@IntE              . (return (string "Int")))
        (@StringE           . (return (string "String")))
        (@FloatE            . (return (string "Float")))
        (@BuiltinE          . (return (string "Builtin")))
        (default            . (not_reachable "output_type"))
        ))
    ))

    ))
