;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2011-01-10 15:02:53 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var operator_table (make_symtable))

; builtin expression headers and types
(export var DontCare    (to_sym "_"))
(export var Nil         (to_sym "nil"))
(export var Symbol      (to_sym "Symbol"))
(export var Int         (to_sym "Int"))
(export var Float       (to_sym "Float"))
(export var String      (to_sym "String"))
(export var Tuple       (to_sym "Tuple"))
(export var List        (to_sym "List"))
(export var Block       (to_sym "Block"))
(export var Apply       (to_sym "Apply"))
(export var Subscr      (to_sym "Subscr"))
(export var Located     (to_sym "Located"))
(export var Loc         (to_sym "Loc"))
(export var Prefix      (to_sym "Prefix"))
(export var Postfix     (to_sym "Postfix"))
(export var InfixL      (to_sym "InfixL"))
(export var InfixR      (to_sym "InfixR"))
(export var Constr      (to_sym "Constr"))
(export var Command     (to_sym "Command"))
(export var HeadP       (to_sym "HeadP"))
(export var SymbolP     (to_sym "SymbolP"))
(export var Eval        (to_sym "Eval"))
(export var Rewrite     (to_sym "Rewrite"))
(export var Quote       (to_sym "Quote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var While       (to_sym "While"))
(export var DefineFunction (to_sym "DefineFunction"))
(export var DefineSyntax   (to_sym "DefineSyntax"))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (return (+ (get_plain_tag obj) @BUILTIN_TYPE_OFFSET))
    ))

(fun is_atom (ty) (
    (if (|| (== ty @Expr) (== ty @ListE))
        (return @FALSE)
        (return @TRUE)
        )
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var builtin_loc (make_loc "<builtin>" 0 0))
(export var no_loc (make_loc "<unknown>" 0 0))

(export fun make_loc (file begin end) (
    (return (make_expr Loc (list3 file (box begin) (box end))))
    ))

(fun loc_file  (loc) ((return (car (field_get loc @ExprArgs)))))
(fun loc_begin (loc) ((return (unbox (cadr (field_get loc @ExprArgs))))))
(fun loc_end   (loc) ((return (unbox (caddr (field_get loc @ExprArgs))))))

(export fun merge_loc (loc1 loc2) (
    (var begin (loc_begin loc1))
    (var end   (loc_end loc2))
    (if (== begin end) (return loc1))
    (return (make_loc (loc_file loc1) begin end))
    ))

(export fun output_loc (ochan loc) (
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_begin loc))
    (var end   (loc_end loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ' ')
    ))

(extern object current_loc)
(export fun output_error (ochan) (
    (flush stdout)
    (output_char ochan '\n')
    (output_loc ochan current_loc)
    (output_string ochan "ERROR: ")
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE . (return Symbol))
        (@Expr    . (return (field_get node @ExprHead)))
        (@ListE   . (return List))
        (@IntE    . (return Int))
        (@FloatE  . (return Float))
        (@StringE . (return String))
        (default  . (not_reachable "expr_head"))
        ))
    ))

(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (if (! args) (not_reachable "expr_arg"))
        (= args (cdr args))
        (decr idx)
        ))
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type) (do
        (output_error stderr)
        (output_string stderr "the ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be ")
        (output_type stderr type)
        (output_string stderr "\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_head (expr head idx) (
    (var arg (expr_arg expr idx))
    (if (!= (expr_head arg) head) (do
        (output_error stderr)
        (output_string stderr "the head of ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be `")
        (pretty_print stderr head)
        (output_string stderr "'\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_size (expr) (
    (return (list_length (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @Expr 2 head args))
    ))

(export fun make_located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun register_operator (head op) (
    (symtable_add operator_table head 0 op)
    ))

(fun find_operator (head) (
    (return (symtable_find operator_table head 0))

    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (% idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun output_type (ochan type) (
    (tswitch type (
        (@SymbolE . (return (output_string ochan "Symbol")))
        (@Expr    . (return (output_string ochan "composite expression")))
        (@ListE   . (return (output_string ochan "List")))
        (@IntE    . (return (output_string ochan "Int")))
        (@FloatE  . (return (output_string ochan "Float")))
        (@StringE . (return (output_string ochan "String")))
        (default  . (not_reachable "output_type"))
        ))
    ))

(export fun pretty_print (ochan node) (
    (pretty_print_main ochan node @ASSOC_MAX)
    ))

(fun pretty_print_main (ochan node assoc) (
    (tswitch (node_type node) (
        (@SymbolE . (return (output_symbol ochan node)))
        (@Expr    . (return (pp_expr ochan node assoc)))
        (@ListE   . (return (pp_list ochan node)))
        (@IntE    . (return (pp_int ochan node)))
        (@FloatE  . (return (pp_float ochan node)))
        (@StringE . (return (pp_string ochan node)))
        (default  . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr (ochan node assoc) (
    (var head (expr_head node))
    (var args (expr_args node))

    (if (== head Tuple) (return (pp_tuple ochan args)))
    (if (== head Block)   (return (pp_block ochan args)))
    (if (&& (== head Apply) (== (node_type (cadr args)) @ListE))
        (return (pp_apply ochan args assoc)))
    (if (&& (== head Subscr) (== (node_type (cadr args)) @ListE))
        (return (pp_subscr ochan args assoc)))
    (if (== head Located) (return (pretty_print_main ochan (expr_arg node 1) assoc)))

    (var op (find_operator head))
    (if op (return (pp_operational_form ochan op args assoc)))
    (output_symbol ochan head)
    (output_char ochan '{')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_operational_form (ochan op args assoc) (
    (var ophead (expr_head op))
    (if (== ophead Prefix)  (return (pp_prefix ochan op args assoc)))
    (if (== ophead Postfix) (return (pp_postfix ochan op args assoc)))
    (if (== ophead InfixL)  (return (pp_infix ochan op args @TRUE assoc)))
    (if (== ophead InfixR)  (return (pp_infix ochan op args @FALSE assoc)))
    (if (== ophead Constr)  (return (pp_constr ochan op args)))
    (if (== ophead Command) (return (pp_command ochan op args)))
    (not_reachable "pp_operational_form")
    ))

(fun is_sign_operator (name) (
    (var c (array_get char name 0))
    (if (&& (<= 'a' c) (<= c 'z')) (return @FALSE))
    (if (&& (<= 'A' c) (<= c 'Z')) (return @FALSE))
    (if (== c '_') (return @FALSE))
    (return @TRUE)
    ))

(fun pp_prefix (ochan op args outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (output_string ochan repr)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (pretty_print_main ochan (car args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_postfix (ochan op args outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (pretty_print_main ochan (car args) assoc)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (output_string ochan repr)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_infix (ochan op args is_left outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (var need_space @FALSE)
    (if (> assoc outer_assoc) (output_char ochan '('))
    (if (! (is_sign_operator repr)) (= need_space @TRUE))
    (pretty_print_main ochan (car args) assoc)
    (if need_space (output_char ochan ' '))
    (output_string ochan repr)
    (if need_space (output_char ochan ' '))
    (pretty_print_main ochan (cadr args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_constr (ochan op args) (
    (var repr (expr_arg op 0))
    (output_string ochan repr)
    (if (&& args (! (is_sign_operator repr))) (output_char ochan ' '))
    (while args (do
        (var e (car args))
        (pretty_print_main ochan e @ASSOC_PRIMARY)
        (= args (cdr args))
        (if args (output_char ochan ' '))
        ))
    ))

(fun pp_command (ochan op args) (
    (var repr (expr_arg op 0))
    (output_string ochan repr)
    (if args (do
        (if (! (is_sign_operator repr)) (output_char ochan ' '))
        (pretty_print ochan (car args))
        ))
    ))

(fun pp_tuple (ochan args) (
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(var indent 0)
(fun incr_indent () ((+= indent 4)))
(fun decr_indent () ((-= indent 4)))

(fun pp_block (ochan args) (
    (output_string ochan "{\n")
    (incr_indent)
    (while args (do
        (for i 0 indent (output_char ochan ' '))
        (pretty_print ochan (car args))
        (output_char ochan '\n')
        (= args (cdr args))
        ))
    (decr_indent)
    (output_char ochan '}')
    ))

(fun pp_apply (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_subscr (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_float (ochan node) (
    (not_implemented "pp_float")
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

    ))
