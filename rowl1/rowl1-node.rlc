;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2011-10-05 00:56:34 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

; symbol table (symbols are globally unique)
(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var Nil         0)
(export var DontCare    (to_sym "_"))

(export var true        (to_sym "true"))
(export var false       (to_sym "false"))

(export var Symbol      (to_builtin_sym "Symbol"))
(export var Int         (to_builtin_sym "Int"))
(export var Float       (to_builtin_sym "Float"))
(export var String      (to_builtin_sym "String"))
(export var List        (to_builtin_sym "List"))
(export var Tuple       (to_sym "Tuple"))
(export var Eval        (to_sym "Eval"))
(export var Block       (to_sym "Block"))
(export var Apply       (to_sym "Apply"))
(export var Subscr      (to_sym "Subscr"))
(export var Located     (to_sym "Located"))
(export var Loc         (to_sym "Loc"))
(export var Prefix      (to_sym "Prefix"))
(export var Postfix     (to_sym "Postfix"))
(export var InfixL      (to_sym "InfixL"))
(export var InfixR      (to_sym "InfixR"))
(export var Constr      (to_sym "Constr"))
(export var Command     (to_sym "Command"))
(export var HeadP       (to_sym "HeadP"))
(export var SymbolP     (to_sym "SymbolP"))
(export var Compile     (to_sym "Compile"))
(export var Quote       (to_sym "Quote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var Else        (to_sym "Else"))
(export var While       (to_sym "While"))
(export var Not         (to_sym "Not"))
(export var LogicalAnd  (to_sym "LogicalAnd"))
(export var LogicalOr   (to_sym "LogicalOr"))

(export var DefineSyntax   (to_sym "DefineSyntax"))
(export var DefineFunction (to_sym "DefineFunction"))
(export var AppendFunction (to_sym "AppendFunction"))
(export var DefineVariable (to_sym "DefineVariable"))

(export var Function    (to_sym "Function")) ; Function{code, defs}
(export var Assembler   (to_builtin_sym "Assembler"))
(export var Environment (to_builtin_sym "Environment"))
(export var Bytecode    (to_builtin_sym "Bytecode"))
(export var Builtin     (to_builtin_sym "Builtin"))

(fun to_builtin_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(fun is_builtin_sym (sym) (
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (return @BuiltinE)
    ))

(fun is_atom (ty) (
    (if (|| (== ty @ExprE) (== ty @ListE))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom_type (obj) (
    (return (is_atom (node_type obj)))
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var no_loc (make_loc (string "<internal>") 0 0))

(export fun make_loc (file begin end) (
    (return (make_expr Loc (list3 file (box begin) (box end))))
    ))

(fun loc_file  (loc) ((return (car (field_get loc @ExprArgs)))))
(fun loc_begin (loc) ((return (unbox (cadr (field_get loc @ExprArgs))))))
(fun loc_end   (loc) ((return (unbox (caddr (field_get loc @ExprArgs))))))

(export fun merge_loc (loc1 loc2) (
    (var begin (loc_begin loc1))
    (var end   (loc_end loc2))
    (if (== begin end) (return loc1))
    (return (make_loc (loc_file loc1) begin end))
    ))

(export fun output_loc (ochan loc) (
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_begin loc))
    (var end   (loc_end loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ' ')
    ))

(extern object current_loc)
(export fun output_error (ochan) (
    (flush stdout)
    (output_loc ochan current_loc)
    (output_string ochan "ERROR: ")
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE      . (return Symbol))
        (@ExprE        . (return (field_get node @ExprHead)))
        (@ListE        . (return List))
        (@AssemblerE   . (return Assembler))
        (@EnvironmentE . (return Environment))
        (@BytecodeE    . (return Bytecode))
        (@IntE         . (return Int))
        (@FloatE       . (return Float))
        (@StringE      . (return String))
        (@BuiltinE     . (return Builtin))
        (default       . (not_reachable "expr_head"))
        ))
    ))

(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (if (! args) (not_reachable "expr_arg"))
        (= args (cdr args))
        (decr idx)
        ))
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type) (do
        (output_error stderr)
        (output_string stderr "the ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be ")
        (output_type stderr type)
        (output_string stderr "\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_head (expr head idx) (
    (var arg (expr_arg expr idx))
    (if (!= (expr_head arg) head) (do
        (output_error stderr)
        (output_string stderr "the head of ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be `")
        (pretty_print stderr head)
        (output_string stderr "'\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_set (expr idx val) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (= args (cdr args))
        (decr idx)
        ))
    (setcar args val)
    ))

(export fun expr_size (expr) (
    (return (list_length (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @ExprE 2 head args))
    ))

(export fun make_expr_user (head args) (
    (if (is_builtin_sym head) (do
        (output_error stderr)
        (output_string stderr "can not create builtin object: ")
        (pretty_print stderr head)
        (output_string stderr "{..}\n")
        (exit 1)
        ))
    (return (variant @ExprE 2 head args))
    ))

(export fun make_located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

; patterns
(export fun headP (sym) (
    (return (make_expr HeadP (list2 DontCare sym)))
    ))

(export fun symbolP (sym) (
    (return (make_expr SymbolP (list1 sym)))
    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

(var operator_table (make_symtable))

(export fun register_operator (head op) (
    (symtable_add operator_table head 0 op)
    ))

(fun find_operator (head) (
    (return (symtable_find operator_table head 0))

    ))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (% idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun output_type (ochan type) (
    (tswitch type (
        (@SymbolE      . (return (output_string ochan "Symbol")))
        (@ExprE        . (return (output_string ochan "composite expression")))
        (@ListE        . (return (output_string ochan "List")))
        (@AssemblerE   . (return (output_string ochan "Assembler")))
        (@EnvironmentE . (return (output_string ochan "Environment")))
        (@BytecodeE    . (return (output_string ochan "Bytecode")))
        (@IntE         . (return (output_string ochan "Int")))
        (@FloatE       . (return (output_string ochan "Float")))
        (@StringE      . (return (output_string ochan "String")))
        (@BuiltinE     . (return (output_string ochan "Builtin")))
        (default       . (not_reachable "output_type"))
        ))
    ))

(export fun pretty_print (ochan node) (
    (pretty_print_main ochan node @ASSOC_MAX)
    ))

(fun pretty_print_main (ochan node assoc) (
    (tswitch (node_type node) (
        (@SymbolE      . (return (output_symbol ochan node)))
        (@ExprE        . (return (pp_expr ochan node assoc)))
        (@ListE        . (return (pp_list ochan node)))
        (@AssemblerE   . (return (pp_assembler ochan node)))
        (@EnvironmentE . (return (pp_environment ochan node)))
        (@BytecodeE    . (return (pp_bytecode ochan node)))
        (@IntE         . (return (pp_int ochan node)))
        (@FloatE       . (return (pp_float ochan node)))
        (@StringE      . (return (pp_string ochan node)))
        (@BuiltinE     . (return (pp_builtin ochan node)))
        (default       . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr (ochan node assoc) (
    (var head (expr_head node))
    (var args (expr_args node))

    (if (== head Block)   (return (pp_block ochan args)))
    (if (&& (== head Apply) (== (node_type (cadr args)) @ListE))
        (return (pp_apply ochan args assoc)))
    (if (&& (== head Subscr) (== (node_type (cadr args)) @ListE))
        (return (pp_subscr ochan args assoc)))
    (if (== head Located) (return (pretty_print_main ochan (expr_arg node 1) assoc)))

    (var op (find_operator head))
    (if op (return (pp_operational_form ochan op args assoc)))
    (output_symbol ochan head)
    (output_char ochan '{')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_operational_form (ochan op args assoc) (
    (var ophead (expr_head op))
    (if (== ophead Prefix)  (return (pp_prefix ochan op args assoc)))
    (if (== ophead Postfix) (return (pp_postfix ochan op args assoc)))
    (if (== ophead InfixL)  (return (pp_infix ochan op args @TRUE assoc)))
    (if (== ophead InfixR)  (return (pp_infix ochan op args @FALSE assoc)))
    (if (== ophead Constr)  (return (pp_constr ochan op args)))
    (if (== ophead Command) (return (pp_command ochan op args)))
    (not_reachable "pp_operational_form")
    ))

(fun is_sign_operator (name) (
    (var c (array_get char name 0))
    (if (&& (<= 'a' c) (<= c 'z')) (return @FALSE))
    (if (&& (<= 'A' c) (<= c 'Z')) (return @FALSE))
    (if (== c '_') (return @FALSE))
    (return @TRUE)
    ))

(fun pp_prefix (ochan op args outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (output_string ochan repr)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (pretty_print_main ochan (car args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_postfix (ochan op args outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (pretty_print_main ochan (car args) assoc)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (output_string ochan repr)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_infix (ochan op args is_left outer_assoc) (
    (var repr (expr_arg op 0))
    (var assoc (expr_arg_int op 1))
    (var need_space @FALSE)
    (if (> assoc outer_assoc) (output_char ochan '('))
    (if (! (is_sign_operator repr)) (= need_space @TRUE))
    (pretty_print_main ochan (car args) assoc)
    (if need_space (output_char ochan ' '))
    (output_string ochan repr)
    (if need_space (output_char ochan ' '))
    (pretty_print_main ochan (cadr args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_constr (ochan op args) (
    (var repr (expr_arg op 0))
    (output_string ochan repr)
    (if (&& args (! (is_sign_operator repr))) (output_char ochan ' '))
    (while args (do
        (var e (car args))
        (pretty_print_main ochan e @ASSOC_PRIMARY)
        (= args (cdr args))
        (if args (output_char ochan ' '))
        ))
    ))

(fun pp_command (ochan op args) (
    (var repr (expr_arg op 0))
    (output_string ochan repr)
    (if args (do
        (if (! (is_sign_operator repr)) (output_char ochan ' '))
        (pretty_print ochan (car args))
        ))
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_assembler (ochan expr) (
    (output_string ochan "<#Assembler:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_environment (ochan expr) (
    (output_string ochan "<#Environment:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_bytecode (ochan expr) (
    (output_string ochan "<#Bytecode:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(var indent 0)
(fun incr_indent () ((+= indent 4)))
(fun decr_indent () ((-= indent 4)))

(fun pp_block (ochan args) (
    (output_string ochan "{\n")
    (incr_indent)
    (while args (do
        (for i 0 indent (output_char ochan ' '))
        (pretty_print ochan (car args))
        (output_char ochan '\n')
        (= args (cdr args))
        ))
    (decr_indent)
    (output_char ochan '}')
    ))

(fun pp_apply (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_subscr (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_float (ochan node) (
    (not_implemented "pp_float")
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

(fun pp_builtin (ochan node) (
    (output_string ochan "<#Builtin:0x")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(export fun pretty_print_full (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE      . (return (output_symbol ochan node)))
        (@ExprE        . (return (pp_expr_full ochan node)))
        (@ListE        . (return (pp_expr_full ochan node)))
        (@AssemblerE   . (return (pp_assembler ochan node)))
        (@EnvironmentE . (return (pp_environment ochan node)))
        (@BytecodeE    . (return (pp_bytecode ochan node)))
        (@IntE         . (return (pp_int ochan node)))
        (@FloatE       . (return (pp_float ochan node)))
        (@StringE      . (return (pp_string ochan node)))
        (@BuiltinE     . (return (pp_builtin ochan node)))
        (default       . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr_full (ochan node) (
    (var hd (expr_head node))
    (var args (expr_args node))
    (output_symbol ochan hd)
    (output_char ochan '{')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

    ))
