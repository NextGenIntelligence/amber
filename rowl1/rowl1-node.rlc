;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2012-02-06 12:44:33 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

; symbol table (symbols are globally unique)
(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var Nil         null)
(export var DontCare    (to_sym "_"))

(export var true        (to_sym "true"))
(export var false       (to_sym "false"))

(export var Symbol      (to_builtin_sym "Symbol"))
(export var Int         (to_builtin_sym "Int"))
(export var Float       (to_builtin_sym "Float"))
(export var String      (to_builtin_sym "String"))
(export var List        (to_builtin_sym "List"))
(export var Tuple       (to_sym "Tuple"))
(export var Eval        (to_sym "Eval"))
(export var Block       (to_sym "Block"))
(export var Apply       (to_sym "Apply"))
(export var Subscript   (to_sym "Subscript"))
(export var Located     (to_sym "Located"))
(export var Loc         (to_sym "Loc"))
(export var Prefix      (to_sym "Prefix"))
(export var Postfix     (to_sym "Postfix"))
(export var InfixL      (to_sym "InfixL"))
(export var InfixR      (to_sym "InfixR"))
(export var Constr      (to_sym "Constr"))
(export var Command     (to_sym "Command"))
(export var Domain      (to_sym "Domain"))
(export var Where       (to_sym "Where"))
(export var Compile     (to_sym "Compile"))
(export var Quote       (to_sym "Quote"))
(export var QuasiQuote  (to_sym "QuasiQuote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var Else        (to_sym "Else"))
(export var While       (to_sym "While"))
(export var Not         (to_sym "Not"))
(export var LogicalAnd  (to_sym "LogicalAnd"))
(export var LogicalOr   (to_sym "LogicalOr"))

(export var Include        (to_sym "Include"))
(export var Import         (to_sym "Import"))
(export var DefInfixL      (to_sym "DefineInfixL"))
(export var DefInfixR      (to_sym "DefineInfixR"))
(export var DefPrefix      (to_sym "DefinePrefix"))
(export var DefPostfix     (to_sym "DefinePostfix"))
(export var DefConstr      (to_sym "DefineConstr"))
(export var DefCommand     (to_sym "DefineCommand"))
(export var DefModule      (to_sym "DefineModule"))
(export var DefineVariable (to_sym "DefineVariable"))
(export var DefineFunction (to_sym "DefineFunction"))

(export var Qualified   (to_sym "Qualified"))
(export var Rewrite     (to_sym "Rewrite"))
(export var Assign      (to_sym "Assign"))
(export var Lambda      (to_sym "Lambda"))
(export var Bind        (to_sym "Bind"))
(export var Return      (to_sym "Return"))
(export var Seq         (to_sym "Seq"))

(export var Assembler     (to_builtin_sym "Assembler"))
(export var Builtin       (to_builtin_sym "Builtin"))
(export var Bytecode      (to_builtin_sym "Bytecode"))
(export var Function      (to_builtin_sym "Function"))
(export var BoundFunction (to_builtin_sym "BoundFunction"))
(export var Closure       (to_builtin_sym "Closure"))
(export var InputFileStream (to_builtin_sym "InputFileStream"))
(export var OutputFileStream (to_builtin_sym "OutputFileStream"))
(export var Module      (to_builtin_sym "Module"))

; internal nodes
(export var ModuleVariable        (to_sym "%ModuleVariable"))
(export var LocalVariable         (to_sym "%LocalVariable"))
(export var Arity                 (to_sym "%Arity"))
(export var Argument              (to_sym "%Argument"))
(export var ListAt                (to_sym "%ListAt"))
(export var ExprAt                (to_sym "%ExprAt"))

(export fun to_builtin_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(fun is_builtin_sym (sym) (
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun qualified (outer inner) (
    (return (make_expr Qualified (list2 (to_sym outer) inner)))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (return @BuiltinE)
    ))

(fun is_atom_type (ty) (
    (if (|| (== ty @ExprE) (== ty @ListE))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom (obj) (
    (return (is_atom_type (node_type obj)))
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var no_loc (make_loc (string "<internal>") 0 0))

(export fun make_loc (file begin end) (
    (return (make_expr Loc (list3 file (box begin) (box end))))
    ))

(fun loc_file  (loc) ((return (expr_arg_string loc 0))))
(fun loc_begin (loc) ((return (expr_arg_int loc 1))))
(fun loc_end   (loc) ((return (expr_arg_int loc 2))))

(export fun merge_loc (loc1 loc2) (
    (var begin (loc_begin loc1))
    (var end   (loc_end loc2))
    (if (== begin end) (return loc1))
    (return (make_loc (loc_file loc1) begin end))
    ))

(export fun output_loc (ochan loc) (
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_begin loc))
    (var end   (loc_end loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ' ')
    ))

(extern object current_loc)
(export fun output_error (ochan loc) (
    (flush stdout)
    (output_loc ochan loc)
    (output_string ochan "ERROR: ")
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return Symbol))
        (@ExprE             . (return (field_get node @ExprHead)))
        (@ListE             . (return List))
        (@AssemblerE        . (return Assembler))
        (@BytecodeE         . (return Bytecode))
        (@FunctionE         . (return Function))
        (@BoundFunctionE    . (return BoundFunction))
        (@InputFileStreamE  . (return InputFileStream))
        (@OutputFileStreamE . (return OutputFileStream))
        (@ModuleE           . (return Module))
        (@IntE              . (return Int))
        (@FloatE            . (return Float))
        (@StringE           . (return String))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "expr_head"))
        ))
    ))

(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom_type ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (var i idx)
    (while (&& (> i 0) args) (do
        (= args (cdr args))
        (decr i)
        ))
    (if (! args) (do
        (output_error stderr current_loc)
        (output_string stderr "`")
        (pretty_print stderr expr)
        (output_string stderr "' does not have ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter\n")
        (exit 1)
        ))
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type) (do
        (output_error stderr current_loc)
        (output_string stderr "the ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be ")
        (output_type stderr type)
        (output_string stderr "\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_head (expr head idx) (
    (var arg (expr_arg expr idx))
    (if (!= (expr_head arg) head) (do
        (output_error stderr current_loc)
        (output_string stderr "the head of ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be `")
        (pretty_print stderr head)
        (output_string stderr "'\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_set (expr idx val) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr current_loc)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (= args (cdr args))
        (decr idx)
        ))
    (setcar args val)
    ))

(export fun expr_size (expr) (
    (return (list_len (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @ExprE 2 head args))
    ))

(export fun make_expr_user (head args) (
    (if (!= (node_type head) @SymbolE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 1st argument of MakeExpression must be a Symbol\n")
        (exit 1)
        ))
    (if (is_builtin_sym head) (do
        (output_error stderr current_loc)
        (output_string stderr "can not create builtin object: ")
        (pretty_print stderr head)
        (output_string stderr "{..}\n")
        (exit 1)
        ))
    (if (!= (node_type args) @ListE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 2nd argument of MakeExpression must be a List\n")
        (exit 1)
        ))

    ; special case : Tuple{x} is equal to x
    (if (&& (== head Tuple) (== (list_len args) 1))
        (return (car args))
        )
    (return (variant @ExprE 2 head args))
    ))

(export fun make_located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun quote (expr) (
    (return (make_expr Quote (list1 expr)))
    ))

(export fun qquote (expr) (
    (return (make_expr QuasiQuote (list1 expr)))
    ))

(export fun unquote (expr) (
    (return (make_expr Unquote (list1 expr)))
    ))

(export fun make_ifelse (cnd then else) (
	(return (make_expr Else (list2 (make_expr If (list2 cnd then)) else)))
	))

(export fun make_seq (e1 e2) (
    (return (make_expr Seq (list2 e1 e2)))
    ))

; patterns
(export fun domainP (sym) (
    (return (make_expr Domain (list2 DontCare sym)))
    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (% idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun output_type (ochan type) (
    (tswitch type (
        (@SymbolE           . (return (output_string ochan "Symbol")))
        (@ExprE             . (return (output_string ochan "composite expression")))
        (@ListE             . (return (output_string ochan "List")))
        (@AssemblerE        . (return (output_string ochan "Assembler")))
        (@BytecodeE         . (return (output_string ochan "Bytecode")))
        (@FunctionE         . (return (output_string ochan "Function")))
        (@BoundFunctionE    . (return (output_string ochan "BoundFunction")))
        (@InputFileStreamE  . (return (output_string ochan "InputFileStream")))
        (@OutputFileStreamE . (return (output_string ochan "OutputFileStream")))
        (@ModuleE           . (return (output_string ochan "Module")))
        (@IntE              . (return (output_string ochan "Int")))
        (@FloatE            . (return (output_string ochan "Float")))
        (@StringE           . (return (output_string ochan "String")))
        (@BuiltinE          . (return (output_string ochan "Builtin")))
        (default            . (not_reachable "output_type"))
        ))
    ))

(extern fun pp_module)

(export fun pretty_print (ochan node) (
    (pretty_print_main ochan node @ASSOC_MAX)
    ))

(fun pretty_print_main (ochan node assoc) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr ochan node assoc)))
        (@ListE             . (return (pp_list ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(extern object current_mod)
(extern fun lookup_operator_from_head)
(fun pp_expr (ochan node assoc) (
    (var head (expr_head node))
    (var args (expr_args node))

    (if (== head Block) (return (pp_block ochan args)))
    (if (&& (== head Apply) (== (node_type (cadr args)) @ListE))
        (return (pp_apply ochan args assoc)))
    (if (== head Tuple) (return (pp_tuple ochan args)))
    (if (&& (== head Subscript) (== (node_type (cadr args)) @ListE))
        (return (pp_subscr ochan args assoc)))
    (if (== head Located) (return (pretty_print_main ochan (expr_arg node 1) assoc)))

    (var op (lookup_operator_from_head current_mod head))
    (if op (return (pp_operational_form ochan op args assoc)))
    (output_symbol ochan head)
    (output_char ochan '{')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_operational_form (ochan op args assoc) (
    (var optype (field_get op 0))
    (if (== optype @OP_PREFIX)  (return (pp_prefix ochan op args assoc)))
    (if (== optype @OP_POSTFIX) (return (pp_postfix ochan op args assoc)))
    (if (== optype @OP_INFIX)   (return (pp_infix ochan op args (field_get op 3) assoc)))
    (if (== optype @OP_CONSTR)  (return (pp_constr ochan op args)))
    (if (== optype @OP_COMMAND) (return (pp_command ochan op args)))
    (not_reachable "pp_operational_form")
    ))

(fun is_sign_operator (name) (
    (var c (array_get char name 0))
    (if (&& (<= 'a' c) (<= c 'z')) (return @FALSE))
    (if (&& (<= 'A' c) (<= c 'Z')) (return @FALSE))
    (if (== c '_') (return @FALSE))
    (return @TRUE)
    ))

(fun pp_prefix (ochan op args outer_assoc) (
    (var repr (field_get op 2))
    (var assoc (field_get op 3))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (output_string ochan repr)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (pretty_print_main ochan (car args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_postfix (ochan op args outer_assoc) (
    (var repr (field_get op 2))
    (var assoc (field_get op 3))
    (if (> assoc outer_assoc) (output_char ochan '('))
    (pretty_print_main ochan (car args) assoc)
    (if (! (is_sign_operator repr)) (output_char ochan ' '))
    (output_string ochan repr)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_infix (ochan op args is_left outer_assoc) (
    (var repr (field_get op 2))
    (var assoc (field_get op 4))
    (var need_space @FALSE)
    (if (> assoc outer_assoc) (output_char ochan '('))
    (if (! (is_sign_operator repr)) (= need_space @TRUE))
    (pretty_print_main ochan (car args) assoc)
    (if need_space (output_char ochan ' '))
    (output_string ochan repr)
    (if need_space (output_char ochan ' '))
    (pretty_print_main ochan (cadr args) assoc)
    (if (> assoc outer_assoc) (output_char ochan ')'))
    ))

(fun pp_constr (ochan op args) (
    (var repr (field_get op 2))
    (output_string ochan repr)
    (if (&& args (! (is_sign_operator repr))) (output_char ochan ' '))
    (while args (do
        (var e (car args))
        (pretty_print_main ochan e @ASSOC_PRIMARY)
        (= args (cdr args))
        (if args (output_char ochan ' '))
        ))
    ))

(fun pp_command (ochan op args) (
    (var repr (field_get op 2))
    (output_string ochan repr)
    (if args (do
        (if (! (is_sign_operator repr)) (output_char ochan ' '))
        (pretty_print ochan (car args))
        ))
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_tuple (ochan args) (
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_assembler (ochan expr) (
    (output_string ochan "<#Assembler:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_bytecode (ochan expr) (
    (output_string ochan "<#Bytecode:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_function (ochan expr) (
    (output_string ochan "<#Function:0x")
    (output_hex ochan expr 8)
    (output_char ochan ':')
    (pretty_print_full ochan (field_get expr 2))
    (output_char ochan '>')
    ))

(fun pp_bound (ochan expr) (
    (output_string ochan "<#BoundFunction:")
    (output_hex ochan expr 8)
    (output_char ochan ':')
    (pretty_print_full ochan (field_get expr 2))
    (output_char ochan ',')
    (pretty_print_full ochan (field_get expr 3))
    (output_char ochan '>')
    ))

(fun pp_file_stream (ochan node) (
    (if (== (node_type node) @InputFileStreamE)
        (output_string ochan "<#InputFileStream:")
        (output_string ochan "<#OutputFileStream:")
        )
    (pretty_print ochan (field_get node 1))
    (output_char ochan '>')
    ))

(var indent 0)
(fun incr_indent () ((+= indent 4)))
(fun decr_indent () ((-= indent 4)))

(fun pp_block (ochan args) (
    (output_string ochan "{\n")
    (incr_indent)
    (while args (do
        (for i 0 indent (output_char ochan ' '))
        (pretty_print ochan (car args))
        (output_char ochan '\n')
        (= args (cdr args))
        ))
    (decr_indent)
    (output_char ochan '}')
    ))

(fun pp_apply (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_subscr (ochan args assoc) (
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan '('))
    (pretty_print_main ochan (car args) @ASSOC_SECONDARY)
    (= args (cadr args))
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    (if (< assoc @ASSOC_SECONDARY) (output_char ochan ')'))
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_float (ochan node) (
    (not_implemented "pp_float")
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

(fun pp_builtin (ochan node) (
    (output_string ochan "<#Builtin:0x")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(export fun pretty_print_full (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr_full ochan node)))
        (@ListE             . (return (pp_list_full ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr_full (ochan node) (
    (var hd (expr_head node))
    (var args (expr_args node))
    (output_symbol ochan hd)
    (output_char ochan '{')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_list_full (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(export fun debugc (c) ((output_char stderr c)))
(export fun debugs (s) ((output_string stderr s)))
(export fun debugi (i) ((output_int stderr i)))
(export fun debugx (x) ((output_hex stderr x 8)))
(export fun debugp (o) ((pretty_print stderr o) (debugc '\n')))


    ))
