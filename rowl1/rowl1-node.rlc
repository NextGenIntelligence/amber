;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2012-12-08 23:59:24 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

(extern object current_loc)

; symbol table (symbols are globally unique)
(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var DontCare    (to_sym "_"))

(export var true        (to_sym "true"))
(export var false       (to_sym "false"))
(export var nil         (to_sym "nil"))
(export var undefined   (to_sym "undefined"))

(export var Symbol      (to_builtin_sym "Symbol"))
(export var Int         (to_builtin_sym "Int"))
(export var BigInt      (to_builtin_sym "BigInt"))
(export var Float       (to_builtin_sym "Float"))
(export var String      (to_builtin_sym "String"))
(export var Loc         (to_builtin_sym "Loc"))
(export var Float       (to_sym "Float"))
(export var List        (to_sym "List"))
(export var Array       (to_sym "Array"))
(export var Table       (to_sym "Table"))
(export var Tuple       (to_sym "Tuple"))
(export var Range       (to_sym "Range"))
(export var Block       (to_sym "Block"))
(export var Apply       (to_sym "Apply"))
(export var Subscript   (to_sym "Subscript"))
(export var Located     (to_sym "Located"))
(export var Domain      (to_sym "Domain"))
(export var Where       (to_sym "Where"))
(export var Ellipsis    (to_sym "Ellipsis"))
(export var Quote       (to_sym "Quote"))
(export var QuasiQuote  (to_sym "QuasiQuote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var IfElse      (to_sym "IfElse"))
(export var While       (to_sym "While"))
(export var For         (to_sym "For"))
(export var RevFor      (to_sym "RevFor"))
(export var Break       (to_sym "Break"))
(export var Continue    (to_sym "Continue"))
(export var Not         (to_sym "Not"))
(export var SeqAnd      (to_sym "SeqAnd"))
(export var SeqOr       (to_sym "SeqOr"))
(export var Equal       (to_sym "Equal"))
(export var NotEqual    (to_sym "NotEqual"))

(export var MakeExpr  (to_sym "MakeExpr"))
(export var Head      (to_sym "Head"))
(export var Arguments (to_sym "Arguments"))

(export var FieldRef  (to_sym "%FieldRef")) ; only for internal use

(export var Import        (to_sym "Import"))
(export var Open          (to_sym "Open"))
(export var DefSyntax     (to_sym "DefineSyntax"))
(export var RepSyntax     (to_sym "ReplaceSyntax"))
(export var ReserveSymbol (to_sym "ReserveSymbol"))
(export var DefVariable   (to_sym "DefineVariable"))
(export var DefFunction   (to_sym "DefineFunction"))
(export var BeginModule   (to_sym "BeginModule"))
(export var EndModule     (to_sym "EndModule"))

(export var Dynamic     (to_sym "Dynamic"))
(export var Qualified   (to_sym "Qualified"))
(export var Assign      (to_sym "Assign"))
(export var Lambda      (to_sym "Lambda"))
(export var Bind        (to_sym "Bind"))
(export var Return      (to_sym "Return"))
(export var Try         (to_sym "Try"))
(export var Throw       (to_sym "Throw"))
(export var Seq         (to_sym "Seq"))

(export var Assembler        (to_builtin_sym "Assembler"))
(export var Builtin          (to_builtin_sym "Builtin"))
(export var Bytecode         (to_builtin_sym "Bytecode"))
(export var Function         (to_builtin_sym "Function"))
(export var Closure          (to_builtin_sym "Closure"))
(export var InputFileStream  (to_builtin_sym "InputFileStream"))
(export var OutputFileStream (to_builtin_sym "OutputFileStream"))
(export var StringIO         (to_builtin_sym "StringIO"))
(export var Module           (to_builtin_sym "Module"))

(export var Exception   (to_sym "Exception"))

(export var Eval        (to_sym "eval"))
(export var Compile     (to_sym "compile"))
(export var Rewrite     (to_sym "rewrite"))

; for parser
(export var Parser (to_builtin_sym "Parser"))

(export var OneOf      (to_sym "OneOf"))
(export var NoneOf     (to_sym "NoneOf"))
(export var Option     (to_sym "Option"))
(export var Choice     (to_sym "Choice"))
(export var Many       (to_sym "Many"))
(export var Many1      (to_sym "Many1"))
(export var And        (to_sym "And"))
; Amber's original syntax elements
(export var Scoped     (to_sym "Scoped"))
(export var Aligned    (to_sym "Aligned"))
(export var Delimited  (to_sym "Delimited"))
(export var Delimited1 (to_sym "Delimited1"))
(export var Delimited2 (to_sym "Delimited2"))
(export var NoSpace    (to_sym "NoSpace"))
(export var WithBlank  (to_sym "WithBlank"))

(export var Some   (to_sym "Some"))

; internal nodes
(export var ModuleVariable (to_sym "%ModuleVariable"))
(export var LocalVariable  (to_sym "%LocalVariable"))
(export var Label          (to_sym "%Label"))
(export var BreakLabel     (to_sym "%BreakLabel"))
(export var ContinueLabel  (to_sym "%ContinueLabel"))
(export var Arity          (to_sym "%Arity"))
(export var Argument       (to_sym "%Argument"))
(export var ListAt         (to_sym "%ListAt"))
(export var ListFrom       (to_sym "%ListFrom"))
(export var ExprAt         (to_sym "%ExprAt"))
(export var ExprFrom       (to_sym "%ExprFrom"))

(extern fun exception)
(extern fun out_of_range)
(extern fun type_error)

(export fun to_builtin_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(extern fun is_letter)
(extern fun is_identchar)
(extern fun invalid_argument)
(export fun to_sym_user (name) (
    (var len (strlen name))
    (if (! len) (goto to_sym_error))
    (if (! (is_letter (array_get char name 0))) (goto to_sym_error))
    (for i 1 len (do
        (if (! (is_identchar (array_get char name i))) (goto to_sym_error))
        ))
    (return (to_sym name))
    (label to_sym_error)
    (throw (invalid_argument current_loc
        (string "invalid identifier string")
        name
        ))
    ))

(export fun unique_sym () (
    (return (to_sym (strcat "x" (itos symbol_index_gen))))
    ))

(fun is_builtin_sym (sym) (
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun is_special_symbol (sym) (
    (return (|| (|| (|| (== sym true) (== sym false)) (== sym DontCare)) (== sym undefined)))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (if (== tag @TAG_BIGINT) (return @BigIntE))
    (return @BuiltinE)
    ))

(fun is_atom_type (ty) (
    (if (|| (== ty @ExprE) (|| (== ty @ListE) (== ty @ArrayE)))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom (obj) (
    (return (is_atom_type (node_type obj)))
    ))

(export var no_loc (make_loc (string "<internal>") 0 0 0 0))

(export fun make_loc (file bl bc el ec) (
    (return (variant @LocE 1 file bl bc el ec))
    ))

(export fun loc_file   (loc) ((return (field_get loc 1))))
(export fun loc_beginL (loc) ((return (field_get loc 2))))
(export fun loc_beginC (loc) ((return (field_get loc 3))))
(export fun loc_endL   (loc) ((return (field_get loc 4))))
(export fun loc_endC   (loc) ((return (field_get loc 5))))

(export fun merge_loc (loc1 loc2) (
    (var el (loc_endL loc2))
    (var ec (loc_endC loc2))
    (field_set loc1 4 el)
    (field_set loc1 5 ec)
    (return loc1)
    ))

(export fun pp_loc (ochan loc) (
    (output_char ochan '[')
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_beginL loc))
    (var end   (loc_endL loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ']')
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return Symbol))
        (@ExprE             . (return (field_get node @ExprHead)))
        (@ListE             . (return List))
        (@ArrayE            . (return Array))
        (@TableE            . (return Table))
        (@AssemblerE        . (return Assembler))
        (@BytecodeE         . (return Bytecode))
        (@FunctionE         . (return Function))
        (@BoundFunctionE    . (return Function))
        (@InputFileStreamE  . (return InputFileStream))
        (@OutputFileStreamE . (return OutputFileStream))
        (@ModuleE           . (return Module))
        (@ParserE           . (return Parser))
        (@StringIOE         . (return StringIO))
        (@BigIntE           . (return BigInt))
        (@LocE              . (return Loc))
        (@IntE              . (return Int))
        (@StringE           . (return String))
        (@FloatE            . (return Float))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "expr_head"))
        ))
    ))

(extern fun ary_to_list)
(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom_type ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (if (== ty @ArrayE) (return (ary_to_list expr)))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (var i idx)
    (while (&& (> i 0) args) (do
        (= args (cdr args))
        (decr i)
        ))
    (if (! args)
        (throw (out_of_range current_loc expr (box (+ idx 1))))
        )
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type)
        (throw (type_error current_loc
            (type_string type) arg))
        )
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_set (expr idx val) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args)
            (throw (out_of_range current_loc
                expr (box (+ idx 1))))
            )
        (= args (cdr args))
        (decr idx)
        ))
    (setcar args val)
    ))

(export fun expr_size (expr) (
    (return (list_len (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @ExprE 2 head args))
    ))

(export fun make_expr_user (head args) (
    (if (!= (node_type head) @SymbolE)
        (throw (exception current_loc (string "the 1st argument of MakeExpr must be a Symbol")))
        )
    (if (is_builtin_sym head)
        (throw (make_expr Exception (list2
            (string "Can not create builtin object")
            head)))
        )
    (if (!= (node_type args) @ListE)
        (throw (exception current_loc (string "the 2nd argument of MakeExpr must be a List")))
        )

    (if (== head List)
        (return args)
        )
    (return (variant @ExprE 2 head args))
    ))

(export fun qualified (outer inner) (
    (return (make_expr Qualified (list2 (to_sym outer) inner)))
    ))

(export fun located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun quote (expr) (
    (return (make_expr Quote (list1 expr)))
    ))

(export fun qquote (expr) (
    (return (make_expr QuasiQuote (list1 expr)))
    ))

(export fun unquote (expr) (
    (return (make_expr Unquote (list1 expr)))
    ))

(export fun dynamic (sym) (
    (return (make_expr Dynamic (list1 sym)))
    ))

(export fun ifelse (cnd then else) (
	(return (make_expr IfElse (list3 cnd then else)))
	))

(export fun mkif (cnd then) (
	(return (make_expr If (list2 cnd then)))
	))

(export fun apply (fun args) (
    (return (make_expr Apply (list2 fun args)))
    ))

(export fun block (stmts) (
    (return (make_expr Block (list1 stmts)))
    ))

(export fun seq (stmts) (
    (return (make_expr Seq (list1 stmts)))
    ))

(export fun lambda (args body) (
    (return (make_expr Lambda (list2 args body)))
    ))

(export fun assign (v arg) (
    (return (make_expr Assign (list2 v arg)))
    ))

(export fun mkreturn (v) (
    (return (make_expr Return (list1 v)))
    ))

(export fun defvar (v arg) (
    (return (make_expr DefVariable (list2 v arg)))
    ))

; patterns
(export fun domainP (sym) (
    (return (make_expr Domain (list2 DontCare sym)))
    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

; types
(export var symT       (domainP Symbol))
(export var stringT    (domainP String))
(export var intT       (domainP Int))
(export var bintT      (domainP BigInt))
(export var floatT     (domainP Float))
(export var listT      (domainP List))
(export var arrayT     (domainP Array))
(export var tableT     (domainP Table))
(export var tupleT     (domainP Tuple))
(export var funT       (domainP Function))
(export var irangeT    (make_expr Range (list2 intT intT)))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (umod idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun type_string (type) (
    (tswitch type (
        (@SymbolE           . (return (string "Symbol")))
        (@ExprE             . (return (string "composite expression")))
        (@ListE             . (return (string "List")))
        (@ArrayE            . (return (string "Array")))
        (@TableE            . (return (string "Table")))
        (@AssemblerE        . (return (string "Assembler")))
        (@BytecodeE         . (return (string "Bytecode")))
        (@FunctionE         . (return (string "Function")))
        (@BoundFunctionE    . (return (string "Function")))
        (@InputFileStreamE  . (return (string "InputFileStream")))
        (@OutputFileStreamE . (return (string "OutputFileStream")))
        (@ModuleE           . (return (string "Module")))
        (@ParserE           . (return (string "Parser")))
        (@StringIOE         . (return (string "StringIO")))
        (@BigIntE           . (return (string "BigInt")))
        (@LocE              . (return (string "Loc")))
        (@IntE              . (return (string "Int")))
        (@StringE           . (return (string "String")))
        (@FloatE            . (return (string "Float")))
        (@BuiltinE          . (return (string "Builtin")))
        (default            . (not_reachable "output_type"))
        ))
    ))

    ))
