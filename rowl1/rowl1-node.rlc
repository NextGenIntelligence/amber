;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2010-12-09 18:02:49 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")

(var symbol_table (make_idtable))
(var symbol_index_gen 0)

; builtin expression headers and types
(export var Int     (to_sym "Int"))
(export var String  (to_sym "String"))
(export var Tuple   (to_sym "Tuple"))
(export var List    (to_sym "List"))
(export var Block   (to_sym "Block"))
(export var Apply   (to_sym "Apply"))
(export var Subscr  (to_sym "Subscr"))
(export var Located (to_sym "Located"))
(export var Loc     (to_sym "Loc"))

; operators
(export var Infix   (to_sym "infix"))
(export var Prefix  (to_sym "prefix"))
(export var Postfix (to_sym "postfix"))
(export var Constr  (to_sym "constr"))
(export var Left    (to_sym "left"))
(export var Right   (to_sym "right"))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @Symbol 2 name 0 symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun node_type (obj) (
    (if (! obj) (error "node_type: null object"))
    (if (& obj 1) (return @Int))
    (var tag (get_tag obj))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (return (+ (get_plain_tag obj) @BUILTIN_TYPE_OFFSET))
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var builtin_loc (make_loc "<builtin>" 0 0))

(export fun make_loc (file begin end) (
    (return (make_expr Loc (list3 file (box begin) (box end))))
    ))

(fun loc_file  (loc) ((return (car (field_get loc @ExprArgs)))))
(fun loc_begin (loc) ((return (unbox (cadr (field_get loc @ExprArgs))))))
(fun loc_end   (loc) ((return (unbox (caddr (field_get loc @ExprArgs))))))

(export fun merge_loc (loc1 loc2) (
    (var begin (loc_begin loc1))
    (var end   (loc_end loc2))
    (if (== begin end) (return loc1))
    (return (make_loc (loc_file loc1) begin end))
    ))

(export fun output_loc (ochan loc) (
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_begin loc))
    (var end   (loc_end loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ' ')
    ))

(export fun make_expr (head args) (
    (return (variant @Expr 2 head args))
    ))

(export fun make_located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun pretty_print (ochan node) (
    (tswitch (node_type node) (
        (@Symbol . (return (pp_symbol ochan node)))
        (@Expr   . (return (pp_expr ochan node)))
        (@Int    . (return (pp_int ochan node)))
        (@Float  . (return (pp_float ochan node)))
        (@String . (return (pp_string ochan node)))
        (default . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_symbol (ochan node) (
    (output_string ochan (field_get node @SymbolName))
    ))

(fun pp_expr (ochan node) (
    (var head (field_get node @ExprHead))
    (var args (field_get node @ExprArgs))

    (if (== head Tuple) (return (pp_tuple ochan args)))
    (if (== head List)  (return (pp_list ochan args)))
    (if (== head Block)   (return (pp_block ochan args)))
    (if (== head Apply)  (return (pp_apply ochan args)))
    (if (== head Subscr) (return (pp_subscr ochan args)))

    (output_string ochan (field_get head @SymbolName))
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_tuple (ochan args) (
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(var indent 0)
(fun incr_indent () ((+= indent 4)))
(fun decr_indent () ((-= indent 4)))

(fun pp_block (ochan args) (
    (output_string ochan "{\n")
    (incr_indent)
    (while args (do
        (for i 0 indent (output_char ochan ' '))
        (pretty_print ochan (car args))
        (output_char ochan '\n')
        (= args (cdr args))
        ))
    (decr_indent)
    (output_char ochan '}')
    ))

(fun pp_apply (ochan args) (
    (pretty_print ochan (car args))
    (= args (cdr args))
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_subscr (ochan args) (
    (pretty_print ochan (car args))
    (= args (cdr args))
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_float (ochan node) (
    (not_implemented "pp_float")
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

    ))
