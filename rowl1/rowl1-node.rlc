;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2012-06-27 12:08:24 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

; symbol table (symbols are globally unique)
(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var DontCare    (to_sym "_"))

(export var true        (to_sym "true"))
(export var false       (to_sym "false"))
(export var nil         (to_sym "nil"))
(export var undefined   (to_sym "undefined"))

(export var Symbol      (to_builtin_sym "Symbol"))
(export var Int         (to_builtin_sym "Int"))
(export var Float       (to_builtin_sym "Float"))
(export var String      (to_builtin_sym "String"))
(export var List        (to_sym "List"))
(export var Tuple       (to_sym "Tuple"))
(export var Eval        (to_sym "Eval"))
(export var Block       (to_sym "Block"))
(export var OpenBlock   (to_sym "OpenBlock"))
(export var Apply       (to_sym "Apply"))
(export var Subscript   (to_sym "Subscript"))
(export var Located     (to_sym "Located"))
(export var Loc         (to_sym "Loc"))
(export var Domain      (to_sym "Domain"))
(export var Where       (to_sym "Where"))
(export var Ellipsis    (to_sym "Ellipsis"))
(export var Compile     (to_sym "Compile"))
(export var Quote       (to_sym "Quote"))
(export var QuasiQuote  (to_sym "QuasiQuote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var IfElse      (to_sym "IfElse"))
(export var While       (to_sym "While"))
(export var Break       (to_sym "Break"))
(export var Continue    (to_sym "Continue"))
(export var Not         (to_sym "Not"))
(export var SeqAnd      (to_sym "SeqAnd"))
(export var SeqOr       (to_sym "SeqOr"))
(export var Equal       (to_sym "Equal"))
(export var NotEqual    (to_sym "NotEqual"))

(export var MakeExpr  (to_sym "MakeExpr"))
(export var Head      (to_sym "Head"))
(export var Arguments (to_sym "Arguments"))

(export var Include        (to_sym "Include"))
(export var Import         (to_sym "Import"))
(export var DefSyntax      (to_sym "DefineSyntax"))
(export var DefineVariable (to_sym "DefineVariable"))
(export var DefineFunction (to_sym "DefineFunction"))
(export var BeginModule    (to_sym "BeginModule"))
(export var EndModule      (to_sym "EndModule"))

(export var Dynamic     (to_sym "Dynamic"))
(export var Qualified   (to_sym "Qualified"))
(export var Rewrite     (to_sym "Rewrite"))
(export var Assign      (to_sym "Assign"))
(export var Lambda      (to_sym "Lambda"))
(export var Bind        (to_sym "Bind"))
(export var Return      (to_sym "Return"))
(export var Try         (to_sym "Try"))
(export var Throw       (to_sym "Throw"))
(export var Seq         (to_sym "Seq"))

(export var Assembler        (to_builtin_sym "Assembler"))
(export var Builtin          (to_builtin_sym "Builtin"))
(export var Bytecode         (to_builtin_sym "Bytecode"))
(export var Function         (to_builtin_sym "Function"))
(export var Closure          (to_builtin_sym "Closure"))
(export var InputFileStream  (to_builtin_sym "InputFileStream"))
(export var OutputFileStream (to_builtin_sym "OutputFileStream"))
(export var Module           (to_builtin_sym "Module"))

; for parser
(export var Parser (to_builtin_sym "Parser"))
(export var Parsed     (to_sym "Parsed"))   ; Parsed (location node)
(export var NoParse    (to_sym "NoParse"))  ; NoParse [(location msg)]
(export var MayParse   (to_sym "MayParse")) ; MayParse (shell mode only)

(export var Option     (to_sym "Option"))
(export var Choice     (to_sym "Choice"))
(export var Many       (to_sym "Many"))
(export var Many1      (to_sym "Many1"))
(export var And        (to_sym "And"))
; Amber's original syntax elements
(export var Scoped     (to_sym "Scoped"))
(export var Aligned    (to_sym "Aligned"))
(export var Delimited  (to_sym "Delimited"))
(export var Delimited1 (to_sym "Delimited1"))
(export var Delimited2 (to_sym "Delimited2"))

(export var Some   (to_sym "Some"))

; internal nodes
(export var ModuleVariable (to_sym "%ModuleVariable"))
(export var LocalVariable  (to_sym "%LocalVariable"))
(export var Label          (to_sym "%Label"))
(export var BreakLabel     (to_sym "%BreakLabel"))
(export var ContinueLabel  (to_sym "%ContinueLabel"))
(export var Arity          (to_sym "%Arity"))
(export var Argument       (to_sym "%Argument"))
(export var ListAt         (to_sym "%ListAt"))
(export var ExprAt         (to_sym "%ExprAt"))

(export fun to_builtin_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun unique_sym () (
    (return (to_sym (strcat "%s" (itos symbol_index_gen))))
    ))

(fun is_builtin_sym (sym) (
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun qualified (outer inner) (
    (return (make_expr Qualified (list2 (to_sym outer) inner)))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (return @BuiltinE)
    ))

(fun is_atom_type (ty) (
    (if (|| (== ty @ExprE) (== ty @ListE))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom (obj) (
    (return (is_atom_type (node_type obj)))
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var no_loc (make_loc (string "<internal>") 0 0))

(export fun make_loc (file begin end) (
    (return (make_expr Loc (list3 file (box begin) (box end))))
    ))

(fun loc_file  (loc) ((return (expr_arg_string loc 0))))
(fun loc_begin (loc) ((return (expr_arg_int loc 1))))
(fun loc_end   (loc) ((return (expr_arg_int loc 2))))

(export fun merge_loc (loc1 loc2) (
    (var begin (loc_begin loc1))
    (var end   (loc_end loc2))
    (if (== begin end) (return loc1))
    (return (make_loc (loc_file loc1) begin end))
    ))

(export fun output_loc (ochan loc) (
    (output_char ochan '[')
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_begin loc))
    (var end   (loc_end loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ']')
    ))

(extern object current_loc)
(export fun output_error (ochan loc) (
    (flush stdout)
    (if loc 
        (do
            (output_string ochan "Error ")
            (output_loc ochan loc)
            (output_string ochan " : ")
        )
        (output_string ochan "Error : ")
        )
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return Symbol))
        (@ExprE             . (return (field_get node @ExprHead)))
        (@ListE             . (return List))
        (@AssemblerE        . (return Assembler))
        (@BytecodeE         . (return Bytecode))
        (@FunctionE         . (return Function))
        (@BoundFunctionE    . (return Function))
        (@InputFileStreamE  . (return InputFileStream))
        (@OutputFileStreamE . (return OutputFileStream))
        (@ModuleE           . (return Module))
        (@ParserE           . (return Parser))
        (@IntE              . (return Int))
        (@FloatE            . (return Float))
        (@StringE           . (return String))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "expr_head"))
        ))
    ))

(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom_type ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (var i idx)
    (while (&& (> i 0) args) (do
        (= args (cdr args))
        (decr i)
        ))
    (if (! args) (do
        (output_error stderr current_loc)
        (output_string stderr "`")
        (pretty_print stderr expr)
        (output_string stderr "' does not have ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter\n")
        (exit 1)
        ))
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type) (do
        (output_error stderr current_loc)
        (output_string stderr "the ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be ")
        (output_type stderr type)
        (output_string stderr "\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_head (expr head idx) (
    (var arg (expr_arg expr idx))
    (if (!= (expr_head arg) head) (do
        (output_error stderr current_loc)
        (output_string stderr "the head of ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be `")
        (pretty_print stderr head)
        (output_string stderr "'\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_set (expr idx val) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr current_loc)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (= args (cdr args))
        (decr idx)
        ))
    (setcar args val)
    ))

(export fun expr_size (expr) (
    (return (list_len (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @ExprE 2 head args))
    ))

(export fun make_expr_user (head args) (
    (if (!= (node_type head) @SymbolE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 1st argument of MakeExpr must be a Symbol\n")
        (exit 1)
        ))
    (if (is_builtin_sym head) (do
        (output_error stderr current_loc)
        (output_string stderr "can not create builtin object: ")
        (pretty_print stderr head)
        (output_string stderr "{..}\n")
        (exit 1)
        ))
    (if (!= (node_type args) @ListE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 2nd argument of MakeExpr must be a List\n")
        (exit 1)
        ))

    (if (== head List)
        (return args)
        )
    (return (variant @ExprE 2 head args))
    ))

(export fun make_located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun quote (expr) (
    (return (make_expr Quote (list1 expr)))
    ))

(export fun qquote (expr) (
    (return (make_expr QuasiQuote (list1 expr)))
    ))

(export fun unquote (expr) (
    (return (make_expr Unquote (list1 expr)))
    ))

(export fun dynamic (sym) (
    (return (make_expr Dynamic (list1 sym)))
    ))

(export fun make_ifelse (cnd then else) (
	(return (make_expr IfElse (list3 cnd then else)))
	))

(export fun make_seq (e1 e2) (
    (return (make_expr Seq (list2 e1 e2)))
    ))

; patterns
(export fun domainP (sym) (
    (return (make_expr Domain (list2 DontCare sym)))
    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (% idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun output_type (ochan type) (
    (tswitch type (
        (@SymbolE           . (return (output_string ochan "Symbol")))
        (@ExprE             . (return (output_string ochan "composite expression")))
        (@ListE             . (return (output_string ochan "List")))
        (@AssemblerE        . (return (output_string ochan "Assembler")))
        (@BytecodeE         . (return (output_string ochan "Bytecode")))
        (@FunctionE         . (return (output_string ochan "Function")))
        (@BoundFunctionE    . (return (output_string ochan "Function")))
        (@InputFileStreamE  . (return (output_string ochan "InputFileStream")))
        (@OutputFileStreamE . (return (output_string ochan "OutputFileStream")))
        (@ModuleE           . (return (output_string ochan "Module")))
        (@ParserE           . (return (output_string ochan "Parser")))
        (@IntE              . (return (output_string ochan "Int")))
        (@FloatE            . (return (output_string ochan "Float")))
        (@StringE           . (return (output_string ochan "String")))
        (@BuiltinE          . (return (output_string ochan "Builtin")))
        (default            . (not_reachable "output_type"))
        ))
    ))

(extern fun pp_module)

(export fun pretty_print (ochan node) (
    (pretty_print_main ochan node)
    ))

(fun pretty_print_main (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr ochan node)))
        (@ListE             . (return (pp_list ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@ParserE           . (return (pp_parser ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(extern object current_mod)
(fun pp_expr (ochan node) (
    (var head (expr_head node))
    (var args (expr_args node))

    (if (== head Located) (return (pretty_print_main ochan (expr_arg node 1))))

    (output_symbol ochan head)
    (output_char ochan '{')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_tuple (ochan args) (
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_assembler (ochan expr) (
    (output_string ochan "<#Assembler:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_bytecode (ochan expr) (
    (output_string ochan "<#Bytecode:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_function (ochan expr) (
    (output_string ochan "<#Function:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_bound (ochan expr) (
    (output_string ochan "<#Function:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_file_stream (ochan node) (
    (if (== (node_type node) @InputFileStreamE)
        (output_string ochan "<#InputFileStream:")
        (output_string ochan "<#OutputFileStream:")
        )
    (pretty_print ochan (field_get node 1))
    (output_char ochan '>')
    ))

(fun pp_parser (ochan node) (
    (output_string ochan "<#Parser:")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_float (ochan node) (
    (not_implemented "pp_float")
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

(fun pp_builtin (ochan node) (
    (output_string ochan "<#Builtin:0x")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(export fun pretty_print_full (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr_full ochan node)))
        (@ListE             . (return (pp_list_full ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@ParserE           . (return (pp_parser ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr_full (ochan node) (
    (var hd (expr_head node))
    (var args (expr_args node))
    (output_symbol ochan hd)
    (output_char ochan '{')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_list_full (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))


    ))
