;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-node.rlc 2012-10-01 03:12:02 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-symtable")

(extern object current_loc)

; symbol table (symbols are globally unique)
(var symbol_table (make_idtable))
(var symbol_index_gen 0)
(var builtin_symbol_index_gen -1)

; builtin expression headers and types
(export var DontCare    (to_sym "_"))

(export var true        (to_sym "true"))
(export var false       (to_sym "false"))
(export var nil         (to_sym "nil"))
(export var undefined   (to_sym "undefined"))

(export var Symbol      (to_builtin_sym "Symbol"))
(export var Int         (to_builtin_sym "Int"))
(export var BigInt      (to_builtin_sym "BigInt"))
(export var Float       (to_builtin_sym "Float"))
(export var String      (to_builtin_sym "String"))
(export var Loc         (to_builtin_sym "Loc"))
(export var Float       (to_sym "Float"))
(export var List        (to_sym "List"))
(export var Array       (to_sym "Array"))
(export var Table       (to_sym "Table"))
(export var Tuple       (to_sym "Tuple"))
(export var Block       (to_sym "Block"))
(export var Apply       (to_sym "Apply"))
(export var Subscript   (to_sym "Subscript"))
(export var Located     (to_sym "Located"))
(export var Domain      (to_sym "Domain"))
(export var Where       (to_sym "Where"))
(export var Ellipsis    (to_sym "Ellipsis"))
(export var Quote       (to_sym "Quote"))
(export var QuasiQuote  (to_sym "QuasiQuote"))
(export var Unquote     (to_sym "Unquote"))
(export var If          (to_sym "If"))
(export var IfElse      (to_sym "IfElse"))
(export var While       (to_sym "While"))
(export var Break       (to_sym "Break"))
(export var Continue    (to_sym "Continue"))
(export var Not         (to_sym "Not"))
(export var SeqAnd      (to_sym "SeqAnd"))
(export var SeqOr       (to_sym "SeqOr"))
(export var Equal       (to_sym "Equal"))
(export var NotEqual    (to_sym "NotEqual"))

(export var MakeExpr  (to_sym "MakeExpr"))
(export var Head      (to_sym "Head"))
(export var Arguments (to_sym "Arguments"))

(export var FieldRef  (to_sym "%FieldRef")) ; only for internal use

(export var Include        (to_sym "Include"))
(export var Import         (to_sym "Import"))
(export var DefSyntax      (to_sym "DefineSyntax"))
(export var DefineVariable (to_sym "DefineVariable"))
(export var DefineFunction (to_sym "DefineFunction"))
(export var BeginModule    (to_sym "BeginModule"))
(export var EndModule      (to_sym "EndModule"))

(export var Dynamic     (to_sym "Dynamic"))
(export var Qualified   (to_sym "Qualified"))
(export var Assign      (to_sym "Assign"))
(export var Lambda      (to_sym "Lambda"))
(export var Bind        (to_sym "Bind"))
(export var Return      (to_sym "Return"))
(export var Try         (to_sym "Try"))
(export var Throw       (to_sym "Throw"))
(export var Seq         (to_sym "Seq"))

(export var Assembler        (to_builtin_sym "Assembler"))
(export var Builtin          (to_builtin_sym "Builtin"))
(export var Bytecode         (to_builtin_sym "Bytecode"))
(export var Function         (to_builtin_sym "Function"))
(export var Closure          (to_builtin_sym "Closure"))
(export var InputFileStream  (to_builtin_sym "InputFileStream"))
(export var OutputFileStream (to_builtin_sym "OutputFileStream"))
(export var StringIO         (to_builtin_sym "StringIO"))
(export var Module           (to_builtin_sym "Module"))

(export var Eval        (to_sym "eval"))
(export var Compile     (to_sym "compile"))
(export var Rewrite     (to_sym "rewrite"))

; for parser
(export var Parser (to_builtin_sym "Parser"))

(export var OneOf      (to_sym "OneOf"))
(export var NoneOf     (to_sym "NoneOf"))
(export var Option     (to_sym "Option"))
(export var Choice     (to_sym "Choice"))
(export var Many       (to_sym "Many"))
(export var Many1      (to_sym "Many1"))
(export var And        (to_sym "And"))
; Amber's original syntax elements
(export var Scoped     (to_sym "Scoped"))
(export var Aligned    (to_sym "Aligned"))
(export var Delimited  (to_sym "Delimited"))
(export var Delimited1 (to_sym "Delimited1"))
(export var Delimited2 (to_sym "Delimited2"))

(export var Some   (to_sym "Some"))

; internal nodes
(export var ModuleVariable (to_sym "%ModuleVariable"))
(export var LocalVariable  (to_sym "%LocalVariable"))
(export var Label          (to_sym "%Label"))
(export var BreakLabel     (to_sym "%BreakLabel"))
(export var ContinueLabel  (to_sym "%ContinueLabel"))
(export var Arity          (to_sym "%Arity"))
(export var Argument       (to_sym "%Argument"))
(export var ListAt         (to_sym "%ListAt"))
(export var ListFrom       (to_sym "%ListFrom"))
(export var ExprAt         (to_sym "%ExprAt"))
(export var ExprFrom       (to_sym "%ExprFrom"))

(export fun to_builtin_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name builtin_symbol_index_gen))
    (-= builtin_symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(export fun to_sym (name) (
    (var sym (idtable_find symbol_table name))
    (if sym (return sym))
    (= name (strdup name))
    (= sym (variant @SymbolE 1 name symbol_index_gen))
    (+= symbol_index_gen 1)
    (idtable_add symbol_table name sym)
    (return sym)
    ))

(extern fun is_letter)
(extern fun is_identchar)
(extern fun invalid_argument)
(export fun to_sym_user (name) (
    (var len (strlen name))
    (if (! len) (goto to_sym_error))
    (if (! (is_letter (array_get char name 0))) (goto to_sym_error))
    (for i 1 len (do
        (if (! (is_identchar (array_get char name i))) (goto to_sym_error))
        ))
    (return (to_sym name))
    (label to_sym_error)
    (throw (invalid_argument current_loc
        (string "invalid identifier string")
        name
        ))
    ))

(export fun unique_sym () (
    (return (to_sym (strcat "x" (itos symbol_index_gen))))
    ))

(fun is_builtin_sym (sym) (
    (if (< (field_get sym 2) 0)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(export fun symbol_name (sym) (
    (return (field_get sym @SymbolName))
    ))

(export fun node_type (obj) (
    (if (! obj) (return @ListE))
    (if (& obj 1) (return @IntE))
    (var tag (get_tag obj))
    (if (== tag @TAG_PSTRUCT) (return (+ (get_pstruct_tag obj) @PLAIN_TYPE_OFFSET)))
    (if (== tag @TAG_VARIANT) (return (field_get obj 0)))
    (if (== tag @TAG_CONS) (return @ListE))
    (if (== tag @TAG_BYTECODE) (return @BytecodeE))
    (if (== tag @TAG_BIGINT) (return @BigIntE))
    (if (&& (== tag @TAG_SEQUENCE) (== (get_sequence_tag obj) @SEQ_ARRAY))
        (return @ArrayE)
        )
    (return @BuiltinE)
    ))

(fun is_atom_type (ty) (
    (if (|| (== ty @ExprE) (|| (== ty @ListE) (== ty @ArrayE)))
        (return @FALSE)
        (return @TRUE)
        )
    ))

(export fun is_atom (obj) (
    (return (is_atom_type (node_type obj)))
    ))

; XXX: output precise information
(export fun check_type (name type obj) (
    (if (|| (! obj) (!= (node_type obj) type)) (do
        (output_string stderr name)
        (output_string stderr ": invalid argument\n")
        (exit 1)
        ))
    ))

(export fun make_float_from_string (str) (
    (error "floating-point literals are not supported yet")
    ))

(export var no_loc (make_loc (string "<internal>") 0 0 0 0))

(export fun make_loc (file bl bc el ec) (
    (return (variant @LocE 1 file bl bc el ec))
    ))

(export fun loc_file   (loc) ((return (field_get loc 1))))
(export fun loc_beginL (loc) ((return (field_get loc 2))))
(export fun loc_beginC (loc) ((return (field_get loc 3))))
(export fun loc_endL   (loc) ((return (field_get loc 4))))
(export fun loc_endC   (loc) ((return (field_get loc 5))))

(export fun merge_loc (loc1 loc2) (
    (var el (loc_endL loc2))
    (var ec (loc_endC loc2))
    (field_set loc1 4 el)
    (field_set loc1 5 ec)
    (return loc1)
    ))

(export fun pp_loc (ochan loc) (
    (output_char ochan '[')
    (output_string ochan (loc_file loc))
    (output_char ochan ':')
    (var begin (loc_beginL loc))
    (var end   (loc_endL loc))
    (if (== begin end)
        (output_int ochan begin)
        (do
            (output_int ochan begin)
            (output_char ochan '-')
            (output_int ochan end)
        ))
    (output_char ochan ']')
    ))

(export fun output_error (ochan loc) (
    (flush stdout)
    (if loc 
        (do
            (output_string ochan "Error ")
            (pp_loc ochan loc)
            (output_string ochan " : ")
        )
        (output_string ochan "Error : ")
        )
    ))

(export fun expr_head (node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return Symbol))
        (@ExprE             . (return (field_get node @ExprHead)))
        (@ListE             . (return List))
        (@ArrayE            . (return Array))
        (@TableE            . (return Table))
        (@AssemblerE        . (return Assembler))
        (@BytecodeE         . (return Bytecode))
        (@FunctionE         . (return Function))
        (@BoundFunctionE    . (return Function))
        (@InputFileStreamE  . (return InputFileStream))
        (@OutputFileStreamE . (return OutputFileStream))
        (@ModuleE           . (return Module))
        (@ParserE           . (return Parser))
        (@StringIOE         . (return StringIO))
        (@BigIntE           . (return BigInt))
        (@LocE              . (return Loc))
        (@IntE              . (return Int))
        (@StringE           . (return String))
        (@FloatE            . (return Float))
        (@BuiltinE          . (return Builtin))
        (default            . (not_reachable "expr_head"))
        ))
    ))

(extern fun ary_to_list)
(export fun expr_args (expr) (
    (var ty (node_type expr))
    (if (is_atom_type ty) (return (cons expr 0)))
    (if (== ty @ListE) (return expr))
    (if (== ty @ArrayE) (return (ary_to_list expr)))
    (return (field_get expr @ExprArgs))
    ))

(export fun expr_arg (expr idx) (
    (var args (expr_args expr))
    (var i idx)
    (while (&& (> i 0) args) (do
        (= args (cdr args))
        (decr i)
        ))
    (if (! args) (do
        (output_error stderr current_loc)
        (output_string stderr "`")
        (pretty_print stderr expr)
        (output_string stderr "' does not have ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter\n")
        (exit 1)
        ))
    (return (car args))
    ))

(fun expr_arg_check (expr type idx) (
    (var arg (expr_arg expr idx))
    (if (!= (node_type arg) type) (do
        (output_error stderr current_loc)
        (output_string stderr "the ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be ")
        (output_type stderr type)
        (output_string stderr "\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_int (expr idx) (
    (var v (expr_arg_check expr @IntE idx))
    (return (unbox v))
    ))

(export fun expr_arg_symbol (expr idx) (
    (return (expr_arg_check expr @SymbolE idx))
    ))

(export fun expr_arg_string (expr idx) (
    (return (expr_arg_check expr @StringE idx))
    ))

(export fun expr_arg_list (expr idx) (
    (return (expr_arg_check expr @ListE idx))
    ))

(export fun expr_arg_head (expr head idx) (
    (var arg (expr_arg expr idx))
    (if (!= (expr_head arg) head) (do
        (output_error stderr current_loc)
        (output_string stderr "the head of ")
        (output_ordinal stderr (+ idx 1))
        (output_string stderr " parameter of `")
        (pretty_print stderr expr)
        (output_string stderr "' must be `")
        (pretty_print stderr head)
        (output_string stderr "'\n")
        (exit 1)
        ))
    (return arg)
    ))

(export fun expr_arg_set (expr idx val) (
    (var args (expr_args expr))
    (while (> idx 0) (do
        (if (! args) (do
            (output_error stderr current_loc)
            (output_string stderr "`")
            (pretty_print stderr expr)
            (output_string stderr "' does not have ")
            (output_ordinal stderr (+ idx 1))
            (output_string stderr " parameter\n")
            (exit 1)
            ))
        (= args (cdr args))
        (decr idx)
        ))
    (setcar args val)
    ))

(export fun expr_size (expr) (
    (return (list_len (expr_args expr)))
    ))

(export fun make_expr (head args) (
    (return (variant @ExprE 2 head args))
    ))

(export fun make_expr_user (head args) (
    (if (!= (node_type head) @SymbolE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 1st argument of MakeExpr must be a Symbol\n")
        (exit 1)
        ))
    (if (is_builtin_sym head) (do
        (output_error stderr current_loc)
        (output_string stderr "can not create builtin object: ")
        (pretty_print stderr head)
        (output_string stderr "{..}\n")
        (exit 1)
        ))
    (if (!= (node_type args) @ListE) (do
        (output_error stderr current_loc)
        (output_string stderr "the 2nd argument of MakeExpr must be a List\n")
        (exit 1)
        ))

    (if (== head List)
        (return args)
        )
    (return (variant @ExprE 2 head args))
    ))

(export fun qualified (outer inner) (
    (return (make_expr Qualified (list2 (to_sym outer) inner)))
    ))

(export fun located (loc expr) (
    (return (make_expr Located (list2 loc expr)))
    ))

(export fun quote (expr) (
    (return (make_expr Quote (list1 expr)))
    ))

(export fun qquote (expr) (
    (return (make_expr QuasiQuote (list1 expr)))
    ))

(export fun unquote (expr) (
    (return (make_expr Unquote (list1 expr)))
    ))

(export fun dynamic (sym) (
    (return (make_expr Dynamic (list1 sym)))
    ))

(export fun ifelse (cnd then else) (
	(return (make_expr IfElse (list3 cnd then else)))
	))

(export fun mkif (cnd then) (
	(return (make_expr If (list2 cnd then)))
	))

(export fun apply (fun args) (
    (return (make_expr Apply (list2 fun args)))
    ))

(export fun block (stmts) (
    (return (make_expr Block (list1 stmts)))
    ))

(export fun lambda (args body) (
    (return (make_expr Lambda (list2 args body)))
    ))

(export fun assign (v arg) (
    (return (make_expr Assign (list2 v arg)))
    ))

(export fun mkreturn (v) (
    (return (make_expr Return (list1 v)))
    ))

(export fun defvar (v arg) (
    (return (make_expr DefineVariable (list2 v arg)))
    ))

; patterns
(export fun domainP (sym) (
    (return (make_expr Domain (list2 DontCare sym)))
    ))

(export fun output_symbol (ochan sym) (
    (output_string ochan (field_get sym @SymbolName))
    ))

; types
(export var symT       (domainP Symbol))
(export var stringT    (domainP String))
(export var intT       (domainP Int))
(export var bintT      (domainP BigInt))
(export var floatT     (domainP Float))
(export var listT      (domainP List))
(export var arrayT     (domainP Array))
(export var tableT     (domainP Table))
(export var tupleT     (domainP Tuple))
(export var funT       (domainP Function))

; printing functions
(fun output_ordinal (ochan idx) (
    (output_int ochan idx)
    (if (== (/ idx 10) 1) (return (output_string ochan "th")))
    (var r (umod idx 10))
    (if (== r 1) (return (output_string ochan "st")))
    (if (== r 2) (return (output_string ochan "nd")))
    (if (== r 3) (return (output_string ochan "rd")))
    (output_string ochan "th")
    ))

(fun output_type (ochan type) (
    (tswitch type (
        (@SymbolE           . (return (output_string ochan "Symbol")))
        (@ExprE             . (return (output_string ochan "composite expression")))
        (@ListE             . (return (output_string ochan "List")))
        (@ArrayE            . (return (output_string ochan "Array")))
        (@TableE            . (return (output_string ochan "Table")))
        (@AssemblerE        . (return (output_string ochan "Assembler")))
        (@BytecodeE         . (return (output_string ochan "Bytecode")))
        (@FunctionE         . (return (output_string ochan "Function")))
        (@BoundFunctionE    . (return (output_string ochan "Function")))
        (@InputFileStreamE  . (return (output_string ochan "InputFileStream")))
        (@OutputFileStreamE . (return (output_string ochan "OutputFileStream")))
        (@ModuleE           . (return (output_string ochan "Module")))
        (@ParserE           . (return (output_string ochan "Parser")))
        (@StringIOE         . (return (output_string ochan "StringIO")))
        (@BigIntE           . (return (output_string ochan "BigInt")))
        (@LocE              . (return (output_string ochan "Loc")))
        (@IntE              . (return (output_string ochan "Int")))
        (@StringE           . (return (output_string ochan "String")))
        (@FloatE            . (return (output_string ochan "Float")))
        (@BuiltinE          . (return (output_string ochan "Builtin")))
        (default            . (not_reachable "output_type"))
        ))
    ))

(extern fun pp_module)
(extern fun pp_table)
(extern fun pp_table_full)
(extern fun pp_bint)
(extern fun pp_float)

(export fun pretty_print (ochan node) (
    (pretty_print_main ochan node)
    ))

(fun pretty_print_main (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr ochan node)))
        (@ListE             . (return (pp_list ochan node)))
        (@ArrayE            . (return (pp_array ochan node)))
        (@TableE            . (return (pp_table ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@ParserE           . (return (pp_parser ochan node)))
        (@StringIOE         . (return (pp_stringio ochan node)))
        (@BigIntE           . (return (pp_bint ochan node)))
        (@LocE              . (return (pp_loc ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(extern object current_mod)
(fun pp_expr (ochan node) (
    (var head (expr_head node))
    (var args (expr_args node))

    (if (== head Located) (return (pretty_print_main ochan (expr_arg node 1))))

    (output_symbol ochan head)
    (output_char ochan '{')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_list (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_array (ochan ary) (
    (output_string ochan "Array [")
    (var size (array_size ary))
    (for i 0 size (do
        (pretty_print ochan (array_get object ary i))
        (if (< i (- size 1)) (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_tuple (ochan args) (
    (output_char ochan '(')
    (while args (do
        (pretty_print ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ')')
    ))

(fun pp_assembler (ochan expr) (
    (output_string ochan "<#Assembler:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_bytecode (ochan expr) (
    (output_string ochan "<#Bytecode:0x")
    (output_hex ochan expr 8)
    (output_char ochan '>')
    ))

(fun pp_function (ochan expr) (
    (output_string ochan "<#Function:0x")
    (output_hex ochan expr 8)
    (output_char ochan ':')
    (pretty_print ochan (field_get expr 2))
    (output_char ochan '>')
    ))

(fun pp_bound (ochan expr) (
    (output_string ochan "<#Function:0x")
    (output_hex ochan expr 8)
    (output_char ochan ':')
    (pretty_print ochan (field_get expr 2))
    (pretty_print ochan (field_get expr 3))
    (output_char ochan '>')
    ))

(fun pp_file_stream (ochan node) (
    (if (== (node_type node) @InputFileStreamE)
        (output_string ochan "<#InputFileStream:")
        (output_string ochan "<#OutputFileStream:")
        )
    (pretty_print ochan (field_get node 1))
    (output_char ochan '>')
    ))

(fun pp_parser (ochan node) (
    (output_string ochan "<#Parser:")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(fun pp_stringio (ochan node) (
    (output_string ochan "<#StringIO:")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(fun pp_int (ochan node) (
    (output_int ochan (unbox node))
    ))

(fun pp_string (ochan node) (
    (output_char ochan '"')
    (var i 0)
    (while (array_get char node i) (do
        (output_char_escape ochan (array_get char node i))
        (incr i)
        ))
    (output_char ochan '"')
    ))

(fun pp_builtin (ochan node) (
    (output_string ochan "<#Builtin:0x")
    (output_hex ochan node 8)
    (output_char ochan '>')
    ))

(export fun pretty_print_full (ochan node) (
    (tswitch (node_type node) (
        (@SymbolE           . (return (output_symbol ochan node)))
        (@ExprE             . (return (pp_expr_full ochan node)))
        (@ListE             . (return (pp_list_full ochan node)))
        (@ArrayE            . (return (pp_array_full ochan node)))
        (@TableE            . (return (pp_table_full ochan node)))
        (@AssemblerE        . (return (pp_assembler ochan node)))
        (@BytecodeE         . (return (pp_bytecode ochan node)))
        (@FunctionE         . (return (pp_function ochan node)))
        (@BoundFunctionE    . (return (pp_bound ochan node)))
        (@InputFileStreamE  . (return (pp_file_stream ochan node)))
        (@OutputFileStreamE . (return (pp_file_stream ochan node)))
        (@ModuleE           . (return (pp_module ochan node)))
        (@ParserE           . (return (pp_parser ochan node)))
        (@StringIOE         . (return (pp_stringio ochan node)))
        (@BigIntE           . (return (pp_bint ochan node)))
        (@LocE              . (return (pp_loc ochan node)))
        (@IntE              . (return (pp_int ochan node)))
        (@StringE           . (return (pp_string ochan node)))
        (@FloatE            . (return (pp_float ochan node)))
        (@BuiltinE          . (return (pp_builtin ochan node)))
        (default            . (not_reachable "pretty_print"))
        ))
    ))

(fun pp_expr_full (ochan node) (
    (var hd (expr_head node))
    (var args (expr_args node))
    (output_symbol ochan hd)
    (output_char ochan '{')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan '}')
    ))

(fun pp_list_full (ochan args) (
    (output_char ochan '[')
    (while args (do
        (pretty_print_full ochan (car args))
        (= args (cdr args))
        (if args (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

(fun pp_array_full (ochan ary) (
    (output_string ochan "Array [")
    (var size (array_size ary))
    (for i 0 size (do
        (pretty_print_full ochan (array_get object ary i))
        (if (< i (- size 1)) (output_string ochan ", "))
        ))
    (output_char ochan ']')
    ))

    ))
