;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: vm-insn.rlc 2011-01-11 16:49:22 nineties $
;

(define gen_field_get (idx) `(
    (asm "movl (%esi), %eax")
    (asm "movl " @(* 4 idx) "(%eax), %eax")
    (asm "movl %eax, (%esi)")
    ))

(define gen_field_set (idx) `(
    (vmpop %ecx) ; value
    (vmpop %eax) ; ptr
    (asm "movl %ecx, " @(* 4 idx) "(%eax)")
    ))

(define gen_comparison1 (cmovname) `(
    (vmpop %eax)
    (asm "cmpl %edx, %eax")
    (asm "movl $3, %eax")
    (vmsshort 1 %ecx)
    (asm @cmovname " %ecx, %eax")
    (vmsucc %eax)
    (vmfetch)
    ))

(define gen_comparison2 (cmovname) `(
    (vmpop %eax)
    (vmpop %ecx)
    (asm "cmpl %eax, %ecx")
    (asm "movl $3, %eax")
    (vmsshort 1 %ecx)
    (asm @cmovname " %ecx, %eax")
    (vmsucc %eax)
    (vmfetch)
    ))

(define gen_check_plain (type) `(
    (vmpop %eax)
    (asm "test $1, %eax")
    (asm "jnz 1f")
    (asm "cmpl $0, %eax")
    (asm "je 1f")
    (asm "movl -4(%eax), %eax")
    ; XXX: should not hardcode the layout of object header.
    (asm "andl $" @(- (<< 1 11) 1) ", %eax")
    (asm "cmpl $" @(| (<< type 3) TAG_PLAIN) ", %eax")
    (asm "je 2f")
    (asm "1:")
    (vmsshort 1 %ecx)
    (vmsucc %ecx)
    (vmfetch)
    (asm "2:")
    (vmsucc 3)
    (vmfetch)
    ))

(define operand_len (opd) (assoc opd `((byte . 1) (short . 2) (ushort . 2) (int . 4) (prim . 2) (addr . 2) (object . 4))))
(define insn_length (operands) (do
    (var len 1) ; 1 for instruction code
    (foreach o operands (+= len (operand_len o)))
    len
    ))

(var vm_instructions `(
    (nop       () @true ())
    (drop  () @true ((asm "addl $4, %esi")))
    (drop2 () @true ((asm "addl $8, %esi")))
    (dup   () @true ((asm "movl (%esi), %eax") (vmpush %eax)))
    (swap  () @true (
        (asm "movl (%esi), %eax")
        (asm "movl 4(%esi), %ecx")
        (asm "movl %eax, 4(%esi)")
        (asm "movl %ecx, (%esi)")
        ))
    (imm_i0    () @true ((vmpush %edx))) ; also used for 'nil'
    (imm_i1    () @true ((vmpush $1)))
    (imm_i2    () @true ((vmpush $2)))
    (imm_i3    () @true ((vmpush $3)))
    (imm_i4    () @true ((vmpush $4)))
    (imm_i5    () @true ((vmpush $5)))
    (imm_im1   () @true ((vmpush $-1)))
    (imm_int16 (short) @true ((vmsshort 1 %eax) (vmpush %eax)))
    (imm_int32 (int) @true ((vmint 1 %eax) (vmpush %eax)))
    (iadd      () @true ((vmbin "addl")))
    (isub      () @true ((vmbin "subl")))
    (iadd1 () @true ((asm "incl (%esi)")))
    (isub1 () @true ((asm "decl (%esi)")))
    (imul      () @true ((vmpop %eax) (asm "imul (%esi), %eax") (asm "movl %eax, (%esi)")))
    (idiv      () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "idiv %ecx")
        (vmpush %eax)
        (asm "xorl %edx, %edx") ; clear zero register
        ))
    (imod       () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "idiv %ecx")
        (vmpush %edx)
        (asm "xorl %edx, %edx") ; clear zero register
        ))
    (ineg       () @true ((asm "negl (%esi)")))
    (shl   () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "shll %cl, %eax")
        (vmpush %eax)
        ))
    (shr   () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "shrl %cl, %eax")
        (vmpush %eax)
        ))
    (sal   () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "sall %cl, %eax")
        (vmpush %eax)
        ))
    (sar   () @true (
        (vmpop %ecx)
        (vmpop %eax)
        (asm "sarl %cl, %eax")
        (vmpush %eax)
        ))
    (bsr   () @true (
        (asm "movl (%esi), %eax")
        (asm "bsr %eax, %eax")
        (asm "cmovz %edx, %eax")
        (asm "movl %eax, (%esi)")
        ))
    (and    () @true ((vmbin "andl")))
    (or     () @true ((vmbin "orl")))
    (xor    () @true ((vmbin "xorl")))
    ; allocate cons object
    ; arg0 = cdr object
    ; arg1 = car object
    (cons () @true (
        (vmsave)
        (call allocate_cons)
        (vmrestore)
        (vmpop %ecx)
        (asm "movl %ecx, (%eax)")
        (asm "movl (%esi), %ecx")
        (asm "movl %ecx, 4(%eax)")
        (asm "movl %eax, (%esi)")
        ))
    (list_at (int) @true (
        (asm "movl (%esi), %eax")
        (vmint 1 %ecx)
        (asm "0:")
        (asm "cmpl $0, %ecx")
        (asm "je 1f")
        (asm "movl 4(%eax), %eax")
        (asm "decl %ecx")
        (asm "jmp 0b")
        (asm "1:")
        (asm "movl (%eax), %eax")
        (asm "movl %eax, (%esi)")
        ))
    ; allocate plain object
    ; arg0 = size (in bytes)
    ; NB: allocated memory is not be zero-cleared
    (plain (byte) @true (
        (asm "movl (%esi), %eax")
        (vmsave)
        (asm "pushl %eax")
        (vmubyte 1 %eax) ; type of plain
        (asm "pushl %eax")
        (call allocate_plain)
        (asm "addl $8, %esp")
        (vmrestore)
        (asm "movl %eax, (%esi)")
        ))
    ; allocate tuple object
    ; opd0 = # of elements (8bit)
    ; opd1 = # of boxed elements (8bit)
    ; NB:
    ;  - allocated memory is not be zero-cleared
    ;  - all boxed elements must be placed first
    (tuple (byte byte) @true (
        (vmsave)
        (asm "pushl %esi")
        (vmubyte 2 %eax) ; # of boxed elements
        (asm "pushl %eax")
        (vmubyte 1 %eax) ; # of elements
        (asm "pushl %eax")
        (asm "sall $2, %eax")
        (asm "addl %eax, %esi")
        (call allocate_tuple_with_values)
        (asm "addl $12, %esp")
        (vmrestore)
        (vmpush %eax)
        ))
    ; allocate variant object
    ; opd0 = tag (16bit)
    ; opd1 = # of elements (8bit)
    ; opd2 = # of boxed elements (8bit)
    ; NB:
    ;  - allocated memory is not be zero-cleared
    ;  - field0 is for the tag
    ;  - do not rewrite the tag
    ;  - all boxed elements must be placed first
    (variant (short byte byte) @true (
        (vmsave)
        (asm "pushl %esi")
        (vmubyte 4 %eax) ; # of boxed elements
        (asm "pushl %eax")
        (vmubyte 3 %eax) ; # of elements
        (asm "pushl %eax")
        (asm "sall $2, %eax")
        (asm "addl %eax, %esi")
        (vmushort 1 %eax) ; tag
        (asm "pushl %eax")
        (call allocate_variant_with_values)
        (asm "addl $16, %esp")
        (vmrestore)
        (vmpush %eax)
        ))
    (field_get0 () @true @(gen_field_get 0)) ; also used for 'car'
    (field_get1 () @true @(gen_field_get 1)) ; also used for 'cdr'
    (field_get2 () @true @(gen_field_get 2))
    (field_get3 () @true @(gen_field_get 3))
    (field_get4 () @true @(gen_field_get 4))
    (field_get5 () @true @(gen_field_get 5))
    (field_get  (byte) @true (
        (vmubyte 1 %eax)
        (asm "sall $2, %eax")
        (asm "movl (%esi), %ecx")
        (asm "addl %ecx, %eax")
        (asm "movl (%eax), %eax")
        (asm "movl %eax, (%esi)")
        ))
    ; field_set val obj
    (field_set0 () @true @(gen_field_set 0)) ; also used for 'setcar'
    (field_set1 () @true @(gen_field_set 1)) ; also used for 'setcdr'
    (field_set2 () @true @(gen_field_set 2))
    (field_set3 () @true @(gen_field_set 3))
    (field_set4 () @true @(gen_field_set 4))
    (field_set5 () @true @(gen_field_set 5))
    (field_set  (byte) @true (
        (vmubyte 1 %eax) ; index
        (asm "sall $2, %eax")
        (vmpop %ecx) ; obj
        (asm "addl %eax, %ecx")
        (asm "movl (%esi), %eax")
        (asm "movl %eax, (%ecx)")
        ))
    ; array nelem
    (array () @true (
        (asm "movl (%esi), %eax") ; # of elements
        (vmsave)
        (asm "pushl %eax")
        (call allocate_array)
        (asm "addl $4, %esp")
        (vmrestore)
        (asm "movl %eax, (%esi)")
        ))
    ; array_get ary idx
    (array_get8 () @true (
        (vmpop %eax) ; index
        (asm "movl (%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movsbl (%ecx), %eax")
        (asm "movl %eax, (%esi)")
        ))
    (array_get16 () @true (
        (vmpop %eax) ; index
        (asm "sall $1, %eax")
        (asm "movl (%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movswl (%ecx), %eax")
        (asm "movl %eax, (%esi)")
        ))
    (array_get32 () @true (
        (vmpop %eax) ; index
        (asm "sall $2, %eax")
        (asm "movl (%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movl (%ecx), %eax")
        (asm "movl %eax, (%esi)")
        ))
    ; array_set ary idx val
    (array_set8 () @true (
        (asm "movl 4(%esi), %eax") ; index
        (asm "movl 8(%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movl (%esi), %eax") ; value
        (asm "movb %al, (%ecx)")
        (asm "addl $12, %esi")
        ))
    (array_set16 () @true (
        (asm "movl 4(%esi), %eax") ; index
        (asm "sall $1, %eax")
        (asm "movl 8(%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movl (%esi), %eax") ; value
        (asm "movw %ax, (%ecx)")
        (asm "addl $12, %esi")
        ))
    (array_set32 () @true (
        (asm "movl 4(%esi), %eax") ; index
        (asm "sall $2, %eax")
        (asm "movl 8(%esi), %ecx") ; array
        (asm "addl %eax, %ecx")
        (asm "movl (%esi), %eax") ; value
        (asm "movl %eax, (%ecx)")
        (asm "addl $12, %esi")
        ))
    ; allocate stack area for local variables
    (allocate (byte) @true (
        (vmubyte 1 %eax)
        (asm "sall $2, %eax")
        (asm "subl %eax, %esi")
        ))
    ; arguments
    (arg0 () @true ((asm "movl 8(%edi), %eax") (vmpush %eax)))
    (arg1 () @true ((asm "movl 12(%edi), %eax") (vmpush %eax)))
    (arg2 () @true ((asm "movl 16(%edi), %eax") (vmpush %eax)))
    (arg3 () @true ((asm "movl 20(%edi), %eax") (vmpush %eax)))
    (arg4 () @true ((asm "movl 24(%edi), %eax") (vmpush %eax)))
    ; load word from local
    (loadl0 () @true ((asm "movl -4(%edi), %eax") (vmpush %eax)))
    (loadl1 () @true ((asm "movl -8(%edi), %eax") (vmpush %eax)))
    (loadl2 () @true ((asm "movl -12(%edi), %eax") (vmpush %eax)))
    (loadl3 () @true ((asm "movl -16(%edi), %eax") (vmpush %eax)))
    (loadl4 () @true ((asm "movl -20(%edi), %eax") (vmpush %eax)))
    (loadl5 () @true ((asm "movl -24(%edi), %eax") (vmpush %eax)))
    (loadl (byte) @true (
        (vmsbyte 1 %ecx) ; offset
        (asm "movl %edi, %eax")
        (asm "addl %ecx, %eax")
        (asm "movl (%eax), %eax")
        (vmpush %eax)
        ))
    ; store word to local
    (storel0 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -4(%edi)")))
    (storel1 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -8(%edi)")))
    (storel2 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -12(%edi)")))
    (storel3 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -16(%edi)")))
    (storel4 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -20(%edi)")))
    (storel5 () @true ((asm "movl (%esi), %eax") (asm "movl %eax, -24(%edi)")))
    (storel (byte) @true (
        (vmsbyte 1 %ecx) ; index
        (asm "movl %edi, %eax")
        (asm "addl %ecx, %eax")
        (asm "movl (%esi), %ecx")
        (asm "movl %ecx, (%eax)")
        ))
    (incrl0 () @true ((asm "incl -4(%edi)")))
    (incrl1 () @true ((asm "incl -8(%edi)")))
    (incrl2 () @true ((asm "incl -12(%edi)")))
    (incrl3 () @true ((asm "incl -16(%edi)")))
    (incrl4 () @true ((asm "incl -20(%edi)")))
    (incrl5 () @true ((asm "incl -24(%edi)")))
    (incrl (byte) @true (
        (vmsbyte 1 %ecx) ; index
        (asm "movl %edi, %eax")
        (asm "addl %ecx, %eax")
        (asm "incl (%eax)")
        ))
    (decrl0 () @true ((asm "decl -4(%edi)")))
    (decrl1 () @true ((asm "decl -8(%edi)")))
    (decrl2 () @true ((asm "decl -12(%edi)")))
    (decrl3 () @true ((asm "decl -16(%edi)")))
    (decrl4 () @true ((asm "decl -20(%edi)")))
    (decrl5 () @true ((asm "decl -24(%edi)")))
    (decrl (byte) @true (
        (vmsbyte 1 %ecx) ; index
        (asm "movl %edi, %eax")
        (asm "addl %ecx, %eax")
        (asm "decl (%eax)")
        ))
    (addrl (byte) @true (
        (vmsbyte 1 %ecx) ; index
        (asm "movl %edi, %eax")
        (asm "addl %ecx, %eax")
        (vmpush %eax)
        ))
    ; load byte from value area
    (loadbv (ushort) @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movsbl (%eax), %eax")
        (vmpush %eax)
        ))
    ; load word from value area
    (loadv (ushort) @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movl (%eax), %eax")
        (vmpush %eax)
        ))
    ; load address of array from value area
    (loadav (ushort) @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (vmpush %eax)
        ))
    ; store byte to value area
    (storebv (ushort) @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movl (%esi), %ecx")
        (asm "movb %cl, (%eax)")
        ))
    ; store word to value area
    (storewv (ushort) @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movl (%esi), %ecx")
        (asm "movl %ecx, (%eax)")
        ))
    ; load global heap object
    (loado (ushort) @true (
        (vmushort 1 %eax)
        (asm "shll $2, %eax")
        (asm "addl gobject_area_base, %eax")
        (asm "movl (%eax), %eax")
        (vmpush %eax)
        ))
    ; store global heap object
    (storeo (ushort) @true (
        (vmushort 1 %eax)
        (asm "shll $2, %eax")
        (asm "addl gobject_area_base, %eax")
        (asm "movl (%esi), %ecx")
        (asm "movl %ecx, (%eax)")
        ))
    ; 'fun:1' 'relative address of the function:2'
    (fun (addr) @true (
        (vmsshort 1 %eax) ; offset of address of the function
        (asm "addl %ebx, %eax") ; compute absloute address
        (asm "subl code_base, %eax")
        (vmpush %eax)
        ))
    ; 'prim:1' 'index of the external function:2'
    (prim (prim) @true (
        (vmushort 1 %eax) ; index of the function
        (asm "orl  $0x80000000, %eax") ; set flag
        (vmpush %eax)
        ))
    ; 'call:1' 'relative address of the function:2' 'size of arguments:1'
    (call (addr byte)  @nil  (
        (asm "movl %ebx, %eax")
        (asm "addl $4, %eax")
        (vmpush %eax) ; store return point
        (vmpush %edi) ; store base pointer
        (asm "movl %esi, %edi") ; set base pointer
        (vmsshort 1 %eax) ; offset of address of the function
        (asm "addl %eax, %ebx")
        (vmfetch)
        ))
    ; 'pcall:1' 'index of the external function:2' 'size of arguments:1'
    (pcall (prim byte)  @true (
        (vmsave)
        (vmushort 1 %eax)
        (vmubyte 3 %ecx)
        (asm "pushl %esi") ; push argv
        (asm "pushl %ecx") ; push argsize
        (asm "pushl %eax") ; push index
        (call vm_pcall)
        (asm "addl $12, %esp")
        (vmrestore)
        (vmubyte 3 %ecx) ; total size of arguments
        (asm "addl %ecx, %esi") ; remove arguments from stack
        (vmpush %eax) ; push return value
        ))
    ; 'dcall:1' 'size of arguments:1'
    (dcall (byte) @nil (
        (asm "movl (%esi), %eax")
        (if (< (register %eax) 0) ; check flag
            ( ; call primitive function
                (vmpop %eax)
                (asm "movzwl %ax, %eax") ; function index is 2byte value
                (vmubyte 1 %ecx)
                (vmsave)
                (asm "pushl %esi") ; push argv
                (asm "pushl %ecx") ; push argsize
                (asm "pushl %eax") ; push index
                (call vm_pcall)
                (asm "addl $12, %esp")
                (vmrestore)
                (vmubyte 3 %ecx) ; total size of arguments
                (asm "addl %ecx, %esi") ; remove arguments from stack
                (vmpush %eax) ; push return value
            )
            ( ; absolute call
                (asm "movl %ebx, %ecx")
                (asm "addl $2, %ecx")
                (vmpop %ebx)
                (vmpush %ecx) ; store return point
                (vmpush %edi) ; store base pointer
                (asm "movl %esi, %edi") ; set base pointer
                (asm "addl code_base, %ebx")
                (vmfetch)
            ))
        ))
    ; 'jcall:1' 'size of arguments:1'
    (jcall (byte) @nil (
        (asm "movl %ebx, %ecx")
        (asm "addl $2, %ecx")
        (vmpop %ebx)
        (asm "movl (%ebx), %ebx") ; pointer to the bytecode
        (vmpush %ecx) ; store return point
        (vmpush %edi) ; store base pointer
        (asm "movl %esi, %edi") ; set base pointer
        (vmfetch)
        ))
    (jjump () @nil (
        (vmpop %ebx)
        (asm "movl (%ebx), %ebx")
        (vmfetch)
        ))
    (push (object) @true (
        (vmint 1 %eax)
        (vmpush %eax)
        ))
    (return () @nil  (
        (asm "movl $0, %ecx") ; return value
        (asm "movl %edi, %esi")
        (vmpop %edi) ; base pointer
        (vmpop %ebx) ; return address
        (asm "movzbl -1(%ebx), %eax") ; total size of arguments
        (asm "addl %eax, %esi")
        (vmpush %ecx) ; push return value
        (vmfetch)
        ))
    (ireturn () @nil  (
        (asm "movl (%esi), %ecx") ; return value
        (asm "movl %edi, %esi")
        (vmpop %edi) ; base pointer
        (vmpop %ebx) ; return address
        (asm "movzbl -1(%ebx), %eax") ; total size of arguments
        (asm "addl %eax, %esi")
        (vmpush %ecx) ; push return value
        (vmfetch)
        ))
    ; switch (table search)
    (tswitch (ushort) @nil (
        (vmpop %eax)
        (vmushort 1 %ecx) ; number of cases
        (asm "cmpl %eax, %ecx")
        (asm "cmovle %ecx, %eax")
        (asm "sall $1, %eax")
        (asm "addl $3, %ebx")
        (asm "addl %eax, %ebx")
        (asm "movzwl (%ebx), %eax")
        (asm "addl %eax, %ebx")
        (vmfetch)
        ))
    ; switch (linear search)
    (lswitch (int) @nil (
        (vmpop %eax)
        (vmint 1 %ecx) ; maximum value of case values
        (asm "addl $5, %ebx")
        (asm "1:")
        (asm "movl (%ebx), %edx") ; case value
        (asm "cmpl %eax, %edx")
        (asm "je 2f")
        (asm "cmpl %ecx, %edx")
        (asm "je 2f")
        (asm "addl $6, %ebx")
        (asm "jmp 1b")
        (asm "2:")
        (asm "xorl %edx, %edx") ; zero clear
        (asm "movzwl 4(%ebx), %eax")
        (asm "addl %eax, %ebx")
        (vmfetch)
        ))
    (goto       (addr) @nil ((vmsshort 1 %eax) (asm "addl %eax, %ebx") (vmfetch)))
    (dgoto      () @nil (
        (vmpop %ebx)
        (vmfetch)
        ))
    (if_zero    (addr) @nil @(gen_comparison1 "cmovz"))
    (if_nonzero (addr) @nil @(gen_comparison1 "cmovnz"))
    (if_eq      (addr) @nil @(gen_comparison2 "cmove"))
    (if_ne      (addr) @nil @(gen_comparison2 "cmovne"))
    (if_gt      (addr) @nil @(gen_comparison2 "cmovg"))
    (if_ge      (addr) @nil @(gen_comparison2 "cmovge"))
    (if_lt      (addr) @nil @(gen_comparison2 "cmovl"))
    (if_le      (addr) @nil @(gen_comparison2 "cmovle"))
    (if_true  (addr) @nil (
        (vmpop %eax)
        (asm "cmpl $1, %eax")
        (asm "movl $3, %eax")
        (vmsshort 1 %ecx)
        (asm "cmovne %ecx, %eax")
        (vmsucc %eax)
        (vmfetch)
        ))
    (if_false     (addr) @nil (
        (vmpop %eax)
        (asm "cmpl $1, %eax")
        (asm "movl $3, %eax")
        (vmsshort 1 %ecx)
        (asm "cmove %ecx, %eax")
        (vmsucc %eax)
        (vmfetch)
        ))
    (check_int  (addr) @nil (
        (vmpop %eax)
        (vmsshort 1 %ecx)
        (asm "andl $1, %eax")
        (asm "movl $3, %eax")
        (asm "cmovz %ecx, %eax")
        (vmsucc %eax)
        (vmfetch)
        ))
    (check_string (addr) @nil @(gen_check_plain PLAIN_STRING))
    (check_list (addr int) @nil (
        ; XXX: should not hardcode the layouer of object header.
        (vmpop %eax)
        (vmint 3 %ecx)
        (asm "0:")
        (asm "cmpl $0, %eax")
        (asm "je 1f")
        (asm "test $1, %eax")
        (asm "jnz 3f")
        (asm "movl -4(%eax), %edx")
        (asm "andl $7, %edx")
        (asm "cmpl $" @TAG_CONS ", %edx")
        (asm "jne 3f")
        (asm "movl 4(%eax), %eax")
        (asm "decl %ecx")
        (asm "jmp 0b")
        (asm "1:")
        (asm "cmpl $0, %ecx")
        (asm "je 2f")
        (asm "3:")
        (asm "xorl %edx, %edx")
        (vmsshort 1 %ecx)
        (vmsucc %ecx)
        (vmfetch)
        (asm "2:")
        (asm "xorl %edx, %edx")
        (vmsucc 7)
        (vmfetch)
        ))
    (exit () @nil ((vmpop %eax) (break)))
    ))

; insn-name -> (code len)
(var vm_insn_table (do
    (var code 0)
    (var entries ())
    (foreach i vm_instructions (do
        (var name (car i))
        (var len  (insn_length (cadr i)))
        (push entries `(@name @code @len))
        (incr code)
        ))
    (reverse entries)

    ))

(define IS_PRIM (v) `(< @v 0))
(define PRIM_IDX (v) `(& @v 0xffff))
