;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-util.rlc 2014-02-20 10:04:32 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(define PRINTABLE (c) `(&& (<= 0x20 @c) (<= @c 0x7e)))
(compile `object `(

(export fun output_char_escape (ochan t) (
    (if (== t '"')  (return (output_string ochan "\\\"")))
    (if @(PRINTABLE t) (return (output_char ochan t)))
    (if (== t '\\') (do (output_char ochan '\\') (output_char ochan '\\'))
    (if (== t '\a') (output_string ochan "\\a")
    (if (== t '\b') (output_string ochan "\\b")
    (if (== t '\f') (output_string ochan "\\f")
    (if (== t '\n') (output_string ochan "\\n")
    (if (== t '\r') (output_string ochan "\\r")
    (if (== t '\t') (output_string ochan "\\t")
    (if (== t '\v') (output_string ochan "\\v")
    (if (== t '\0') (output_string ochan "\\0")
        (do
            (output_string ochan "\\x")
            (output_hex ochan t 2)
        )
        )))))))))
    ))

(export fun output_string_escape (ochan str) (
    (var i 0)
    (while 1 (do
        (var c (array_get char str i))
        (if (! c) break)
        (output_char_escape ochan c)
        (incr i)
    ))
    ))

(export fun escape_char (c) (
    (if (== c '\\') (return "\\"))
    (if (== c '\a') (return "\\a"))
    (if (== c '\b') (return "\\b"))
    (if (== c '\f') (return "\\f"))
    (if (== c '\n') (return "\\n"))
    (if (== c '\r') (return "\\r"))
    (if (== c '\t') (return "\\t"))
    (if (== c '\v') (return "\\v"))
    (if (== c '\0') (return "\\0"))
    (if (== c '"')  (return "\\\""))
    (return (ctos c))
    ))

(fun unescape_char (c) (
    (if (== c '\\') (return '\\'))
    (if (== c 'a') (return '\a'))
    (if (== c 'b') (return '\b'))
    (if (== c 'f') (return '\f'))
    (if (== c 'n') (return '\n'))
    (if (== c 'r') (return '\r'))
    (if (== c 't') (return '\t'))
    (if (== c 'v') (return '\v'))
    (if (== c '0') (return '\0'))
    (if (== c '"') (return '"'))
    (not_reachable "unescape_char")
    ))

; unescape double-quoted string.
; NB: given argument will be overriden
(export fun unescape_string_d (str) (
    (var len (strlen str))
    (var i 0)
    (var j 0)
    (while (< i len) (do
        (var c (array_get char str i))
        (if (== c '\\') (do
            (incr i)
            (= c (unescape_char (array_get char str i)))
            ))
        (array_set char str j c)
        (incr i)
        (incr j)
        ))
    (array_set char str j 0)
    ))

;; unescape single-quoted string.
;; NB: given argument will be overriden
;(export fun unescape_string_s (str) (
;    (var len (strlen str))
;    (var i 0)
;    (var j 0)
;    (while (< i len) (do
;        (var c (array_get char str i))
;        (if (== c '\\') (do
;            (incr i)
;            (var d (array_get char str i))
;            (if (|| (== d ''') (== d '\\'))
;                (array_set char str j d)
;                (do
;                    (array_set char str j '\\')
;                    (incr j)
;                    (array_set char str j d)
;                ))
;            )
;            (array_set char str j c)
;            )
;        (incr i)
;        (incr j)
;        ))
;    (array_set char str j 0)
;    ))

(export fun list1 (v) (
    (return (cons v 0))
    ))

(export fun list2 (v1 v2) (
    (return (cons v1 (cons v2 0)))
    ))

(export fun list3 (v1 v2 v3) (
    (return (cons v1 (cons v2 (cons v3 0))))
    ))

(export fun list4 (v1 v2 v3 v4) (
    (return (cons v1 (cons v2 (cons v3 (cons v4 0)))))
    ))

(export fun list5 (v1 v2 v3 v4 v5) (
    (return (cons v1 (cons v2 (cons v3 (cons v4 (cons v5 0))))))
    ))

(export fun list6 (v1 v2 v3 v4 v5 v6) (
    (return (cons v1 (cons v2 (cons v3 (cons v4 (cons v5 (cons v6 0)))))))
    ))

(export fun diag_list (len v) (
    (if (== len 0) (return 0))
    (return (cons v (diag_list (- len 1) v)))
    ))

(export fun list_reverse (ls) (
    (var new_ls 0)
    (while ls (do
        (= new_ls (cons (car ls) new_ls))
        (= ls (cdr ls))
        ))
    (return new_ls)
    ))

(export fun list_append (ls1 ls2) (
    (if (! ls1) (return ls2))
    (return (cons (car ls1) (list_append (cdr ls1) ls2)))
    ))

(export fun list_delete (val ls) (
    (var p 0)
    (var ret ls)
    (while ls (do
        (if (== (car ls) val) (do
            (if (! p)
                (= ret (cdr ls))
                (setcdr p (cdr ls))
                )
            break
            ))
        (= p ls)
        (= ls (cdr ls))
        ))
    (return ret)
    ))

(export fun list_insert_uniq (val ls) (
    (if (! ls) (return (list1 val)))
    (if (== (car ls) val) (return ls))
    (return (cons (car ls) (list_insert_uniq val (cdr ls))))
    ))

(export fun list_member (val ls) (
    (while ls (do
        (if (== val (car ls)) (return @TRUE))
        (= ls (cdr ls))
        ))
    (return @FALSE)
    ))

(export fun list_drop (ls n) (
    (while (> n 0) (do
        (= ls (cdr ls))
        (decr n)
        ))
    (return ls)
    ))

(export fun list_copy (ls) (
    (if (! ls) (return 0))
    (return (cons (car ls) (list_copy (cdr ls))))
    ))

(export fun list_split (ls n) (
    (if (== n 0) (return (cons 0 ls)))
    (var hd ls)
    (while (> n 1) (do
        (= ls (cdr ls))
        (decr n)
        ))
    (var tl (cdr ls))
    (setcdr ls 0)
    (return (cons hd tl))
    ))

(fun is_prefix (pre str) (
    (var i 0)
    (while 1 (do
        (var a (array_get char pre i))
        (if (! a) (return @TRUE))
        (var b (array_get char str i))
        (if (!= a b) (return @FALSE))
        (incr i)
        ))
    ))

(fun is_suffix (post str) (
    (var post_len (strlen post))
    (var str_len (strlen str))
    (return (streq (+ str (- str_len post_len)) post))
    ))

(export fun get_env (name) (
    (var envp (environ))
    (var i 0)
    (while 1 (do
        (var ent (array_get string envp i))
        (if (! ent) (return 0))
        (if (is_prefix name ent) (do
            (return (strdup (+ ent (+ (strlen name) 1))))
            ))
        (incr i)
        ))
    ))

(export fun add_extension (post path) (
    (if (! (is_suffix post path))
        (return (strcat path post))
        (return path)
        )
    ))

(export fun get_directory (path) (
    (var len (- (strlen path) 1))
    (var dir (strdup path))
    (while (> len 0) (do
        (if (== (array_get char dir len) '/') (do
            (array_set char dir len 0)
            break
            ))
        (-= len 1)
        ))
    (if (== len 0) (do
        (return (string "."))
        ))
    (return dir)
    ))

(export fun not_reachable (name) (
    (flush stdout)
    (output_string stderr "INTERNAL ERROR: ")
    (output_string stderr name)
    (output_string stderr " : not reachable here")
    (exit 1)
    ))

(export fun not_implemented (name) (
    (flush stdout)
    (output_string stderr "INTERNAL ERROR: ")
    (output_string stderr name)
    (output_string stderr " : not implemented here")
    (exit 1)
    ))

(extern fun pprint)
(extern fun pprint_debug)

(export fun debugc (c) ((output_char stderr c)))
(export fun debugs (s) ((output_string stderr s)))
(export fun debugi (i) ((output_int stderr i)))
(export fun debugx (x) ((output_hex stderr x 8)))
(export fun debugp (o) ((pprint stderr o) (debugc '\n')))
(export fun debugpf (o) ((pprint_debug stderr o) (debugc '\n')))

    ))
