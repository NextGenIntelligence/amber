;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-util.rlc 2010-10-25 23:09:22 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; location of source code
; (Single, file, line)
; (Multi, file, begin line, end line)
(var Single 0)
(var Multi  1)

(compile `object `(

(export fun make_loc (file line) (
    (return (variant @Single 1 file line))
    ))

(export fun merge_loc (loc1 loc2) (
    (var type1 (field_get loc1 0))
    (var type2 (field_get loc2 0))
    (if (== type1 type2)
        (if (== type1 @Single)
            (return (merge_loc_single loc1 loc2))
            (return (merge_loc_multi loc1 loc2))
            )
        (if (== type1 @Single)
            (return (merge_loc_single_multi loc1 loc2))
            (return (merge_loc_multi_single loc1 loc2))
            ))
    ))

(fun merge_loc_single (loc1 loc2) (
    (return (variant @Multi 1
        (field_get loc1 1)
        (field_get loc1 2)
        (field_get loc2 2)
        ))
    ))
(fun merge_loc_multi (loc1 loc2) (
    (return (variant @Multi 1
        (field_get loc1 1)
        (field_get loc1 2)
        (field_get loc2 3)
        ))
    ))
(fun merge_loc_single_multi (loc1 loc2) (
    (return (variant @Multi 1
        (field_get loc1 1)
        (field_get loc1 2)
        (field_get loc2 3)
        ))
    ))
(fun merge_loc_multi_single (loc1 loc2) (
    (return (variant @Multi 1
        (field_get loc1 1)
        (field_get loc1 2)
        (field_get loc2 2)
        ))
    ))

(export fun output_srcloc (ochan loc) (
    (var type (field_get loc 0))
    (output_string ochan (field_get loc 1)) ; file
    (output_char ochan ':')
    (if (== type @Single)
        (output_int ochan (field_get loc 2))
        (do
            (output_int ochan (field_get loc 2))
            (output_char ochan '-')
            (output_int ochan (field_get loc 3))
        ))
    ))

(export fun error_head (ochan loc) (
    (output_char ochan '[')
    (output_srcloc ochan loc)
    (output_string ochan "] ERROR: ")
    ))

(export fun output_char_escape (ochan t) (
    (if (== t '\\') (do (output_char ochan '\\') (output_char ochan '\\'))
    (if (== t '\a') (output_string ochan "\\a")
    (if (== t '\b') (output_string ochan "\\b")
    (if (== t '\f') (output_string ochan "\\f")
    (if (== t '\n') (output_string ochan "\\n")
    (if (== t '\r') (output_string ochan "\\r")
    (if (== t '\t') (output_string ochan "\\t")
    (if (== t '\v') (output_string ochan "\\v")
    (if (== t '\0') (output_string ochan "\\0")
        (output_char ochan t)
        )))))))))
    ))

(fun unescape_char (c) (
    (if (== c '\\') (return '\\'))
    (if (== c 'a') (return '\a'))
    (if (== c 'b') (return '\b'))
    (if (== c 'f') (return '\f'))
    (if (== c 'n') (return '\n'))
    (if (== c 'r') (return '\r'))
    (if (== c 't') (return '\t'))
    (if (== c 'v') (return '\v'))
    (if (== c '0') (return '\0'))
    (not_reachable "unescape_char")
    ))

(export fun unescape_string (str) (
    (var len (strlen str))
    (var i 0)
    (var j 0)
    (while (< i len) (do
        (var c (array_get char str i))
        (if (== c '\\') (do
            (incr i)
            (= c (unescape_char (array_get char str i)))
            ))
        (array_set char str j c)
        (incr i)
        (incr j)
        ))
    (array_set char str j 0)
    ))

(export fun list_length (ls) (
    (var len 0)
    (while ls (do
        (= ls (cdr ls))
        (incr len)
        ))
    (return len)
    ))

(export fun list_reverse (ls) (
    (var new_ls 0)
    (while ls (do
        (= new_ls (cons (car ls) new_ls))
        (= ls (cdr ls))
        ))
    (return new_ls)
    ))

(export fun not_reachable (name) (
    (flush stdout)
    (output_string stderr "INTERNAL ERROR: ")
    (output_string stderr name)
    (output_string stderr " : not reachable here")
    (exit 1)
    ))

(export fun not_implemented (name) (
    (flush stdout)
    (output_string stderr "INTERNAL ERROR: ")
    (output_string stderr name)
    (output_string stderr " : not implemented here")
    (exit 1)
    ))

    ))
