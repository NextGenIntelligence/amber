;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-lex.rlc 2011-12-13 01:24:41 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; Regular expressions
;
; comment    : #[^\n]*
; spaces     : [\n\r\t ]
; letter     : [A-Za-z_]
; deciaml    : 0|([1-9][0-9]*(e[1-9][0-9]*)?)
; binary     : 0b[01]+
; octal      : 0o[0-7]+
; hex        : 0x[0-9a-fA-F]+
; float      : {decimal}\.[0-9]+(e(+|-)?[0-9]+)?
; escape     : \\['"\\abfnrtv0]
; character  : \'({escape}|[^\\\'\n])\'
; string     : \"({escape}|[^\\\"\n]*\"
; opchar     : [!#$%&=-^|@+*:/?<>.,]
; identifier : {letter}({letter}|[0-9_])*

; character group

(var CH_EOF        0) ; "\0"
(var CH_SPACES     1) ; "\t\r "
(var CH_NL         2) ; "\n"
(var CH_0          3) ; "0"
(var CH_1          4) ; "1"
(var CH_2_7        5) ; "1234567"
(var CH_8_9        6) ; "89"
(var CH_af         7) ; "af"
(var CH_b          8) ; "b"
(var CH_e          9) ; "e"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_HEX       14) ; "ABCDEFabcdef"
(var CH_OTHER     15) ; "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
(var CH_SQUOTE    16) ; "'"
(var CH_DQUOTE    17) ; "\""
(var CH_SLASH     18) ; "/"
(var CH_BACKSLASH 19) ; "\\"
(var CH_SHARP     20) ; "#"
(var CH_DOT       21) ; "."
(var CH_PLUSMINUS 22) ; "+-"
(var CH_SPECIAL   23) ; ",()[]{}"
(var CH_OPCHAR    24) ; "!$%&=^|@*:;/\\?<>~`"
(var CH_INVALID   25)

; === state transition diagram ===
;
;    spaces
;   +---+--------------------+
;   v   |                    |
; +---+ | EOF   +---+        |
; | 0 +-+------>|@13| (end)  |
; +---+ |       +---+        |
;       | #     +---+        | (comment)
;       +------>| 14+-+------+
;       |       +---+ |
;       |         ^   |[^\n]
;       |         +---+
;       | 0     +---+
;       +------>|@15|              +---+
;       |       +-+-+              v   |01
;       |         | b  +---+01   +---+ |
;       |         +--->| 16+---->|@17+-+   +---+
;       |         |    +---+     +---+     v   |0-7
;       |         | o         +---+0-7   +---+ |
;       |         +---------->| 18+----->|@19+-+    +---+
;       |         |           +---+      +---+      v   |{hex}
;       |         | x                +---+        +---+ |
;       |         +----------------->| 20+------->|@21+-+                 +---+
;       |         +-------+.         +---+ {hex}  +---+                   v   |0-9
;       | 1-9   +---+  .  |   +---+      +---+  e    +---+ 1-9          +---+ |
;       +------>|@22+-+---+-->| 23+----->|@24+-+---->| 25+-----------+->|@27+-+
;       |       +---+ |       +---+ 0-9  +---+ |     +-+-+           |  +---+
;       |         A   |0-9                 A   |0-9    | +-   +---+  |
;       |         +---+                    +---+       +----->| 26+--+
;       | '     +---+ [^\\\n]        +---+ '    +---+         +---+ 1-9
;       +------>| 28+--------------->| 29+----->|@1 |
;       |       +-+-+                +---+      +---+
;       |         |\    +---+ '"\\abfnrtv0   +---+ '  +---+
;       |         +---->| 30+--------------->| 31+--->|@1 |
;       |               +---+                +---+    +---+
;       | "     +---+              "    +---+
;       +------>| 32+-+----------+----->|@34|
;       |       +---+ |          |      +---+
;       |         A   |[^\\\"\n] |\
;       |         +---+          |
;       |         |              v
;       |         |'"\\abfnrtv0+---+
;       |         +------------+ 33|
;       |                      +---+
;       |{letter}+---+
;       +------->|@35+-+
;       |        +---+ |{letter}|[0-9]
;       |          A   |
;       |          +---+
;       |{opchar}+---+           +---+
;       +------->| 36+-+-------->|@37|
;       |        +---+ |         +---+
;       |          A   |{opchar}
;       |          +---+
;       |{special} +---+
;       +--------->|@38|
;                  +---+
;
;
;
; 1 : accept token
;
; error state:
;
; 2 : invalid character
; 3 : invalid decimal integer literal
; 4 : invalid binary integer literal
; 5 : invalid octal integer literal
; 6 : invalid hexadecimal integer literal
; 7 : invalid floating point literal
; 8 : invalid escape sequence
; 9 : unterminated character literal
; 10: unterminated string literal
; 11: invalid symbol literal
; 12: undefined operator

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")

(array char chgroup (
     0 25 25 25 25 25 25 25 25  1  2 25 25  1 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
     1 24 17 20 24 24 24 16 23 23 24 22 23 22 21 18
     3  4  5  5  5  5  5  5  6  6 24 24 24 24 24 24
    24 14 14 14 14 14 14 15 15 15 15 15 15 15 15 15
    15 15 15 15 15 15 15 15 15 15 15 23 19 23 24 15
    24  7  8 14 14  9  7 15 15 15 15 15 15 15 13 10
    15 15 11 15 11 15 11 15 12 15 15 23 24 23 24 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    ))

;                     C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C
;                     H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H
;                     _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
;                     E  S  N  0  1  2  8  a  b  e  o  r  x  n  H  O  S  D  S  B  S  D  P  S  O  I
;                     O  P  L  :  :  _  _  f  :  :  :  t  :  :  E  T  Q  Q  L  A  H  O  L  P  P  N
;                     F  A  :  :  :  7  9  :  :  :  :  v  :  :  X  H  U  U  A  C  A  T  U  E  C  V
;                     :  C  :  :  :  :  :  :  :  :  :  :  :  :  :  E  O  O  S  K  R  :  S  C  H  A
;                     :  E  :  :  :  :  :  :  :  :  :  :  :  :  :  R  T  T  H  S  P  :  M  I  A  L
;                     :  S  :  :  :  :  :  :  :  :  :  :  :  :  :  :  E  E  :  L  :  :  I  A  R  I
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  A  :  :  N  L  :  D
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  S  :  :  U  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  H  :  :  S  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :
(array char s0next  (13  2  2 15 22 22 22 35 35 35 35 35 35 35 35 35 28 32 36 36  2 36 36 38 36 2))
(array char s15next ( 1  1  1  3  3  3  3  3 16  3 18  3 20  3  3  3  1  1  1  1  1 23  1  1  1 2))
(array char s17next ( 1  1  1 17 17  4  4  4  4  4  4  4  4  4  4  4  1  1  1  1  1  4  1  1  1 2))
(array char s19next ( 1  1  1 19 19 19  5  5  5  5  5  5  5  5  5  5  1  1  1  1  1  5  1  1  1 2))
(array char s21next ( 1  1  1 21 21 21 21 21 21 21  6  6  6  6 21  6  1  1  1  1  1  6  1  1  1 2))
(array char s22next ( 1  1  1 22 22 22 22  3  3 23  3  3  3  3  3  3  1  1  1  1  1 23  1  1  1 2))
(array char s24next ( 1  1  1 24 24 24 24  7  7 25  7  7  7  7  7  7  1  1  1  1  1  7  1  1  1 2))
(array char s27next ( 1  1  1 27 27 27 27  7  7  7  7  7  7  7  7  7  1  1  1  1  1  7  1  1  1 2))
(array char s28next ( 9 29  9 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 30 29 29 29 29 29 2))
(array char s30next ( 8  8  8 31  8  8  8 31 31  8  8 31  8 31  8  8 31 31  8 31  8  8  8  8  8 2))
(array char s32next (10 32 10 32 32 32 32 32 32 32 32 32 32 32 32 32 32 34 32 33 32 32 32 32 32 2))
(array char s33next ( 8  8  8 32  8  8  8 32 32  8  8 32  8 32  8  8 32 32  8 32  8  8  8  8  8 2))
(array char s35next ( 1  1  1 35 35 35 35 35 35 35 35 35 35 35 35 35  1  1  1  1  1  1  1  1  1 2))
(array char s36next (37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 36 36 37 36 36 37 36 2))

(array char grp_0_9 ( 0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_1_9 ( 0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_oct ( 0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_hex ( 0  0  0  1  1  1  1  1  1  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0))

(var lexichan null)
(var lexbuf null)
(var lexbuf_end 0)
(var token_tag @TOK_NONE)
(var token_unboxed 0) ; for integer
(var token_boxed null)
(var token_buf null)
(var srcfile null)
(var srcline 1)
(var srcclmn 1)
(var next_srcfile null)
(var next_srcline 1)
(var next_srcclmn 1)
(var prev_srcfile null)
(var prev_srcline 1)
(var prev_srcclmn 1)
(var newline 1)
(var unputted 0)
(var lexer_stack null)

(extern object current_mod)

(fun is_member_of (c group) ((return (array_get char group c))))

(export fun get_token_text () ((return (cvector_raw token_buf))))
(export fun get_token_len  () ((return (- (cvector_size token_buf) 1))))
(export fun get_token_unboxed () ((return token_unboxed)))
(export fun get_token_boxed () ((return token_boxed)))
(export fun get_clmn () ((return srcclmn)))
(export fun get_loc () (
    (if unputted
	(return (make_loc prev_srcfile prev_srcline prev_srcline))
	(return (make_loc srcfile srcline srcline))
	)
    ))

(array char esc2val_table (
    34 0 0 0 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 0 0 0 0 0 92 0 0 0 0 7 8 0 0 0 12 0
     0 0 0 0 0 0 10 0 0 0 13 0 9 0 11
    ))
(fun esc2val (c) (
    (return (- (array_get char esc2val_table c) '"'))
    ))

(fun init_token_buf () (
    (= token_tag @TOK_NONE)
    (= token_unboxed 0)
    (cvector_resize token_buf 0)
    (cvector_pushback token_buf '\0')
    return
    ))

(fun lookahead () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (return @CH_EOF))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (if (== c -1) (return @CH_EOF))
    (return (array_get char chgroup c))
    ))

(fun read_char () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (error "unexpected EOF"))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (incr lexbuf_end)
    (if (== c '\n')
	(do
	    (incr next_srcline)
	    (= next_srcclmn 1)
	    (= newline @TRUE)
        )
	(do
	    (incr next_srcclmn)
	    (if (!= c ' ') (= newline @FALSE))
	)
        )
    (return c)
    ))

(fun consume () (
    (var c (read_char))
    (cvector_put token_buf (- (cvector_size token_buf) 1) c)
    (cvector_pushback token_buf '\0')
    (return c)
    ))

(fun ignore () (
    (read_char)
    ))

(export fun unput () (
    (if unputted (error "try to unput two or more tokens\n"))
    (= unputted 1)
    return
    ))

(fun next_state (table) (
    (return (array_get char table (lookahead)))
    ))

(fun accept (tag) (
    (= token_tag tag)
    return
    ))

(export fun output_token (ochan t) (
    (if (== t @TOK_CHAR) (output_string ochan "character")
    (if (== t @TOK_INT) (output_string ochan "integer")
    (if (== t @TOK_FLOAT) (output_string ochan "floating point")
    (if (== t @TOK_STRING) (output_string ochan "string")
    (if (== t @TOK_SYMBOL) (output_string ochan "symbol")
    (if (== t @TOK_PREFIX) (output_string ochan "prefix operator")
    (if (== t @TOK_POSTFIX) (output_string ochan "postfix operator")
    (if (== t @TOK_INFIX) (output_string ochan "infix operator")
        (do
            (if (>= t 256) (error "BUG: output_token : not reachable"))
            (output_char ochan ''')
            (output_char_escape ochan t)
            (output_char ochan ''')
        )))))))))
    ))

(fun lex_error (msg) (
    (flush stdout)
    (if srcfile (do
        (output_string stderr srcfile)
        (output_char   stderr ':')
        (output_int    stderr srcline)
        (output_char   stderr ':')
        (output_int    stderr srcclmn)
        (output_string stderr ": ")
        ))
    (output_string stderr msg)
    (output_string stderr ": ")
    (output_string stderr (get_token_text))
    (output_char   stderr '\n')
    (exit 1)
    ))

(export fun init_lexer (fname ichan) (
    (= next_srcfile (strdup fname))
    (= next_srcline 1)
    (= next_srcclmn 1)
    (= token_tag @TOK_NONE)
    (= token_unboxed 0)
    (= unputted 0)
    (= lexichan ichan)
    (= token_buf (make_cvector 0))
    (cvector_pushback token_buf '\0')
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)

    ; setup special constructors
    (add_constr DefInfixL "infixl")
    (add_constr DefInfixR "infixr")
    (add_constr DefPrefix "prefix")
    (add_constr DefPostfix "postfix")
    (add_constr DefConstr "constr")
    (add_constr DefCommand "command")
	(add_constr DefModule "module")
    ))

; XXX: not good design. should implement reentrant lexer
(export fun push_lexer (fname ichan) (
    (var state (struct 3 next_srcfile lexichan lexbuf next_srcline next_srcclmn lexbuf_end))
    (= lexer_stack (cons state lexer_stack))
    (= next_srcfile (strdup fname))
    (= next_srcline 1)
    (= next_srcclmn 1)
    (= lexichan ichan)
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)
    ))

(export fun pop_lexer () (
    (var state (car lexer_stack))
    (= lexer_stack (cdr lexer_stack))
    (= next_srcfile (struct_at state 0))
    (= next_srcline (struct_at state 3))
    (= next_srcclmn (struct_at state 4))
    (= lexichan     (struct_at state 1))
    (= lexbuf       (struct_at state 2))
    (= lexbuf_end   (struct_at state 5))
    ))

(export fun lex () ((return (lex_main 0 0))))
(export fun lex_sub (offs)   ((return (lex_main 0 offs))))
(export fun lex_infix (offs) ((return (lex_main 1 offs))))

(fun lex_main (infix_p offs) (
    (if unputted (do
        (= unputted 0)
        (var op (lookup_operator current_mod (get_token_text)))
        (if op (accept_operator op infix_p))
        (return token_tag)
        ))

    (skip_spaces)

    (if (&& newline (<= next_srcclmn offs)) (do
	(accept @TOK_END)
	(return @TOK_END)
	))

    (= prev_srcfile srcfile)
    (= prev_srcline srcline)
    (= prev_srcclmn srcclmn)
    (= srcfile next_srcfile)
    (= srcline next_srcline)
    (= srcclmn next_srcclmn)

    (var state 0)
    (label lexloop)
    (tswitch state (
        (0 . (do
            (init_token_buf)
            (= state (next_state s0next))
            (goto lexloop)
            ))
        (1  . (do
	    (return token_tag)
	    ))
        (2  . (lex_error "invalid character"))
        (3  . (lex_error "invalid decimal integer literal"))
        (4  . (lex_error "invalid binary integer literal"))
        (5  . (lex_error "invalid octal integer literal"))
        (6  . (lex_error "invalid hexadecimal integer literal"))
        (7  . (lex_error "invalid floating point literal"))
        (8  . (lex_error "invalid escape sequenc"))
        (9  . (lex_error "unterminated character literal"))
        (10 . (lex_error "unterminated string literal"))
        (11 . (lex_error "invalid symbol literal"))
        (12 . (lex_error "undefined operator"))
        (13 . (do
            (= token_tag @TOK_EOF)
            (return @TOK_EOF)
            ))
        (14 . (do
	    (not_reachable "lex_main")
            ))
        (15 . (do
            (consume)
            (accept @TOK_INT)
            (= state (next_state s15next))
            (goto lexloop)
            ))
        (16 . (do
            (consume)
            (var c (lookahead))
            (if (&& (!= c @CH_0) (!= c @CH_1)) (do
                (= state 4)
                (goto lexloop)
                ))
            ; fall through
            ))
        (17 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_unboxed 1)
            (|= token_unboxed (- c '0'))
            (= state (next_state s17next))
            (goto lexloop)
            ))
        (18 . (do
            (consume)
            (if (! (is_member_of grp_oct (lookahead))) (do
                (= state 5)
                (goto lexloop)
                ))
            ; fall through
            ))
        (19 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_unboxed 3)
            (|= token_unboxed (- c '0'))
            (= state (next_state s19next))
            (goto lexloop)
            ))
        (20 . (do
            (consume)
            (if (! (is_member_of grp_hex (lookahead))) (do
                (= state 6)
                (goto lexloop)
                ))
            ; fall through
            ))
        (21 . (do
            (accept @TOK_INT)
            (<<= token_unboxed 4)
            (var c (consume))
            (if (<= 'a' c)
                (|= token_unboxed (+ (- c 'a') 10))
            (if (<= 'A' c)
                (|= token_unboxed (+ (- c 'A') 10))
                (|= token_unboxed (- c '0'))
                ))
            (= state (next_state s21next))
            (goto lexloop)
            ))
        (22 . (do
            (accept @TOK_INT)
            (= token_unboxed (+ (* 10 token_unboxed) (- (consume) '0')))
            (= state (next_state s22next))
            (goto lexloop)
            ))
        (23 . (do
            (consume)
            (if (! (is_member_of grp_0_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            ; fall through
            ))
        (24 . (do
            (consume)
            (accept @TOK_FLOAT)
            (= state (next_state s24next))
            (goto lexloop)
            ))
        (25 . (do
            (consume)
            (var c (lookahead))
            (if (is_member_of grp_1_9 c) (do
                (= state 27)
                (goto lexloop)
                ))
            (if (== c @CH_PLUSMINUS) (do
                (= state 26)
                (goto lexloop)
                ))
            (= state 7)
            (goto lexloop)
            ))
        (26 . (do
            (consume)
            (if (! (is_member_of grp_1_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            (= state 27)
            (goto lexloop)
            ))
        (27 . (do
            (consume)
            (= state (next_state s27next))
            (goto lexloop)
            ))
        (28 . (do
            (consume)
            (= state (next_state s28next))
            (goto lexloop)
            ))
        (29 . (do
            (consume)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (accept @TOK_CHAR)
                (var str (get_unquoted_token_text))
                (unescape_string str)
                (= token_boxed (string str))
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (30 . (do
            (consume)
            (= state (next_state s30next))
            (goto lexloop)
            ))
        (31 . (do
            (consume)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (accept @TOK_CHAR)
                (var str (get_unquoted_token_text))
                (unescape_string str)
                (= token_boxed (string str))
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (32 . (do
            (consume)
            (= state (next_state s32next))
            (goto lexloop)
            ))
        (33 . (do
            (consume)
            (= state (next_state s33next))
            (goto lexloop)
            ))
        (34 . (do
            (consume)
            (accept @TOK_STRING)
            (var str (get_unquoted_token_text))
            (unescape_string str)
            (= token_boxed (string str))
            (= state 1)
            (goto lexloop)
            ))
        (35 . (do
            (consume)
            (= state (next_state s35next))
	    (if (== state 1) (do
                (var op (lookup_operator current_mod (get_token_text)))
                (if op
                    (accept_operator op infix_p)
                    (do
                        (accept @TOK_SYMBOL)
                        (= token_boxed (to_sym (get_token_text)))
                    ))
		))
            (goto lexloop)
            ))
        (36 . (do
            (consume)
            (var op (lookup_operator current_mod (get_token_text)))
            (if op
                (do
                    (accept_operator op infix_p)
                    (store_lexer_state)
                ))
            (= state (next_state s36next))
            (goto lexloop)
            ))
        (37 . (do
            (if (== token_tag @TOK_NONE) (do
                (= state 12)
                (goto lexloop)
                ))
            (restore_lexer_state)
            (= state 1)
            (goto lexloop)
            ))
        (38 . (do
            (accept (consume))
            (= state 1)
            (goto lexloop)
            ))
        (default . (error "BUG: invalid state"))
        ))
    (error "BUG: not reachable")
    ))

(fun skip_spaces () (
    (var c (lookahead))
    (while 1 (do
	(if (== c @CH_SHARP) (do
	    (ignore)
	    (while (!= (lookahead) @CH_NL) (ignore))
	    (ignore)
	    )
	(if (|| (== c @CH_SPACES) (== c @CH_NL)) (do
	    (while (|| (== c @CH_SPACES) (== c @CH_NL)) (do
		(ignore)
		(= c (lookahead))
		))
	    )
	    break
	    ))
	(= c (lookahead))
	))
    ))

(var save_lexbuf_end 0)
(var save_srcline 0)
(var save_srcclmn 0)
(var save_token_len 0)
(var save_token_unboxed 0)
(var save_token_boxed null)
(fun store_lexer_state () (
    (= save_lexbuf_end lexbuf_end)
    (= save_srcline next_srcline)
    (= save_srcclmn next_srcclmn)
    (= save_token_len (get_token_len))
    (= save_token_unboxed (get_token_unboxed))
    (= save_token_boxed (get_token_boxed))
    ))

(fun restore_lexer_state () (
    (= lexbuf_end save_lexbuf_end)
    (= next_srcline save_srcline)
    (= next_srcclmn save_srcclmn)
    (cvector_resize token_buf save_token_len)
    (cvector_pushback token_buf '\0')
    (= token_unboxed save_token_unboxed)
    (= token_boxed save_token_boxed)
    ))

(fun get_unquoted_token_text () (
    (var str (get_token_text))
    (var len (- (get_token_len) 2))
    (var new (array char (+ len 1)))
    (strncpy new (+ str 1) len)
    (return new)
    ))

(fun accept_operator (op infix_p) (
    (var optype (field_get op 0))
    (if (== optype @OP_PREFIX) (accept @TOK_PREFIX)
    (if (== optype @OP_POSTFIX) (accept @TOK_POSTFIX)
    (if (== optype @OP_INFIX) (accept @TOK_INFIX)
    (if (== optype @OP_CONSTR) (accept @TOK_CONSTR)
    (if (== optype @OP_COMMAND) (accept @TOK_COMMAND)
    (if (== optype @OP_PREFIX_OR_INFIX) (do
        (if infix_p
            (do (accept @TOK_INFIX) (= op (field_get op 2)))
            (do (accept @TOK_PREFIX) (= op (field_get op 1)))
            )
        )
        ))))))
    (= token_boxed op)
    ))

(fun check_assoc (name assoc) (
    (if (&& (> assoc @ASSOC_PRIMARY) (< assoc @ASSOC_MAX)) return)
    (output_error stderr)
    (output_string stderr "associativity of operator `")
    (output_string stderr name)
    (output_string stderr "' must be ")
    (output_int stderr @(+ ASSOC_PRIMARY 1))
    (output_string stderr " to ")
    (output_int stderr @ASSOC_MAX)
    (output_string stderr "\n")
    (exit 1)
    ))

(fun is_idhead (c) (
    (var group (array_get char chgroup c))
    (if (== group @CH_af) (return @TRUE))
    (if (== group @CH_b) (return @TRUE))
    (if (== group @CH_e) (return @TRUE))
    (if (== group @CH_o) (return @TRUE))
    (if (== group @CH_rtv) (return @TRUE))
    (if (== group @CH_x) (return @TRUE))
    (if (== group @CH_n) (return @TRUE))
    (if (== group @CH_HEX) (return @TRUE))
    (if (== group @CH_OTHER) (return @TRUE))
    (return @FALSE)
    ))

(fun is_idletter (c) (
    (var group (array_get char chgroup c))
    (if (== group @CH_0) (return @TRUE))
    (if (== group @CH_1) (return @TRUE))
    (if (== group @CH_2_7) (return @TRUE))
    (if (== group @CH_8_9) (return @TRUE))
    (if (== group @CH_af) (return @TRUE))
    (if (== group @CH_b) (return @TRUE))
    (if (== group @CH_e) (return @TRUE))
    (if (== group @CH_o) (return @TRUE))
    (if (== group @CH_rtv) (return @TRUE))
    (if (== group @CH_x) (return @TRUE))
    (if (== group @CH_n) (return @TRUE))
    (if (== group @CH_HEX) (return @TRUE))
    (if (== group @CH_OTHER) (return @TRUE))
    (return @FALSE)
    ))

(fun is_opchar (c) (
    (var group (array_get char chgroup c))
    (if (== group @CH_SLASH) (return @TRUE))
    (if (== group @CH_BACKSLASH) (return @TRUE))
    (if (== group @CH_DOT) (return @TRUE))
    (if (== group @CH_PLUSMINUS) (return @TRUE))
    (if (== group @CH_OPCHAR) (return @TRUE))
    (return @FALSE)
    ))

(fun check_operator_format (name) (
    (var i 0)
    (var c (array_get char name 0))
    (if (is_idhead c) (do
        (incr i)
        (while 1 (do
            (= c (array_get char name i))
            (if (! c) return)
            (if (! (is_idletter c)) break)
            (incr i)
            ))
        )
    (if (is_opchar c) (do
        (incr i)
        (while 1 (do
            (= c (array_get char name i))
            (if (! c) return)
            (if (! (is_opchar c)) break)
            (incr i)
            ))
        )))
    (output_error stderr)
    (output_string stderr "invalid string for operator, \"")
    (output_string_escape stderr name)
    (output_string stderr "\"\n")
    (exit 1)
    ))


(export fun add_prefix (head repr assoc) (
    (check_operator_format repr)
    (check_assoc repr assoc)
    (var new_op (variant @OP_PREFIX 2 head repr assoc))
    (var op (lookup_operator current_mod repr))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_INFIX) (do
            (add_operator current_mod repr 0 (variant @OP_PREFIX_OR_INFIX 2 new_op op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator current_mod repr 0 (variant @OP_PREFIX_OR_INFIX 2 new_op (field_get op 2)))
            return
            ))
        ))
    (add_operator current_mod repr head new_op)
    return
    ))

(export fun add_postfix (head repr assoc) (
    (check_operator_format repr)
    (check_assoc repr assoc)
    (var op (variant @OP_POSTFIX 2 head repr assoc))
    (add_operator current_mod repr head op)
    ))

(export fun add_infixl (head repr assoc) ((add_infix head repr assoc @TRUE)))
(export fun add_infixr (head repr assoc) ((add_infix head repr assoc @FALSE)))
(fun add_infix (head repr assoc is_left) (
    (check_operator_format repr)
    (check_assoc repr assoc)
    (var new_op (variant @OP_INFIX 2 head repr is_left assoc))
    (var op (lookup_operator current_mod repr))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_PREFIX) (do
            (add_operator current_mod repr 0 (variant @OP_PREFIX_OR_INFIX 2 op new_op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator current_mod repr 0 (variant @OP_PREFIX_OR_INFIX 2 (field_get op 1) new_op))
            return
            ))
        ))
    (add_operator current_mod repr head new_op)
    ))

(export fun add_constr (head repr) (
    (check_operator_format repr)
    (var op (variant @OP_CONSTR 2 head repr))
    (add_operator current_mod repr head op)
    return
    ))

(export fun add_command (head repr) (
    (check_operator_format repr)
    (var op (variant @OP_COMMAND 2 head repr))
    (add_operator current_mod repr head op)
    return
    ))

    ))
