;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-lex.rlc 2010-12-09 18:45:00 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

; Regular expressions
;
; comment    : #[^\n]*
; spaces     : [\n\r\t ]
; letter     : [A-Za-z_]
; deciaml    : 0|([1-9][0-9]*(e[1-9][0-9]*)?)
; binary     : 0b[01]+
; octal      : 0o[0-7]+
; hex        : 0x[0-9a-fA-F]+
; float      : {decimal}\.[0-9]+(e(+|-)?[0-9]+)?
; escape     : \\['"\\abfnrtv0]
; character  : \'({escape}|[^\\\'\n])\'
; string     : \"({escape}|[^\\\"\n]*\"
; opchar     : [!#$%&=-^|@+*:/?<>.,]
; identifier : {letter}({letter}|[0-9_])*

; character group

(var CH_EOF        0) ; "\0"
(var CH_SPACES     1) ; "\t\r "
(var CH_NL         2) ; "\n"
(var CH_0          3) ; "0"
(var CH_1          4) ; "1"
(var CH_2_7        5) ; "1234567"
(var CH_8_9        6) ; "89"
(var CH_af         7) ; "af"
(var CH_b          8) ; "b"
(var CH_e          9) ; "e"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_HEX       14) ; "ABCDEFabcdef"
(var CH_OTHER     15) ; "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
(var CH_SQUOTE    16) ; "'"
(var CH_DQUOTE    17) ; "\""
(var CH_BQUOTE    18) ; "`"
(var CH_SLASH     19) ; "/"
(var CH_BACKSLASH 20) ; "\\"
(var CH_SHARP     21) ; "#"
(var CH_DOT       22) ; "."
(var CH_PLUSMINUS 23) ; "+-"
(var CH_SPECIAL   24) ; ",()[]{}"
(var CH_OPCHAR    25) ; "!$%&=^|@*:;/\\?<>~"
(var CH_INVALID   26)

; === state transition diagram ===
;
;    spaces
;   +---+--------------------+
;   v   |                    |
; +---+ | EOF   +---+        |
; | 0 +-+------>|@13| (end)  |
; +---+ |       +---+        |
;       | #     +---+        | (comment)
;       +------>| 14+-+------+
;       |       +---+ |
;       |         ^   |[^\n]
;       |         +---+
;       | 0     +---+
;       +------>|@15|              +---+
;       |       +-+-+              v   |01
;       |         | b  +---+01   +---+ |
;       |         +--->| 16+---->|@17+-+   +---+
;       |         |    +---+     +---+     v   |0-7
;       |         | o         +---+0-7   +---+ |
;       |         +---------->| 18+----->|@19+-+    +---+
;       |         |           +---+      +---+      v   |{hex}
;       |         | x                +---+        +---+ |
;       |         +----------------->| 20+------->|@21+-+                 +---+
;       |         +-------+.         +---+ {hex}  +---+                   v   |0-9
;       | 1-9   +---+  .  |   +---+      +---+  e    +---+ 1-9          +---+ |
;       +------>|@22+-+---+-->| 23+----->|@24+-+---->| 25+-----------+->|@27+-+
;       |       +---+ |       +---+ 0-9  +---+ |     +-+-+           |  +---+
;       |         A   |0-9                 A   |0-9    | +-   +---+  |
;       |         +---+                    +---+       +----->| 26+--+
;       | '     +---+ [^\\\n]        +---+ '    +---+         +---+ 1-9
;       +------>| 28+--------------->| 29+----->|@1 |
;       |       +-+-+                +---+      +---+
;       |         |\    +---+ '"\\abfnrtv0   +---+ '  +---+
;       |         +---->| 30+--------------->| 31+--->|@1 |
;       |               +---+                +---+    +---+
;       | "     +---+              "    +---+
;       +------>| 32+-+----------+----->|@34|
;       |       +---+ |          |      +---+
;       |         A   |[^\\\"\n] |\
;       |         +---+          |
;       |         |              v
;       |         |'"\\abfnrtv0+---+
;       |         +------------+ 33|
;       |                      +---+
;       | `     +---+{letter}  +---+                `  +---+
;       +------>| 35+--------->| 36+-+--------------+->|@38|
;       |       +-+-+          +-+-+ |              |  +---+
;       |         |              A   |{letter}|[0-9]|
;       |         |{opchar}      +---+              |
;       |         |    +---+                        |
;       |         +--->| 37+-+----------------------+
;       |              +---+ |
;       |                A   |{opchar}
;       |                +---+
;       |{letter}+---+
;       +------->|@39+-+
;       |        +---+ |{letter}|[0-9]
;       |          A   |
;       |          +---+
;       |{opchar}+---+           +---+
;       +------->| 40+-+-------->|@41|
;       |        +---+ |         +---+
;       |          A   |{opchar}
;       |          +---+
;       |{special} +---+
;       +--------->|@42|
;                  +---+
;
;
;
; 1 : accept token
;
; error state:
;
; 2 : invalid character
; 3 : invalid decimal integer literal
; 4 : invalid binary integer literal
; 5 : invalid octal integer literal
; 6 : invalid hexadecimal integer literal
; 7 : invalid floating point literal
; 8 : invalid escape sequence
; 9 : unterminated character literal
; 10: unterminated string literal
; 11: invalid symbol literal
; 12: undefined operator

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")

(array char chgroup (
     0 26 26 26 26 26 26 26 26  1  2 26 26  1 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
     1 25 17 21 25 25 25 16 24 24 25 23 24 23 22 19
     3  4  5  5  5  5  5  5  6  6 25 25 25 25 25 25
    25 14 14 14 14 14 14 15 15 15 15 15 15 15 15 15
    15 15 15 15 15 15 15 15 15 15 15 24 20 24 25 15
    18  7  8 14 14  9  7 15 15 15 15 15 15 15 13 10
    15 15 11 15 11 15 11 15 12 15 15 24 25 24 25 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
    ))

;                     C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C
;                     H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H
;                     _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
;                     E  S  N  0  1  2  8  a  b  e  o  r  x  n  H  O  S  D  B  S  B  S  D  P  S  O  I
;                     O  P  L  :  :  _  _  f  :  :  :  t  :  :  E  T  Q  Q  Q  L  A  H  O  L  P  P  N
;                     F  A  :  :  :  7  9  :  :  :  :  v  :  :  X  H  U  U  U  A  C  A  T  U  E  C  V
;                     :  C  :  :  :  :  :  :  :  :  :  :  :  :  :  E  O  O  O  S  K  R  :  S  C  H  A
;                     :  E  :  :  :  :  :  :  :  :  :  :  :  :  :  R  T  T  T  H  S  P  :  M  I  A  L
;                     :  S  :  :  :  :  :  :  :  :  :  :  :  :  :  :  E  E  E  :  L  :  :  I  A  R  I
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  A  :  :  N  L  :  D
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  S  :  :  U  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  H  :  :  S  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :
(array char s0next  (13  2  2 15 22 22 22 39 39 39 39 39 39 39 39 39 28 32 35 40 40  2 40 40 42 40 2))
(array char s15next ( 1  1  1  3  3  3  3  3 16  3 18  3 20  3  3  3  1  1  1  1  1  1 23  1  1  1 2))
(array char s17next ( 1  1  1 17 17  4  4  4  4  4  4  4  4  4  4  4  1  1  1  1  1  1  4  1  1  1 2))
(array char s19next ( 1  1  1 19 19 19  5  5  5  5  5  5  5  5  5  5  1  1  1  1  1  1  5  1  1  1 2))
(array char s21next ( 1  1  1 21 21 21 21 21 21 21  6  6  6  6 21  6  1  1  1  1  1  1  6  1  1  1 2))
(array char s22next ( 1  1  1 22 22 22 22  3  3 23  3  3  3  3  3  3  1  1  1  1  1  1 23  1  1  1 2))
(array char s24next ( 1  1  1 24 24 24 24  7  7 25  7  7  7  7  7  7  1  1  1  1  1  1  7  1  1  1 2))
(array char s27next ( 1  1  1 27 27 27 27  7  7  7  7  7  7  7  7  7  1  1  1  1  1  1  7  1  1  1 2))
(array char s28next ( 9 29  9 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 30 29 29 29 29 29 2))
(array char s30next ( 8  8  8 31  8  8  8 31 31  8  8 31  8 31  8  8 31 31  8  8 31  8  8  8  8  8 2))
(array char s32next (10 32 10 32 32 32 32 32 32 32 32 32 32 32 32 32 32 34 32 32 33 32 32 32 32 32 2))
(array char s33next ( 8  8  8 32  8  8  8 32 32  8  8 32  8 32  8  8 32 32  8  8 32  8  8  8  8  8 2))
(array char s35next (11 11 11 11 11 11 11 36 36 36 36 36 36 36 36 36 11 11 11 37 37 11 37 37 11 37 2))
(array char s36next (11 11 11 36 36 36 36 36 36 36 36 36 36 36 36 36 11 11 38 11 11 11 11 11 11 11 2))
(array char s37next (11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 38 37 37 11 37 37 11 37 2))
(array char s39next ( 1  1  1 39 39 39 39 39 39 39 39 39 39 39 39 39  1  1  1  1  1  1  1  1  1  1 2))
(array char s40next (41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 40 40 41 40 40 41 40 2))

(array char grp_0_9 ( 0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_1_9 ( 0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_oct ( 0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_hex ( 0  0  0  1  1  1  1  1  1  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0))

(var lexichan null)
(var lexbuf null)
(var lexbuf_end 0)
(var token_tag @TOK_NONE)
(var token_value 0) ; for integer and character
(var token_buf null)
(var srcfile null)
(var srcline 1)
(var srcclmn 1)
(var next_srcfile null)
(var next_srcline 1)
(var next_srcclmn 1)
(var prev_srcfile null)
(var prev_srcline 1)
(var prev_srcclmn 1)
(var newline 1)
(var unputted 0)
(var operator_table null)

(fun is_member_of (c group) ((return (array_get char group c))))

(export fun get_token_text () ((return (cvector_raw token_buf))))
(export fun get_token_len  () ((return (- (cvector_size token_buf) 1))))
(export fun get_token_value () ((return token_value)))
(export fun get_clmn () ((return srcclmn)))
(export fun get_loc () (
    (if unputted
	(return (make_loc prev_srcfile prev_srcline prev_srcline))
	(return (make_loc srcfile srcline srcline))
	)
    ))

(array char esc2val_table (
    34 0 0 0 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 0 0 0 0 0 92 0 0 0 0 7 8 0 0 0 12 0
     0 0 0 0 0 0 10 0 0 0 13 0 9 0 11
    ))
(fun esc2val (c) (
    (return (- (array_get char esc2val_table c) '"'))
    ))

(fun init_token_buf () (
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (cvector_resize token_buf 0)
    (cvector_pushback token_buf '\0')
    return
    ))

(fun lookahead () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (return @CH_EOF))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (if (== c -1) (return @CH_EOF))
    (return (array_get char chgroup c))
    ))

(fun read_char () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (error "unexpected EOF"))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (incr lexbuf_end)
    (if (== c '\n')
	(do
	    (incr next_srcline)
	    (= next_srcclmn 1)
	    (= newline @TRUE)
        )
	(do
	    (incr next_srcclmn)
	    (if (!= c ' ') (= newline @FALSE))
	)
        )
    (return c)
    ))

(fun consume () (
    (var c (read_char))
    (cvector_put token_buf (- (cvector_size token_buf) 1) c)
    (cvector_pushback token_buf '\0')
    (return c)
    ))

(fun ignore () (
    (read_char)
    ))

(export fun unput () (
    (if unputted (error "try to unput two or more tokens\n"))
    (= unputted 1)
    return
    ))

(fun next_state (table) (
    (return (array_get char table (lookahead)))
    ))

(fun accept (tag) (
    (= token_tag tag)
    return
    ))

(export fun output_token (ochan t) (
    (if (== t @TOK_CHAR) (output_string ochan "character")
    (if (== t @TOK_INT) (output_string ochan "integer")
    (if (== t @TOK_FLOAT) (output_string ochan "floating point")
    (if (== t @TOK_STRING) (output_string ochan "string")
    (if (== t @TOK_SYMBOL) (output_string ochan "symbol")
    (if (== t @TOK_PREFIX) (output_string ochan "prefix operator")
    (if (== t @TOK_POSTFIX) (output_string ochan "postfix operator")
    (if (== t @TOK_INFIX) (output_string ochan "infix operator")
        (do
            (if (>= t 256) (error "BUG: output_token : not reachable"))
            (output_char ochan ''')
            (output_char_escape ochan t)
            (output_char ochan ''')
        )))))))))
    ))

(fun output_loc (ochan) (
    (if srcfile (do
        (output_string ochan srcfile)
        (output_char   ochan ':')
        (output_int    ochan srcline)
        (output_char   ochan ':')
        (output_int    ochan srcclmn)
        (output_string ochan ": ")
        ))
    ))

(fun lex_error (msg) (
    (flush stdout)
    (output_loc stderr)
    (output_string stderr msg)
    (output_string stderr ": ")
    (output_string stderr (get_token_text))
    (output_char   stderr '\n')
    (exit 1)
    ))

(export fun init_lexer (fname ichan) (
    (= next_srcfile (strdup fname))
    (= next_srcline 1)
    (= next_srcclmn 1)
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (= unputted 0)
    (= lexichan ichan)
    (= token_buf (make_cvector 0))
    (cvector_pushback token_buf '\0')
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)
    (= operator_table (make_idtable))

    (skip_spaces)

    return
    ))

(export fun lex () ((return (lex_main 0 0))))
(export fun lex_sub (offs)   ((return (lex_main 0 offs))))
(export fun lex_infix (offs) ((return (lex_main 1 offs))))

(fun lex_main (infix_p offs) (
    (if unputted (do
        (= unputted 0)
        (var op (find_operator (get_token_text)))
        (if op (accept_operator op infix_p))
        (return token_tag)
        ))

    (if (&& newline (<= next_srcclmn offs)) (do
	(accept @TOK_END)
	(return @TOK_END)
	))

    (= prev_srcfile srcfile)
    (= prev_srcline srcline)
    (= prev_srcclmn srcclmn)
    (= srcfile next_srcfile)
    (= srcline next_srcline)
    (= srcclmn next_srcclmn)

    (var state 0)
    (label lexloop)
    (tswitch state (
        (0 . (do
            (init_token_buf)
            (= state (next_state s0next))
            (goto lexloop)
            ))
        (1  . (do
	    (skip_spaces)
	    (return token_tag)
	    ))
        (2  . (lex_error "invalid character"))
        (3  . (lex_error "invalid decimal integer literal"))
        (4  . (lex_error "invalid binary integer literal"))
        (5  . (lex_error "invalid octal integer literal"))
        (6  . (lex_error "invalid hexadecimal integer literal"))
        (7  . (lex_error "invalid floating point literal"))
        (8  . (lex_error "invalid escape sequenc"))
        (9  . (lex_error "unterminated character literal"))
        (10 . (lex_error "unterminated string literal"))
        (11 . (lex_error "invalid symbol literal"))
        (12 . (lex_error "undefined operator"))
        (13 . (do
            (= token_tag @TOK_EOF)
            (return @TOK_EOF)
            ))
        (14 . (do
	    (not_reachable "lex_main")
            ))
        (15 . (do
            (consume)
            (accept @TOK_INT)
            (= state (next_state s15next))
            (goto lexloop)
            ))
        (16 . (do
            (consume)
            (var c (lookahead))
            (if (&& (!= c @CH_0) (!= c @CH_1)) (do
                (= state 4)
                (goto lexloop)
                ))
            ; fall through
            ))
        (17 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_value 1)
            (|= token_value (- c '0'))
            (= state (next_state s17next))
            (goto lexloop)
            ))
        (18 . (do
            (consume)
            (if (! (is_member_of grp_oct (lookahead))) (do
                (= state 5)
                (goto lexloop)
                ))
            ; fall through
            ))
        (19 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_value 3)
            (|= token_value (- c '0'))
            (= state (next_state s19next))
            (goto lexloop)
            ))
        (20 . (do
            (consume)
            (if (! (is_member_of grp_hex (lookahead))) (do
                (= state 6)
                (goto lexloop)
                ))
            ; fall through
            ))
        (21 . (do
            (accept @TOK_INT)
            (<<= token_value 4)
            (var c (consume))
            (if (<= 'a' c)
                (|= token_value (+ (- c 'a') 10))
            (if (<= 'A' c)
                (|= token_value (+ (- c 'A') 10))
                (|= token_value (- c '0'))
                ))
            (= state (next_state s21next))
            (goto lexloop)
            ))
        (22 . (do
            (accept @TOK_INT)
            (= token_value (+ (* 10 token_value) (- (consume) '0')))
            (= state (next_state s22next))
            (goto lexloop)
            ))
        (23 . (do
            (consume)
            (if (! (is_member_of grp_0_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            ; fall through
            ))
        (24 . (do
            (consume)
            (accept @TOK_FLOAT)
            (= state (next_state s24next))
            (goto lexloop)
            ))
        (25 . (do
            (consume)
            (var c (lookahead))
            (if (is_member_of grp_1_9 c) (do
                (= state 27)
                (goto lexloop)
                ))
            (if (== c @CH_PLUSMINUS) (do
                (= state 26)
                (goto lexloop)
                ))
            (= state 7)
            (goto lexloop)
            ))
        (26 . (do
            (consume)
            (if (! (is_member_of grp_1_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            (= state 27)
            (goto lexloop)
            ))
        (27 . (do
            (consume)
            (= state (next_state s27next))
            (goto lexloop)
            ))
        (28 . (do
            (consume)
            (= state (next_state s28next))
            (goto lexloop)
            ))
        (29 . (do
            (consume)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (accept @TOK_CHAR)
                (var str (get_unquoted_token_text))
                (unescape_string str)
                (= token_value (string str))
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (30 . (do
            (consume)
            (= state (next_state s30next))
            (goto lexloop)
            ))
        (31 . (do
            (consume)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (accept @TOK_CHAR)
                (var str (get_unquoted_token_text))
                (unescape_string str)
                (= token_value (string str))
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (32 . (do
            (consume)
            (= state (next_state s32next))
            (goto lexloop)
            ))
        (33 . (do
            (consume)
            (= state (next_state s33next))
            (goto lexloop)
            ))
        (34 . (do
            (consume)
            (accept @TOK_STRING)
            (var str (get_unquoted_token_text))
            (unescape_string str)
            (= token_value (string str))
            (= state 1)
            (goto lexloop)
            ))
        (35 . (do
            (consume)
            (= state (next_state s35next))
            (goto lexloop)
            ))
        (36 . (do
            (consume)
            (= state (next_state s36next))
            (goto lexloop)
            ))
        (37 . (do
            (consume)
            (= state (next_state s37next))
            (goto lexloop)
            ))
        (38 . (do
            (consume)
            (var str (get_unquoted_token_text))
            (= token_value (to_sym str))
            (accept @TOK_SYMBOL)
            (= state 1)
            (goto lexloop)
            ))
        (39 . (do
            (consume)
            (var op (find_operator (get_token_text)))
            (if op (accept_operator op infix_p))
            (= state (next_state s39next))
	    (if (== state 1) (do
		(accept @TOK_SYMBOL)
		(= token_value (to_sym (get_token_text)))
		))
            (goto lexloop)
            ))
        (40 . (do
            (consume)
            (var op (find_operator (get_token_text)))
            (if op
                (do (accept_operator op infix_p) (store_lexer_state))
                )
            (= state (next_state s40next))
            (goto lexloop)
            ))
        (41 . (do
            (if (== token_tag @TOK_NONE) (do
                (= state 12)
                (goto lexloop)
                ))
            (restore_lexer_state)
            (= state 1)
            (goto lexloop)
            ))
        (42 . (do
            (accept (consume))
            (= state 1)
            (goto lexloop)
            ))
        (default . (error "BUG: invalid state"))
        ))
    (error "BUG: not reachable")
    ))

(fun skip_spaces () (
    (var c (lookahead))
    (while 1 (do
	(if (== c @CH_SHARP) (do
	    (ignore)
	    (while (!= (lookahead) @CH_NL) (ignore))
	    (ignore)
	    )
	(if (|| (== c @CH_SPACES) (== c @CH_NL)) (do
	    (while (|| (== c @CH_SPACES) (== c @CH_NL)) (do
		(ignore)
		(= c (lookahead))
		))
	    )
	    break
	    ))
	(= c (lookahead))
	))
    ))

(var save_lexbuf_end 0)
(var save_srcline 0)
(var save_srcclmn 0)
(var save_token_len 0)
(var save_token_value 0)
(fun store_lexer_state () (
    (= save_lexbuf_end lexbuf_end)
    (= save_srcline next_srcline)
    (= save_srcclmn next_srcclmn)
    (= save_token_len (get_token_len))
    (= save_token_value (get_token_value))
    ))

(fun restore_lexer_state () (
    (= lexbuf_end save_lexbuf_end)
    (= next_srcline save_srcline)
    (= next_srcclmn save_srcclmn)
    (cvector_resize token_buf save_token_len)
    (cvector_pushback token_buf '\0')
    (= token_value save_token_value)
    ))

(fun get_unquoted_token_text () (
    (var str (get_token_text))
    (var len (- (get_token_len) 2))
    (var new (array char (+ len 1)))
    (strncpy new (+ str 1) len)
    (return new)
    ))

(fun accept_operator (op infix_p) (
    (var optype (field_get op 0))
    (if (== optype @OP_PREFIX) (accept @TOK_PREFIX)
    (if (== optype @OP_POSTFIX) (accept @TOK_POSTFIX)
    (if (== optype @OP_INFIX) (accept @TOK_INFIX)
    (if (== optype @OP_CONSTR) (accept @TOK_CONSTR)
    (if (== optype @OP_PREFIX_OR_INFIX) (do
        (if infix_p
            (do (accept @TOK_INFIX) (= op (field_get op 2)))
            (do (accept @TOK_PREFIX) (= op (field_get op 1)))
            )
        )
        )))))
    (= token_value op)
    ))

(fun push_operator_table () (
    (idtable_push operator_table)
    ))

(fun pop_operator_table () (
    (idtable_pop operator_table)
    ))

(fun add_operator (name sym) (
    (idtable_add operator_table name sym)
    ))

(fun find_operator (name) (
    (return (idtable_find operator_table name))
    ))

(fun check_assoc (name assoc) (
    (if (> assoc 0) return)
    (output_string stderr "ERROR: associativity of operator '")
    (output_string stderr name)
    (output_string stderr "' must be positive\n")
    (exit 1)
    ))

(export fun add_prefix (name assoc) (
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (to_sym name))
    (var prefix_op (variant @OP_PREFIX 1 sym assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op (field_get op 2)))
            return
            ))
        ))
    (add_operator name prefix_op)
    ))

(export fun add_postfix (name assoc) (
    (check_assoc name assoc)
    (var sym (to_sym name))
    (add_operator name (variant @OP_POSTFIX 1 sym assoc))
    ))

(export fun add_infixl (name assoc) ((add_infix name 1 assoc)))
(export fun add_infixr (name assoc) ((add_infix name 0 assoc)))

(fun add_infix (name is_left assoc) (
    ; XXX: check validity of the format of the name
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (to_sym name))
    (var infix_op (variant @OP_INFIX 1 sym is_left assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_PREFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 op infix_op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 (field_get op 1) infix_op))
            return
            ))
        ))
    (add_operator name infix_op)
    ))

(export fun add_constr (name maxlen assoc) (
    (check_assoc name assoc)
    (var sym (to_sym name))
    (field_set sym @SymbolOp (make_expr Constr (list2 (box maxlen) (box assoc))))
    (add_operator name (variant @OP_CONSTR 1 sym maxlen assoc))
    ))

    ))
