;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-string.rlc 2014-02-12 17:23:26 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-error")

(extern object current_loc)
(extern fun ary_new)
(extern fun ary_push)

(fun s_size (s) (
    (return (box (strlen s)))
    ))

(fun s_equal (a b) (
    (if (streq a b)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))

(fun s_hash (s) (
    (var len (strlen s))
    (var h 0)
    (for i 0 len (do
        (+= h (array_get char s i))
        ))
    (return (box h))
    ))

(fun s_add (a b) (
    (return (strcat a b))
    ))

(fun s_join (list d) (
    (if (! list) (return (string "")))
    (var len 0)
    (var dlen (strlen d))
    (var n 0)
    (var list_ list)
    (while list_ (do
        (var s (car list_))
        (if (!= (node_type s) @StringE)
            (throw (invalid_argument current_loc
                (string "join requires list of strings")
                list))
            )
        (+= len (strlen s))
        (+= n 1)
        (= list_ (cdr list_))
        ))
    (+= len (* (- n 1) dlen))
    (var str (allocate_string len))
    (var p 0)
    (while list (do
        (+= p (strcpy (+ str p) (car list)))
        (if (cdr list)
            (+= p (strcpy (+ str p) d))
            )
        (= list (cdr list))
        ))
    (return str)
    ))

(fun s_unescape (s) (
    (= s (strdup s))
    (unescape_string_d s)
    (return s)
    ))

; returns true if s1 contains s2 as a sub-string.
(fun s_contain (s1 s2) (
    ; simple method
    (var l1 (strlen s1))
    (var l2 (strlen s2))
    (if (< l1 l2) (return @C_FALSE))
    (for i 0 (- l1 l2) (do
        (if (strneq (+ s1 i) s2 l2) (return @C_TRUE))
        ))
    (return @C_FALSE)
    ))

; Split `str` by delimiter string `d`
; split d d = []
; split (d ++ s) d = cons "" (split s d)
; split (s1 ++ d ++ s2) d = cons s1 (split s2 d)
(fun s_split_ (str d i slen dlen) (
    (if (< slen dlen)
        (return (list1 (strldup (+ str i) (+ slen 1))))
        )
    (if (strneq (+ str i) d dlen)
        (return (cons (string "") (s_split_ str d (+ i dlen) (- slen dlen) dlen)))
        )
    (for k i (+ (- (+ i slen) dlen) 1) (do
        (if (strneq (+ str k) d dlen)
            (return (cons (substr str i (- k 1))
                (s_split_ str d (+ k dlen) (- slen (+ k dlen)) dlen)
                )))
        ))
    (return (list1 (strldup (+ str i) (+ slen 1))))
    ))

(fun s_split (str d) (
    (var slen (strlen str))
    (var dlen (strlen d))
    (if (== dlen 0) (do
        (var ls 0)
        (rfor i 0 slen (do
            (= ls (cons (ctos (array_get char str i)) ls))
            ))
        (return ls)
        ))
    (return (s_split_ str d 0 slen dlen))
    ))

(fun s_code (s) (
    (var len (strlen s))
    (if (!= len 1) (throw (invalid_argument current_loc
        (string "`code' requires a string of length 1")
        s)))
    (return (box (array_get char s 0)))
    ))

(fun s_char (i) (
    (= i (unbox i))
    (if (& i 0xffffff00) (throw (invalid_argument current_loc
        (string "`char' requires number between 0 and 255")
        (box i))))
    (return (ctos i))
    ))

(fun s_at (s i) (
    (= i (unbox i))
    (var len (strlen s))
    (if (< i 0) (+= i len))
    (if (|| (>= i len) (< i 0))
        (throw (out_of_range current_loc s (box i))))
    (return (ctos (array_get char s i)))
    ))

(fun s_store (s i c) (
    (if (!= (strlen c) 1)
        (throw (invalid_argument current_loc (string "2nd argument of store for String must be one character") c))
        )
    (= i (unbox i))
    (var len (strlen s))
    (if (< i 0) (+= i len))
    (if (|| (>= i len) (< i 0))
        (throw (out_of_range current_loc s (box i))))
    (array_set char s i (array_get char c 0))
    (return c)
    ))

(fun substr (s i j) (
    (var str (allocate_string (+ (- j i) 1)))
    (memcpy str (+ s i) (+ (- j i) 1))
    (return str)
    ))

(fun s_at_range (s r) (
    (var b (node_arg_int r 0))
    (var e (node_arg_int r 1))
    (var len (strlen s))
    (if (< b 0) (+= b len))
    (if (< e 0) (+= e len))
    (if (> b e)
        (throw (invalid_argument current_loc (string "Not valid range") r))
        )
    (if (|| (>= e len) (< b 0))
        (throw (out_of_range current_loc s r))
        )
    (return (substr s b e))
    ))

;; StringStream
(export fun new_iss (str) (
    (return (variant @InputStringStreamE 1 (make_iss str)))
    ))

(export fun new_oss () (
    (return (variant @OutputStringStreamE 1 (make_oss)))
    ))

(export fun oss_raw (oss) (
    (return (field_get oss 1))
    ))

(export fun oss_to_s (io) (
    (return (string (oss_get (field_get io 1))))
    ))

(fun oss_print_str (io str) (
    (output_string (field_get io 1) str)
    (return @C_NIL)
    ))

; single character is represented as a string of one character
(fun iss_lookahead (io) (
    (var c)
    (if (< (lookahead (address c) (field_get io 1)) 0)
        (return @C_NIL)
        )
    (var s (allocate_string 1))
    (strlcpy s (address c) 2)
    (return s)
    ))

; single character is represented as a string of one character
(fun iss_read_char (io) (
    (var c)
    (if (< (input_char (address c) (field_get io 1)) 0)
        (return @C_NIL)
        )
    (var s (allocate_string 1))
    (strlcpy s (address c) 2)
    (return s)
    ))

(fun iss_read_string (io) (
    (var s)
    (if (< (input_string (address s) (field_get io 1)) 0)
        (return @C_NIL)
        )
    (return s)
    ))

(fun iss_read_line (io) (
    (var s)
    (if (< (input_line (address s) (field_get io 1)) 0)
        (return @C_NIL)
        )
    (return s)
    ))

(export fun setup_string (mod) (
    (var trait (make_object1 (to_sym "Trait") (to_sym "String")))
    (set_slot mod (to_sym "StringTrait") trait)
    (set_special_parent @StringE trait)

    (add_function1 mod (to_sym "string_length") stringT s_size 0)
    (add_function2 mod (to_sym "string_equal?") stringT stringT s_equal 0)
    (add_function1 mod (to_sym "string_hash") stringT s_hash 0)
    (add_function2 mod (to_sym "string_add") stringT stringT s_add 0)
    (add_function2 mod (to_sym "string_join") listT stringT s_join 0)

    (add_function1 mod (to_sym "code_to_char") intT s_char 0)
    (add_function1 mod (to_sym "char_to_code") stringT s_code 0) 

    (add_function2 mod (to_sym "string_at") stringT intT s_at 0)
    (add_function2 mod (to_sym "string_at") stringT irangeT s_at_range 0)
    (add_function1 mod (to_sym "string_unescape") stringT s_unescape 0)
    (add_function2 mod (to_sym "string_contain?") stringT stringT s_contain 0)
    (add_function2 mod (to_sym "string_split") stringT stringT s_split 0)

    ; StringStream module
    (var trait (make_object1 (to_sym "Trait") (to_sym "InputStringStream")))
    (set_slot mod (to_sym "InputStringStreamTrait") trait)
    (set_special_parent @InputStringStreamE trait)

    (var trait (make_object1 (to_sym "Trait") (to_sym "OutputStringStream")))
    (set_slot mod (to_sym "OutputStringStreamTrait") trait)
    (set_special_parent @OutputStringStreamE trait)

    (var issT (domainP InputStringStream))
    (add_function1 mod (to_sym "iss_new") stringT new_iss 0)

    (add_function1 mod (to_sym "iss_lookahead") issT iss_lookahead 0)
    (add_function1 mod (to_sym "iss_read_char") issT iss_read_char 0)
    (add_function1 mod (to_sym "iss_read_string") issT iss_read_string 0)
    (add_function1 mod (to_sym "iss_read_line") issT iss_read_line 0)

    (var ossT (domainP OutputStringStream))

    (add_function0 mod (to_sym "oss_new") new_oss 0)
    (add_function1 mod (to_sym "oss_to_string") ossT oss_to_s 0)
    (add_function2 mod (to_sym "oss_print_string") ossT stringT oss_print_str 0)
    ))

    ))
