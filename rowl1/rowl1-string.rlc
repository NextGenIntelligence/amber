;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-string.rlc 2014-01-24 20:38:37 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-error")

(extern object current_loc)
(extern fun ary_new)
(extern fun ary_push)

(fun s_size (s) (
    (return (box (strlen s)))
    ))

(fun s_equal (a b) (
    (if (streq a b)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))

(fun s_hash (s) (
    (var len (strlen s))
    (var h 0)
    (for i 0 len (do
        (+= h (array_get char s i))
        ))
    (return (box h))
    ))

(fun s_to_s (s) (
    (return s)
    ))

(fun s_add (a b) (
    (return (strcat a b))
    ))

(fun to_s_check (obj) (
    (var s (call1 (to_sym "to_s") obj))
    (if (== s @C_UNDEF)
        (throw (make_object3 Exception current_loc (string "Can not convert to string") obj)) 
        )
    (return s)
    ))

(fun s_add2 (a b) (
    (= a (to_s_check a))
    (= b (to_s_check b))
    (var s (strcat a b))
    (return s)
    ))

(fun s_mul (a n) (
    (= n (unbox n))
    (var m (strlen a))
    (var s (allocate_string (* m n)))
    (for i 0 n (do
        (strcpy (+ s (* m i)) a)
        ))
    (return s)
    ))

(fun s_unescape (s) (
    (= s (strdup s))
    (unescape_string_d s)
    (return s)
    ))

; returns true if s1 contains s2 as a sub-string.
(fun s_contain (s1 s2) (
    ; simple method
    (var l1 (strlen s1))
    (var l2 (strlen s2))
    (if (< l1 l2) (return @C_FALSE))
    (for i 0 (- l1 l2) (do
        (if (strneq (+ s1 i) s2 l2) (return @C_TRUE))
        ))
    (return @C_FALSE)
    ))

; Split `str` by delimiter string `d`
; split d d = []
; split (d ++ s) d = cons "" (split s d)
; split (s1 ++ d ++ s2) d = cons s1 (split s2 d)
(fun s_split_ (str d i slen dlen) (
    (if (< slen dlen)
        (return (list1 (strndup (+ str i) slen)))
        )
    (if (strneq (+ str i) d dlen)
        (return (cons (string "") (s_split_ str d (+ i dlen) (- slen dlen) dlen)))
        )
    (for k i (+ (- (+ i slen) dlen) 1) (do
        (if (strneq (+ str k) d dlen)
            (return (cons (substr str i (- k 1))
                (s_split_ str d (+ k dlen) (- slen (+ k dlen)) dlen)
                )))
        ))
    (return (list1 (strndup (+ str i) slen)))
    ))

(fun s_split (str d) (
    (var slen (strlen str))
    (var dlen (strlen d))
    (if (== dlen 0) (do
        (var ls 0)
        (rfor i 0 slen (do
            (= ls (cons (ctos (array_get char str i)) ls))
            ))
        (return ls)
        ))
    (return (s_split_ str d 0 slen dlen))
    ))

(fun s_code (s) (
    (var len (strlen s))
    (if (!= len 1) (throw (invalid_argument current_loc
        (string "`code' requires a string of length 1")
        s)))
    (return (box (array_get char s 0)))
    ))

(fun s_char (i) (
    (= i (unbox i))
    (if (& i 0xffffff00) (throw (invalid_argument current_loc
        (string "`char' requires number between 0 and 255")
        (box i))))
    (return (ctos i))
    ))

(fun s_at (s i) (
    (= i (unbox i))
    (var len (strlen s))
    (if (< i 0) (+= i len))
    (if (|| (>= i len) (< i 0))
        (throw (out_of_range current_loc s (box i))))
    (return (ctos (array_get char s i)))
    ))

(fun s_store (s i c) (
    (if (!= (strlen c) 1)
        (throw (invalid_argument current_loc (string "2nd argument of store for String must be one character") c))
        )
    (= i (unbox i))
    (var len (strlen s))
    (if (< i 0) (+= i len))
    (if (|| (>= i len) (< i 0))
        (throw (out_of_range current_loc s (box i))))
    (array_set char s i (array_get char c 0))
    (return c)
    ))

(fun substr (s i j) (
    (var str (allocate_string (+ (- j i) 1)))
    (memcpy str (+ s i) (+ (- j i) 1))
    (return str)
    ))

(fun s_at_range (s r) (
    (var b (node_arg_int r 0))
    (var e (node_arg_int r 1))
    (var len (strlen s))
    (if (< b 0) (+= b len))
    (if (< e 0) (+= e len))
    (if (> b e)
        (throw (invalid_argument current_loc (string "Not valid range") r))
        )
    (if (|| (>= e len) (< b 0))
        (throw (out_of_range current_loc s r))
        )
    (return (substr s b e))
    ))

;; StringIO
(export fun new_sio () (
    (return (variant @StringIOE 1 (make_sio)))
    ))

(export fun sio_raw (sio) (
    (return (field_get sio 1))
    ))

(export fun sio_to_s (io) (
    (return (string (sio_get (field_get io 1))))
    ))

(fun sio_print_symbol (io sym) (
    (output_string (field_get io 1) (symbol_name sym))
    (return @C_NIL)
    ))

(fun sio_print_str (io str) (
    (output_string (field_get io 1) str)
    (return @C_NIL)
    ))

(fun sio_print_int (io n) (
    (output_int (field_get io 1) (unbox n))
    (return @C_NIL)
    ))

(export fun setup_string (global) (
    (add_function1 global (to_sym "size") stringT s_size 0)
    (add_function1 global (to_sym "length") stringT s_size 0)
    (add_function2 global (to_sym "equal") stringT stringT s_equal 0)
    (add_function1 global (to_sym "hash") stringT s_hash 0)
    (add_function1 global (to_sym "to_s") stringT s_to_s 0)
    (add_function2 global (to_sym "add") stringT stringT s_add 0)
    (add_function2 global (to_sym "add") stringT DontCare s_add2 0)
    (add_function2 global (to_sym "add") DontCare stringT s_add2 0)
    (add_function2 global (to_sym "mul") stringT intT s_mul 0)

    (add_function1 global (to_sym "char") intT s_char 0)
    (add_function1 global (to_sym "code") stringT s_code 0) 

    (add_function2 global (to_sym "at") stringT intT s_at 0)
    (add_function2 global (to_sym "at") stringT irangeT s_at_range 0)
    (add_function3 global (to_sym "store") stringT intT stringT s_store 0)
    (add_function1 global (to_sym "unescape") stringT s_unescape 0)
    (add_function2 global (to_sym "contain") stringT stringT s_contain 0)
    (add_function2 global (to_sym "split") stringT stringT s_split 0)

    ; StringIO module
    (var sioT (domainP StringIO))
    (var SIO (set_undef_slot global (to_sym "StringIO") (create_module (to_sym "StringIO"))))

    (add_function0 SIO (to_sym "new") new_sio 0)
    (add_function1 global (to_sym "to_s") sioT sio_to_s 0)

    (var IO (set_undef_slot global (to_sym "IO") (create_module (to_sym "IO"))))
    (add_function2 IO (to_sym "print") sioT symT sio_print_symbol 0)
    (add_function2 IO (to_sym "print") sioT stringT sio_print_str 0)
    (add_function2 IO (to_sym "print") sioT intT sio_print_int 0)
    ))

    ))
