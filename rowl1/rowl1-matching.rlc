;1
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2010-12-11 19:42:27 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")

; pattern matrix (((p11 p12 .. ) . e1) ((p21 p22 ..) . e2) ..)

(var headpat (to_sym "%head-pattern"))

(fun compile_matching (bytecode head pats) (
    ; we need to clone 'pats' here because compile_matching_main() will rearrange it.
    (= pats (list_clone pats))

    (var asm (make_assembler 10))
    (compile_matching_main asm 0 pats)
    (compile_matching_error asm head (list_length (caar pats)))

    (set_code bytecode asm)
    (return bytecode)
    ))

(fun compile_matching_main (asm idx pats) (
    (if (== (caar pats) 0) (do
        (put_code asm (cdar pats))
        return
        ))
    (var x (split_matrix pats)) ; (single . remain)
    (compile_matching_single asm idx (car x))
    (if (cdr x)
        (compile_matching_main asm idx (cdr x))
        )
    ))

(fun compile_matching_single (asm idx pats) (
    (var p (caaar pats))
    (if (== p DontCare) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (+ idx 1) pats)
        return
        ))
    (var pty (node_type p))
    (if (== pty @Int) (do
        (var not_int (fresh_label asm))
        (put_arg asm idx)
        (put_check_int asm not_int)
        (compile_matching_intlit asm idx pats)
        (set_label asm not_int)
        return
        ))
    (if (== pty @Expr) (do
        (= pty (field_get p @ExprHead))
        (if (== pty headpat) (do
            (var ty (expr_arg p 0))
            (var check_failed (fresh_label asm))
            (put_arg asm idx)
            (compile_check_head asm ty check_failed)
            (= pats (shift_pat pats))
            (compile_matching_main asm (+ idx 1) pats)
            (set_label asm check_failed)
            return
            ))
        ))
    (not_implemented "compile_matching_single")
    ))

(fun compile_check_head (asm ty exit_lbl) (
    (if (== ty Int) (do
        (put_check_int asm exit_lbl)
        return
        ))
    (if (== ty String) (do
        (put_check_string asm exit_lbl)
        return
        ))

    (if (!= (node_type ty) @SymbolE) (not_reachable "compile_check_head"))

    (put_imm_int32 asm expr_head)
    (put_dcall asm 4)
    (put_push asm ty)
    (put_if_ne asm exit_lbl)
    ))

(fun compile_matching_intlit (asm idx pats) (
    (= pats (sort_int_pat pats))
    (var r (scan_int_cases pats))
    (var continues (unbox (car r)))
    (var cases (cdr r))

    (if continues
        (compile_matching_intlit_tswitch asm idx pats cases)
        (compile_matching_intlit_lswitch asm idx pats cases)
        )
    ))

(fun compile_matching_intlit_tswitch (asm idx pats cases) (
    (var ncases (list_length cases))
    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (put_arg asm idx)

    ; unbox
    (put_imm_i1 asm)
    (put_sar asm)

    (put_tswitch asm ncases)
    (for i 0 ncases
        (emit_tswitch_label asm (array_get int case_lbls i))
        )
    (emit_tswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (+ idx 1) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun compile_matching_intlit_lswitch (asm idx pats cases) (
    (var ncases 0)
    (var max (caar cases))
    (var cases_copy cases)
    (while cases_copy (do
        (incr ncases)
        (if (< max (caar cases_copy))
            (= max (caar cases_copy))
            )
        (= cases_copy (cdr cases_copy))
        ))
    (= max (+ (unbox max) 1))

    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (put_arg asm idx)

    ; unbox
    (put_imm_i1 asm)
    (put_sar asm)

    (put_lswitch asm max)
    (= cases_copy cases)
    (for i 0 ncases (do
        (emit_int asm (unbox (caar cases_copy)))
        (emit_lswitch_label asm (array_get int case_lbls i))
        (= cases_copy (cdr cases_copy))
        ))
    (emit_int asm max)
    (emit_lswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (+ idx 1) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun sort_int_pat (pats) (
    (var ret 0)
    (while pats (do
        (var p (car pats))
        (= pats (cdr pats))

        (var v (caar p))
        (= ret (insert_int_pat p ret))
        ))
    (return ret)
    ))

(fun insert_int_pat (p ls) (
    (if (! ls) (return (cons p 0)))
    (var a (caar p))
    (var b (caaar ls))
    (if (<= a b)
        (return (cons p ls))
        (return (cons (car ls) (insert_int_pat p (cdr ls))))
        )
    ))

(fun scan_int_cases (pats) (
    (var p (caaar pats))
    (var ret 0)
    (var num 0)
    (var continues @FALSE)
    (if (== (unbox p) 0) (do
        (= continues @TRUE)
        ))
    (while pats (do
        (if (== p (caaar pats))
            (do
                (incr num)
                (= pats (cdr pats))
            )
            (do
                (if (!= (+ p 2) (caaar pats))
                    (= continues @FALSE)
                    )
                (= ret (cons (cons p (box num)) ret))
                (= p (caaar pats))
                (= num 1)
                (= pats (cdr pats))
            ))
        ))
    (= ret (cons (cons p (box num)) ret))
    (return (cons (box continues) (list_reverse ret)))
    ))

(fun collect_same_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (var val (caaar pats))
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) val)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_matrix (pats) (
    (var p (caaar pats))
    (if (== p DontCare) (return (split_any pats)))
    (var pty (node_type p))
    (if (== pty @Int) (return (split_int (unbox p) pats)))
    (if (== pty @Expr) (do
        (= pty (field_get p @ExprHead))
        (if (== pty headpat) (return (split_type_pat pty pats)))
        ))
    (not_implemented "split_matrix")
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) DontCare)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int (v pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (node_type (caaar pats)) @Int)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun is_type_pat (ty node) (
    (if (!= (node_type node) @Expr) (return @FALSE))
    (var constr (field_get node @ExprHead))
    (if (!= constr headpat) (return @FALSE))
    (if (== (expr_arg node 0) ty)
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun split_type_pat (ty pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (is_type_pat ty (caaar pats))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (cdaar pats) (cdar pats)) (shift_pat (cdr pats))))
    ))

(export fun compile_matching_hook (ent arity) (
    (var asm (make_assembler 10))

    (put_push asm (field_get ent 2))
    (put_push asm (field_get ent 1))
    (put_push asm (field_get ent 0))
    (put_imm_int32 asm compile_matching)
    (put_dcall asm 8)
    (put_dup asm)
    (put_push asm ent)
    (put_swap asm)
    (put_field_set0 asm)
    (put_jjump asm)

    (set_code (car ent) asm)
    ))

(fun matching_error (head args) (
    (output_error stderr)
    (output_string stderr "no declaration matchines to ")
    (pretty_print stderr (make_expr head args))
    (output_string stderr "\n")
    (exit 1)
    ))

(fun compile_matching_error (asm head arity) (
    (put_imm_int32 asm 0) ; nil
    (while (> arity 0) (do
        (decr arity)
        (put_arg asm arity)
        (put_cons asm)
        ))
    (put_push asm head)
    (compile_simple_call asm 2 matching_error @FALSE)
    ))

    ))
