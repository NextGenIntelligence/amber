;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2010-11-03 22:03:40 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-jitasm")

(fun printstr (str) (
    (print_string str)
    ))

(fun printint (n) (
    (print_int (get n))
    ))

(export fun matching_test () (
    (var asm (make_jitassembler 20))

    (put_push asm printstr)
    (put_dgoto asm)
    (var print_str_code (get_code asm))

    (= asm (make_jitassembler 20))
    (put_push asm printint)
    (put_dgoto asm)
    (var print_int_code (get_code asm))

    (= asm (make_jitassembler 20))
    (compile_matching asm 0 (cons (cons (int 0) 0) (cons (cons AnySym 0) 0)) (cons print_int_code (cons print_str_code 0)))

    ;(exit (jitcall (get_code_ptr asm) "Hello World\n"))
    (exit (jitcall (get_code_ptr asm) (int 0)))
    ))

; pats: pattern matrix ((p11 p12 .. ) (p21 p22 ..) ..)
; exps: list of expressions
(export fun compile_matching (asm idx pats exps) (
    (if (== (car pats) 0) (do
        (put_code asm (car exps))
        return
        ))
    (var x (split_matrix pats)) ; (single . remain)
    (var n (list_length (car x)))
    (var y (list_split exps n))
    (compile_matching_single asm idx (car x) (car y))
    (if (cdr x)
        (compile_matching asm idx (cdr x) (cdr y))
        )
    ))

(fun compile_matching_single (asm idx pats exps) (
    (var p (caar pats))
    (if (== p AnySym) (do
        (= pats (shift_pat pats))
        (compile_matching asm (+ idx 1) pats exps)
        return
        ))
    (var pty (node_type p))
    (if (== pty @Int) (do
        (var value (get p))
        (var endif (fresh_label asm))
        (put_arg asm idx)
        (put_field_get0 asm)
        (put_imm_int asm value)
        (put_if_ne asm endif)
        (= pats (shift_pat pats))
        (compile_matching asm (+ idx 1) pats exps)
        (set_label asm endif)
        return
        ))
    (not_implemented "compile_matching_single")
    ))

(fun split_matrix (pats) (
    (var p (caar pats))
    (if (== p AnySym) (return (split_any pats)))
    (var pty (node_type p))
    (if (== pty @Int) (return (split_int (get p) pats)))
    (not_implemented "split_matrix")
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (caar pats) AnySym)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int (v pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (&& (== (node_type (caar pats)) @Int) (== v (get (caar pats))))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cdar pats) (shift_pat (cdr pats))))
    ))

    ))
