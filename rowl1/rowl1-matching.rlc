;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2010-11-11 20:52:27 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")

; pattern matrix (((p11 p12 .. ) . e1) ((p21 p22 ..) . e2) ..)

(export fun compile_matching (bytecode pats) (
    ; we need to clone 'pats' here because compile_matching_main() will rearrange it.
    (= pats (list_clone pats))

    (var asm (make_assembler 10))
    (compile_matching_main asm 0 pats)
    (if bytecode
        (do
            (set_code bytecode asm)
            (return bytecode)
        )
        (return (get_code asm))
        )
    ))

(fun compile_matching_main (asm idx pats) (
    (if (== (caar pats) 0) (do
        (put_code asm (cdar pats))
        return
        ))
    (var x (split_matrix pats)) ; (single . remain)
    (var n (list_length (car x)))
    (compile_matching_single asm idx (car x))
    (if (cdr x)
        (compile_matching_main asm idx (cdr x))
        )
    ))

(fun compile_matching_single (asm idx pats) (
    (var p (caaar pats))
    (if (== p AnySym) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (+ idx 1) pats)
        return
        ))
    (var pty (node_type p))
    (if (== pty @Int) (do
        (var endif (fresh_label asm))

        (put_arg asm idx)
        (put_check_int asm endif)
        (put_arg asm idx)
        (put_imm_int asm p)
        (put_if_ne asm endif)

        (= pats (shift_pat pats))
        (compile_matching_main asm (+ idx 1) pats)

        (set_label asm endif)
        return
        ))
    (not_implemented "compile_matching_single")
    ))

(fun split_matrix (pats) (
    (var p (caaar pats))
    (if (== p AnySym) (return (split_any pats)))
    (var pty (node_type p))
    (if (== pty @Int) (return (split_int (unbox p) pats)))
    (not_implemented "split_matrix")
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) AnySym)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int (v pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (&& (== (node_type (caaar pats)) @Int) (== v (unbox (caaar pats))))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (cdaar pats) (cdar pats)) (shift_pat (cdr pats))))
    ))

    ))
