;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2010-11-12 00:11:25 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")

; pattern matrix (((p11 p12 .. ) . e1) ((p21 p22 ..) . e2) ..)

(export fun compile_matching (bytecode pats) (
    ; we need to clone 'pats' here because compile_matching_main() will rearrange it.
    (= pats (list_clone pats))

    (var asm (make_assembler 10))
    (compile_matching_main asm 0 pats)

    ; XXX: put error handler here

    (if bytecode
        (do
            (set_code bytecode asm)
            (return bytecode)
        )
        (return (get_code asm))
        )
    ))

(fun compile_matching_main (asm idx pats) (
    (if (== (caar pats) 0) (do
        (put_code asm (cdar pats))
        return
        ))
    (var x (split_matrix pats)) ; (single . remain)
    (compile_matching_single asm idx (car x))
    (if (cdr x)
        (compile_matching_main asm idx (cdr x))
        )
    ))

(fun compile_matching_single (asm idx pats) (
    (var p (caaar pats))
    (if (== p AnySym) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (+ idx 1) pats)
        return
        ))
    (var pty (node_type p))
    (if (== pty @Int) (do
        (= pats (sort_int_pat pats))

        (var not_int (fresh_label asm))
        (put_arg asm idx)
        (put_check_int asm not_int)

        (while pats (do
            (var next (fresh_label asm))
            (var ret (collect_same_int_pat pats))
            (var pat (car ret))

            (put_arg asm idx)
            (put_imm_int asm (caaar pat))
            (put_if_ne asm next)

            (= pat (shift_pat pat))
            (compile_matching_main asm (+ idx 1) pat)
            (set_label asm next)

            (= pats (cdr ret))
            ))

        (set_label asm not_int)
        return
        ))
    (not_implemented "compile_matching_single")
    ))

; XXX: temporal implementation by bubble sort
(fun sort_int_pat (pats) (
    (if (! pats) (return 0))
    (if (! (cdr pats)) (return pats))
    (var a (caaar pats))
    (var b (caaadr pats))
    (if (<= a b)
        (do
            (setcdr pats (sort_int_pat (cdr pats)))
            (return pats)
        )
        (do
            (var t (car pats))
            (setcar pats (cadr pats))
            (setcar (cdr pats) t)
            (setcdr pats (sort_int_pat (cdr pats)))
            (return pats)
        ))
    ))

(fun collect_same_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (var val (caaar pats))
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) val)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_matrix (pats) (
    (var p (caaar pats))
    (if (== p AnySym) (return (split_any pats)))
    (var pty (node_type p))
    (if (== pty @Int) (return (split_int (unbox p) pats)))
    (not_implemented "split_matrix")
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) AnySym)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int (v pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (node_type (caaar pats)) @Int)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (cdaar pats) (cdar pats)) (shift_pat (cdr pats))))
    ))

    ))
