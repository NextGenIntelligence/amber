;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2011-10-04 19:54:43 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")

; pattern matrix (((p11 p12 .. ) . e1) ((p21 p22 ..) . e2) ..)

(fun compile_matching (sym funobj) (
    (var bytecode (expr_arg funobj 0))
    (var pats (expr_arg funobj 1))
    (var asm (make_assembler))

    (= pats (prepare_pats pats))

    (var args 0)
    (var idx (list_length (caar pats)))
    (while (> idx 0) (do
        (decr idx)
        (= args (cons (make_arg idx) args))
        ))

    (compile_matching_main asm args pats)
    (compile_matching_error asm sym (list_length (caar pats)))

    (set_code bytecode asm)
    (return bytecode)
    ))

(fun prepare_pats (pats) (
    (if (== pats 0) (return 0))
    (return (cons
        (cons
            (unquote_pat_list (caar pats))
            (cdar pats)
            )
        (prepare_pats (cdr pats))
        ))
    ))

(fun unquote_pat (pat) (
    (var hd (expr_head pat))
    (if (|| (== hd Symbol) (|| (== hd Int) (== hd String)))
        (return pat)
        )
    (if (== hd List)
        (return (unquote_pat_list pat))
        )
    (if (== hd Quote)
        (return (unquote_pat_sub (expr_arg pat 0)))
        )
    (var args (expr_args pat))
    (return (make_expr hd (unquote_pat_list args)))
    ))

(fun unquote_pat_list (pat) (
    (var ret 0)
    (while pat (do
        (= ret (cons (unquote_pat (car pat)) ret))
        (= pat (cdr pat))
        ))
    (return (list_reverse ret))
    ))

(fun unquote_pat_sub (pat) (
    (var hd (expr_head pat))
    (if (== hd Symbol)
        (return (make_expr SymbolP (list1 pat)))
        )
    (if (|| (== hd Int) (== hd String))
        (return pat)
        )
    (if (== hd Unquote)
        (return (unquote_pat (expr_arg pat 0)))
        )
    (if (== hd List)
        (return (unquote_pat_sub_list pat))
        )
    (var args (expr_args pat))
    (return (make_expr hd (unquote_pat_sub_list args)))
    ))

(fun unquote_pat_sub_list (pat) (
    (var ret 0)
    (while pat (do
        (= ret (cons (unquote_pat_sub (car pat)) ret))
        (= pat (cdr pat))
        ))
    (return (list_reverse ret))
    ))

(fun compile_matching_main (asm args pats) (
    (if (== (caar pats) 0) (do
        (put_code asm (list_at (car pats) 1))
        return
        ))
    (var x (split_pattern_matrix pats)) ; (single . remain)
    (compile_matching_single asm args (car x))
    (if (cdr x)
        (compile_matching_main asm args (cdr x))
        )
    ))

(fun compile_matching_single (asm args pats) (
    (var p (caaar pats))
    (var hd (expr_head p))
    (if (== hd Symbol) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args)  pats)
        return
        ))
    (if (== hd Int) (do
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_int asm check_failed)
        (compile_matching_intlit asm args pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd String) (do
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_string asm check_failed)
        (compile_operand asm (car args))
        (compile_matching_string_lit asm p check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd HeadP) (do
        (var pat (expr_arg_symbol p 1))
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (compile_same_head_pat asm pat check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd SymbolP) (do
        (var sym (expr_arg_symbol p 0))
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_push asm sym)
        (put_if_ne asm check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd List) (do
        (var len (list_length p))
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_list asm check_failed len)

        ; flatten list pattern
        (= pats (expand_list_pat pats))

        ; add list elements to args
        (var ls (car args))
        (= args (cdr args))
        (while (> len 0) (do
            (decr len)
            (= args (cons (make_list_at ls len) args))
            ))

        (compile_matching_main asm args pats)
        (set_label asm check_failed)
        return
        ))

    (var check_failed (fresh_label asm))
    (var size (expr_size p))
    (compile_operand asm (car args))

    (compile_same_head_pat asm hd check_failed)
    (compile_operand asm (car args))
    (put_field_get2 asm)
    (put_check_list asm check_failed size)

    ; flattern expression pattern
    (= pats (expand_composite_pat pats))

    ; add list elements to args
    (var expr (car args))
    (= args (cdr args))
    (while (> size 0) (do
        (decr size)
        (= args (cons (make_expr_at expr size) args))
        ))

    (compile_matching_main asm args pats)
    (set_label asm check_failed)
    ))

(fun compile_same_head_pat (asm ty exit_lbl) (
    (if (== ty Int) (do
        (put_check_int asm exit_lbl)
        return
        ))
    (if (== ty String) (do
        (put_check_string asm exit_lbl)
        return
        ))

    (put_imm_int32 asm expr_head)
    (put_dcall asm 4)
    (put_push asm ty)
    (put_if_ne asm exit_lbl)
    ))

(fun compile_matching_intlit (asm args pats) (
    (= pats (sort_int_pat pats))
    (var r (scan_int_cases pats))
    (var continues (unbox (car r)))
    (var cases (cdr r))

    (if continues
        (compile_matching_intlit_tswitch asm args pats cases)
        (compile_matching_intlit_lswitch asm args pats cases)
        )
    ))

(fun compile_matching_intlit_tswitch (asm args pats cases) (
    (var ncases (list_length cases))
    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (compile_operand asm (car args))

    ; unbox
    (put_imm_i1 asm)
    (put_sar asm)

    (put_tswitch asm ncases)
    (for i 0 ncases
        (emit_tswitch_label asm (array_get int case_lbls i))
        )
    (emit_tswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (cdr args) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun compile_matching_intlit_lswitch (asm args pats cases) (
    (var ncases 0)
    (var max (caar cases))
    (var cases_copy cases)
    (while cases_copy (do
        (incr ncases)
        (if (< max (caar cases_copy))
            (= max (caar cases_copy))
            )
        (= cases_copy (cdr cases_copy))
        ))
    (= max (+ (unbox max) 1))

    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (compile_operand asm (car args))

    ; unbox arg
    (put_imm_i1 asm)
    (put_sar asm)

    (put_lswitch asm max)
    (= cases_copy cases)
    (for i 0 ncases (do
        (emit_int asm (unbox (caar cases_copy)))
        (emit_lswitch_label asm (array_get int case_lbls i))
        (= cases_copy (cdr cases_copy))
        ))
    (emit_int asm max)
    (emit_lswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (cdr args) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun sort_int_pat (pats) (
    (var ret 0)
    (while pats (do
        (var p (car pats))
        (= pats (cdr pats))
        (= ret (insert_int_pat p ret))
        ))
    (return ret)
    ))

(fun insert_int_pat (p ls) (
    (if (! ls) (return (cons p 0)))
    (var a (caar p))
    (var b (caaar ls))
    (if (<= a b)
        (return (cons p ls))
        (return (cons (car ls) (insert_int_pat p (cdr ls))))
        )
    ))

(fun scan_int_cases (pats) (
    (var p (caaar pats))
    (var ret 0)
    (var num 0)
    (var continues @FALSE)
    (if (== (unbox p) 0) (do
        (= continues @TRUE)
        ))
    (while pats (do
        (if (== p (caaar pats))
            (do
                (incr num)
                (= pats (cdr pats))
            )
            (do
                (if (!= (+ p 2) (caaar pats))
                    (= continues @FALSE)
                    )
                (= ret (cons (cons p (box num)) ret))
                (= p (caaar pats))
                (= num 1)
                (= pats (cdr pats))
            ))
        ))
    (= ret (cons (cons p (box num)) ret))
    (return (cons (box continues) (list_reverse ret)))
    ))

(fun collect_same_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (var val (caaar pats))
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) val)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun compile_matching_string_lit (asm str exit_lbl) (
    (put_push asm str)
    (compile_simple_call asm 2 streq)
    (put_if_zero asm exit_lbl)
    ))

(fun split_pattern_matrix (pats) (
    (var p (caaar pats))
    (var hd (expr_head p))
    (if (== hd Symbol) (return (split_any pats)))
    (if (== hd Int) (return (split_int_pat pats)))
    (if (== hd String) (return (split_string_pat pats)))
    (if (== hd HeadP) (return (split_head_pat (expr_arg_symbol p 1) pats)))
    (if (== hd SymbolP) (return (split_symbol_pat (expr_arg_symbol p 0) pats)))
    (if (== hd List) (return (split_list_pat pats)))
    (return (split_composite_pat pats))
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) DontCare)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (node_type (caaar pats)) @Int)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_string_pat (pats) (
    (var n 1)
    (var orig pats)
    (var str (caaar pats))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (node_type nd) @StringE) (! (streq str nd))) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun same_head_pat (hd node) (
    (if (&& (== (expr_head node) HeadP) (== (expr_arg_symbol node 1) hd))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun split_head_pat (hd pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (same_head_pat hd (caaar pats))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun same_symbol_pat (sym node) (
    (var hd (expr_head node))
    (if (&& (== hd SymbolP) (== (expr_arg_symbol node 0) sym))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun split_symbol_pat (sym pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (same_symbol_pat sym (caaar pats))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_list_pat (pats) (
    (= pats (sort_list_pat pats))
    (var n 1)
    (var orig pats)
    (var len (list_length (caaar pats)))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (expr_head nd) List) (!= (list_length nd) len)) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun sort_list_pat (pats) (
    (var ret 0)
    (while pats (do
        (var p (car pats))
        (= pats (cdr pats))
        (= ret (insert_list_pat p ret))
        ))
    (return ret)
    ))

(fun insert_list_pat (p pats) (
    (if (! pats) (return (cons p 0)))
    (var a (caar p))
    (var b (caaar pats))
    (if (!= (expr_head a) List) (return (cons (car pats) (insert_list_pat p (cdr pats)))))
    (if (!= (expr_head b) List) (return (cons p pats)))
    (var alen (list_length a))
    (var blen (list_length b))
    (if (<= alen blen)
        (return (cons p pats))
        (return (cons (car pats) (insert_list_pat p (cdr pats))))
        )
    ))

(fun split_composite_pat (pats) (
    (var n 1)
    (var orig pats)
    (var p (caaar pats))
    (var hd (expr_head p))
    (var size (expr_size p))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (expr_head nd) hd) (!= (expr_size nd) size)) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (cdaar pats) (cdar pats)) (shift_pat (cdr pats))))
    ))

(fun expand_list_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (list_append (caaar pats) (cdaar pats)) (cdar pats))
        (expand_list_pat (cdr pats))))
    ))

(fun expand_composite_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (list_append (expr_args (caaar pats)) (cdaar pats)) (cdar pats))
        (expand_composite_pat (cdr pats))))
    ))

(export fun compile_matching_hook (ent sym arity) (
    (var asm (make_assembler))

    (put_push asm ent)
    (put_push asm sym)
    (put_imm_int32 asm compile_matching)
    (put_dcall asm 8)
    (put_dup asm)
    (put_push asm ent)
    (put_expr_args asm)
    (put_setcar asm)
    (put_jjump asm)

    (set_code (expr_arg ent 0) asm)
    ))

(fun matching_error (head args) (
    (output_error stderr)
    (output_string stderr "no definition matches to ")
    (pretty_print stderr (make_expr head args))
    (output_string stderr "\n")
    (exit 1)
    ))

(fun compile_matching_error (asm head arity) (
    (put_imm_int32 asm 0) ; nil
    (while (> arity 0) (do
        (decr arity)
        (put_arg asm arity)
        (put_cons asm)
        ))
    (put_push asm head)
    (compile_simple_call asm 2 matching_error)
    ))

    ))
