;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-matching.rlc 2012-05-22 16:51:27 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-assemble")
(import "rowl1-compile")

; pattern matrix (((p11 p12 .. ) e1 g1) ((p21 p22 ..) e2 g2) ..)

(var dontcareP (to_sym "%DontCare"))
(var varP      (to_sym "%Var"))
(var headP     (to_sym "%HeadPattern"))

(export fun compile_matching (loc obj def) (
    (var ty (node_type def))
    (if (&& (!= ty @BoundFunctionE) (!= ty @FunctionE)) (do
        (output_error stderr loc)
        (pretty_print stderr obj)
        (output_string stderr " is not a function\n")
        (exit 1)
        ))

    (var cache (field_get def 1))
    (if cache (return cache))

    ; here, `def' has form of Function{ ... }

    ; construct pattern matrix 
    (var mat (construct_pattern_matrix def))

    (var args 0)
    (var idx (- (list_len (caar mat)) 1))
    (while (> idx 0) (do
        (decr idx)
        (= args (cons (make_arg idx) args))
        ))
    (= args (cons (get_arity) args))

    (var asm (make_assembler))
    (compile_matching_main asm args mat)
    (compile_matching_error asm loc)

    (var code (get_code asm))
    (field_set def 1 code) ; caching
    (return code)
    ))

(fun construct_pattern_matrix (def) (
    ; compute maximum arity
    (var len (max_arity def))
    (return (construct_pattern_matrix_sub len def 0))
    ))

(fun construct_pattern_matrix_sub (len def tl) (
    (if (== (node_type def) @FunctionE)
        (return (cons (construct_row len def) tl))
        )
    ; here `def' is a BoundFunction
    (var fun1 (field_get def 2))
    (var fun2 (field_get def 3))
    (= tl (construct_pattern_matrix_sub len fun2 tl))
    (return (construct_pattern_matrix_sub len fun1 tl))
    ))

(fun max_arity (def) (
    (if (== (node_type def) @FunctionE)
        (return (list_len (field_get def 2)))
        )
    ; here `def' is a BoundFunction 
    (var len1 (max_arity (field_get def 2)))
    (var len2 (max_arity (field_get def 3)))
    (if (< len1 len2)
        (return len2)
        (return len1)
        )
    ))

(fun construct_row (len def) (
    (var args (field_get def 2))
    (var code (field_get def 3))
    (var guard (field_get def 4))
    (= args (setup_args len args))
    (return (list3 args code guard))
    ))

(fun setup_args (len args) (
    (if (== len 0) (return 0))
    (if (! args) (return (diag_list len dontcareP)))
    (return (cons (setup_pat (car args)) (setup_args (- len 1) (cdr args))))
    ))

(fun setup_pat (pat) (
    (var hd (expr_head pat))
    (if (== pat DontCare)
        (return dontcareP)
        )
    (if (== hd Symbol) (do
        (return (make_expr varP (list1 pat)))
        ))
    (if (|| (== hd Int) (== hd String))
        (return pat)
        )
    (if (== hd Domain) (do
        (var lhs (setup_pat (expr_arg pat 0)))
        (var dom (expr_arg pat 1))
        (return (make_expr headP (list2 lhs dom)))
        ))
    (if (== hd List)
        (return (setup_pat_list pat))
        )
    (if (== hd Quote)
        (return (expr_arg pat 0))
        )
    (if (== hd QuasiQuote)
        (return (qquote_pat (expr_arg pat 0) 0))
        )
    (var args (expr_args pat))
    (return (make_expr_user hd (setup_pat_list args)))
    ))

(fun setup_pat_list (list) (
    (if (! list) (return 0))
    (return (cons (setup_pat (car list)) (setup_pat_list (cdr list))))
    ))

(fun qquote_pat_list (pat level) (
    (var ret 0)
    (while pat (do
        (= ret (cons (qquote_pat (car pat) level) ret))
        (= pat (cdr pat))
        ))
    (return (list_reverse ret))
    ))

(fun qquote_pat (pat level) (
    (var hd (expr_head pat))
    (if (|| (== hd Symbol) (|| (== hd Int) (== hd String)))
        (return pat)
        )
    (if (== hd List)
        (return (qquote_pat_list pat level))
        )
    (if (== hd Unquote) (do
        (if (== level 0)
            (return (setup_pat (expr_arg pat 0)))
            (return (qquote_pat (expr_arg pat 0) (- level 1)))
            )
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))
    (var args (expr_args pat))
    (return (make_expr_user hd (qquote_pat_list args level)))
    ))

(fun compile_matching_main (asm args pats) (
    (if (== (caar pats) 0) (do
        (var func (car pats))
        (var code (list_at func 1))
        (var guard (list_at func 2))
        (if guard
            (do
                (var guard_failed (fresh_label asm))
                (put_code asm guard)
                (put_push asm true)
                (put_if_ne asm guard_failed)
                (put_push asm code)
                (put_jjump asm)
                (set_label asm guard_failed)
            )
            (do
                (put_push asm code)
                (put_jjump asm)
            ))
        return
        ))
    (var x (split_pattern_matrix pats)) ; (single . remain)
    (compile_matching_single asm args (car x))
    (if (cdr x)
        (compile_matching_main asm args (cdr x))
        )
    ))

(fun compile_matching_single (asm args pats) (
    (var p (caaar pats))
    (var hd (expr_head p))
    (if (== p dontcareP) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args)  pats)
        return
        ))
    (if (== hd Symbol) (do
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_push asm p)
        (put_if_ne asm check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd Int) (do
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_int asm check_failed)
        (compile_matching_intlit asm args pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd String) (do
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_string asm check_failed)
        (compile_operand asm (car args))
        (compile_matching_string_lit asm p check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd headP) (do
        (var pat (expr_arg_symbol p 1))
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (compile_same_head_pat asm pat check_failed)
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args) pats)
        (set_label asm check_failed)
        return
        ))
    (if (== hd varP) (do
        (= pats (shift_pat pats))
        (compile_matching_main asm (cdr args)  pats)
        return
        ))
    (if (== hd List) (do
        (var len (list_len p))
        (var check_failed (fresh_label asm))
        (compile_operand asm (car args))
        (put_check_list asm check_failed len)

        ; flatten list pattern
        (= pats (expand_list_pat pats))

        ; add list elements to args
        (var ls (car args))
        (= args (cdr args))
        (while (> len 0) (do
            (decr len)
            (= args (cons (make_list_at ls len) args))
            ))

        (compile_matching_main asm args pats)
        (set_label asm check_failed)
        return
        ))

    (var check_failed (fresh_label asm))
    (var size (expr_size p))
    (compile_operand asm (car args))

    (compile_same_head_pat asm hd check_failed)
    (compile_operand asm (car args))
    (put_field_get2 asm)
    (put_check_list asm check_failed size)

    ; flattern expression pattern
    (= pats (expand_composite_pat pats))

    ; add list elements to args
    (var expr (car args))
    (= args (cdr args))
    (while (> size 0) (do
        (decr size)
        (= args (cons (make_expr_at expr size) args))
        ))

    (compile_matching_main asm args pats)
    (set_label asm check_failed)
    ))

(fun compile_same_head_pat (asm ty exit_lbl) (
    (if (== ty Int) (do
        (put_check_int asm exit_lbl)
        return
        ))
    (if (== ty String) (do
        (put_check_string asm exit_lbl)
        return
        ))

    (put_imm_int32 asm expr_head)
    (put_dcall asm 4)
    (put_push asm ty)
    (put_if_ne asm exit_lbl)
    ))

(fun compile_matching_intlit (asm args pats) (
    (= pats (sort_int_pat pats))
    (var r (scan_int_cases pats))
    (var continues (unbox (car r)))
    (var cases (cdr r))

    (if continues
        (compile_matching_intlit_tswitch asm args pats cases)
        (compile_matching_intlit_lswitch asm args pats cases)
        )
    ))

(fun compile_matching_intlit_tswitch (asm args pats cases) (
    (var ncases (list_len cases))
    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (compile_operand asm (car args))

    ; unbox
    (put_imm_i1 asm)
    (put_sar asm)

    (put_tswitch asm ncases)
    (for i 0 ncases
        (emit_tswitch_label asm (array_get int case_lbls i))
        )
    (emit_tswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (cdr args) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun compile_matching_intlit_lswitch (asm args pats cases) (
    (var ncases 0)
    (var max (caar cases))
    (var cases_copy cases)
    (while cases_copy (do
        (incr ncases)
        (if (< max (caar cases_copy))
            (= max (caar cases_copy))
            )
        (= cases_copy (cdr cases_copy))
        ))
    (= max (+ (unbox max) 1))

    (var end_lbl (fresh_label asm))
    (var case_lbls (array int ncases))
    (for i 0 ncases
        (array_set int case_lbls i (fresh_label asm))
        )

    (compile_operand asm (car args))

    ; unbox arg
    (put_imm_i1 asm)
    (put_sar asm)

    (put_lswitch asm max)
    (= cases_copy cases)
    (for i 0 ncases (do
        (emit_int asm (unbox (caar cases_copy)))
        (emit_lswitch_label asm (array_get int case_lbls i))
        (= cases_copy (cdr cases_copy))
        ))
    (emit_int asm max)
    (emit_lswitch_label asm end_lbl)
    (for i 0 ncases (do
        (var n (unbox (cdar cases)))
        (var r (list_split pats n))
        (= pats (cdr r))
        (set_label asm (array_get int case_lbls i))
        (compile_matching_main asm (cdr args) (shift_pat (car r)))
        (= cases (cdr cases))
        ))
    (set_label asm end_lbl)
    ))

(fun sort_int_pat (pats) (
    (var ret 0)
    (while pats (do
        (var p (car pats))
        (= pats (cdr pats))
        (= ret (insert_int_pat p ret))
        ))
    (return ret)
    ))

(fun insert_int_pat (p ls) (
    (if (! ls) (return (cons p 0)))
    (var a (caar p))
    (var b (caaar ls))
    (if (<= a b)
        (return (cons p ls))
        (return (cons (car ls) (insert_int_pat p (cdr ls))))
        )
    ))

(fun scan_int_cases (pats) (
    (var p (caaar pats))
    (var ret 0)
    (var num 0)
    (var continues @FALSE)
    (if (== (unbox p) 0) (do
        (= continues @TRUE)
        ))
    (while pats (do
        (if (== p (caaar pats))
            (do
                (incr num)
                (= pats (cdr pats))
            )
            (do
                (if (!= (+ p 2) (caaar pats))
                    (= continues @FALSE)
                    )
                (= ret (cons (cons p (box num)) ret))
                (= p (caaar pats))
                (= num 1)
                (= pats (cdr pats))
            ))
        ))
    (= ret (cons (cons p (box num)) ret))
    (return (cons (box continues) (list_reverse ret)))
    ))

(fun collect_same_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (var val (caaar pats))
    (= pats (cdr pats))
    (while (&& pats (== (caaar pats) val)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun compile_matching_string_lit (asm str exit_lbl) (
    (put_push asm str)
    (compile_simple_call asm 2 streq)
    (put_if_zero asm exit_lbl)
    ))

(fun split_pattern_matrix (pats) (
    (var p (caaar pats))
    (var hd (expr_head p))
    (if (== hd varP) (return (split_any pats)))
    (if (== hd Int) (return (split_int_pat pats)))
    (if (== hd String) (return (split_string_pat pats)))
    (if (== hd headP) (return (split_head_pat (expr_arg_symbol p 1) pats)))
    (if (== hd Symbol) (return (split_symbol_pat 0 pats)))
    (if (== hd List) (return (split_list_pat pats)))
    (return (split_composite_pat pats))
    ))

(fun split_any (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (|| (== (caaar pats) dontcareP) (== (expr_head (caaar pats)) varP))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_int_pat (pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (== (node_type (caaar pats)) @Int)) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_string_pat (pats) (
    (var n 1)
    (var orig pats)
    (var str (caaar pats))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (node_type nd) @StringE) (! (streq str nd))) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun same_head_pat (hd node) (
    (if (&& (== (expr_head node) headP) (== (expr_arg_symbol node 1) hd))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun split_head_pat (hd pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (same_head_pat hd (caaar pats))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun same_symbol_pat (sym node) (
    (var hd (expr_head node))
    (if (&& (== hd Symbol) (== node sym))
        (return @TRUE)
        (return @FALSE)
        )
    ))

(fun split_symbol_pat (sym pats) (
    (var n 1)
    (var orig pats)
    (= pats (cdr pats))
    (while (&& pats (same_symbol_pat sym (caaar pats))) (do
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun split_list_pat (pats) (
    (= pats (sort_list_pat pats))
    (var n 1)
    (var orig pats)
    (var len (list_len (caaar pats)))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (expr_head nd) List) (!= (list_len nd) len)) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun sort_list_pat (pats) (
    (var ret 0)
    (while pats (do
        (var p (car pats))
        (= pats (cdr pats))
        (= ret (insert_list_pat p ret))
        ))
    (return ret)
    ))

(fun insert_list_pat (p pats) (
    (if (! pats) (return (cons p 0)))
    (var a (caar p))
    (var b (caaar pats))
    (if (!= (expr_head a) List) (return (cons (car pats) (insert_list_pat p (cdr pats)))))
    (if (!= (expr_head b) List) (return (cons p pats)))
    (var alen (list_len a))
    (var blen (list_len b))
    (if (<= alen blen)
        (return (cons p pats))
        (return (cons (car pats) (insert_list_pat p (cdr pats))))
        )
    ))

(fun split_composite_pat (pats) (
    (var n 1)
    (var orig pats)
    (var p (caaar pats))
    (var hd (expr_head p))
    (var size (expr_size p))
    (= pats (cdr pats))
    (while pats (do
        (var nd (caaar pats))
        (if (|| (!= (expr_head nd) hd) (!= (expr_size nd) size)) break)
        (= pats (cdr pats))
        (incr n)
        ))
    (return (list_split orig n))
    ))

(fun shift_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (cdaar pats) (cdar pats)) (shift_pat (cdr pats))))
    ))

(fun expand_list_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (list_append (caaar pats) (cdaar pats)) (cdar pats))
        (expand_list_pat (cdr pats))))
    ))

(fun expand_composite_pat (pats) (
    (if (== pats 0) (return 0))
    (return (cons (cons (list_append (expr_args (caaar pats)) (cdaar pats)) (cdar pats))
        (expand_composite_pat (cdr pats))))
    ))

(var arity_max 8)
(fun matching_error (loc arity args) (
    (output_error stderr loc)
    (output_string stderr "no definition matches to argument(s): ")
    (output_char stderr '(')
    (while args (do
        (pretty_print_full stderr (car args))
        (= args (cdr args))
        (if args (output_string stderr ", "))
        ))
    (if (<= arity arity_max)
        (output_string stderr ")\n")
        (output_string stderr ", ...)\n")
        )
    (exit 1)
    ))

(fun compile_matching_error (asm loc) (
    ; construct list of arguments
    (var end_lbl (fresh_label asm))
    (var case_lbls (array int arity_max))
    (for i 0 arity_max
        (array_set int case_lbls i (fresh_label asm))
        )

    (put_imm_i0 asm) ; null list
    (put_arity asm)
    (put_tswitch asm arity_max)
    (for i 0 arity_max
        (emit_tswitch_label asm (array_get int case_lbls i))
        )
    (emit_tswitch_label asm end_lbl)
    (set_label asm end_lbl)
    (for i 0 arity_max (do
        (var arg_idx (- (- arity_max i) 1))
        (put_arg asm arg_idx)
        (put_cons asm)
        (set_label asm (array_get int case_lbls arg_idx))
        ))
    (put_arity asm)
    (put_push asm loc)
    (compile_simple_call asm 3 matching_error)
    ))

    ))
