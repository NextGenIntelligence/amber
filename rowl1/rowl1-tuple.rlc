;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-list.rlc 2012-12-15 22:16:26 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")

(extern object current_loc)
(extern object current_mod)

(export fun tuple2 (a b) (
    (var t (allocate_tuple 2))
    (array_set object t 0 a)
    (array_set object t 1 b)
    (return t)
    ))

(export fun tuple3 (a b c) (
    (var t (allocate_tuple 3))
    (array_set object t 0 a)
    (array_set object t 1 b)
    (array_set object t 2 c)
    (return t)
    ))
 
(export fun tuple4 (a b c d) (
    (var t (allocate_tuple 4))
    (array_set object t 0 a)
    (array_set object t 1 b)
    (array_set object t 2 c)
    (array_set object t 3 d)
    (return t)
    ))

(export fun tuple5 (a b c d e) (
    (var t (allocate_tuple 5))
    (array_set object t 0 a)
    (array_set object t 1 b)
    (array_set object t 2 c)
    (array_set object t 3 d)
    (array_set object t 4 e)
    (return t)
    ))

(fun tp_length (t) (
    (return (box (seq_size t)))
    ))

(fun tp_hash (t) (
    (var f (lookup_func current_mod (to_sym "hash")))
    (var n (seq_size t))
    (var h 0)
    (for i 0 n (do
        (= h (+ (* h 13) (unbox (byterun f (array_get object t i)))))
        ))
    (return (box h))
    ))

(fun tp_equal (t1 t2) (
    (var n (seq_size t1))
    (if (!= (seq_size t2) n) (return false))
    (var f (lookup_func current_mod (to_sym "equal")))
    (for i 0 n (do
        (if (== (byterun f
            (array_get object t1 i) (array_get object t2 i)) false)
            (return false))
        ))
    (return true)
    ))

(export fun tuple_at (t i) (
    (var n (seq_size t))
    (if (>= i n) (throw (out_of_range current_loc t (box (+ i 1)))))
    (return (array_get object t i))
    ))

(fun tp_at (t i) (
    (return (tuple_at t (unbox i)))
    ))

(export fun tuple_store (t i v) (
    (var n (seq_size t))
    (if (>= i n) (throw (out_of_range current_loc t (box (+ i 1)))))
    (array_set object t i v)
    (return v)
    ))

(fun tp_store (t i v) (
    (return (tuple_store t (unbox i) v))
    ))

(export fun tuple_restof (tup i) (
    (var ls 0)
    (var size (seq_size tup))
    (rfor j i size (do
        (= ls (cons (array_get object tup j) ls))
        ))
    (return ls)
    ))

(export fun tuple_to_list (tup) (
    (var ls 0)
    (var size (seq_size tup))
    (rfor i 0 size (do
        (= ls (cons (array_get object tup i) ls))
        ))
    (return ls)
    ))

(export fun list_to_tuple (list) (
    (var n (list_len list))
    (var t (allocate_tuple n))
    (for i 0 n (do
        (array_set object t i (car list))
        (= list (cdr list))
        ))
    (return t)
    ))

(export fun setup_tuple (std) (
    (add_function1 std (to_sym "length") tupleT tp_length 0)
    (add_function1 std (to_sym "size") tupleT tp_length 0)
    (add_function1 std (to_sym "hash") tupleT tp_hash 0)
    (add_function2 std (to_sym "equal") tupleT tupleT tp_equal 0)
    (add_function2 std (to_sym "at") tupleT intT tp_at 0)
    (add_function3 std (to_sym "store") tupleT intT DontCare tp_store 0)
    ))

    ))
