;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-object.rlc 2014-02-01 15:45:52 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-compile")
(import "rowl1-error")

(extern object current_loc)

(var slots (make_wrtable))
(var proto (to_sym "proto"))
(var proto_tbl (make_wrtable))
(var dummy (wrtable_add slots proto proto_tbl))
(var initialize (to_sym "initialize"))
(var proto_special null)

(extern fun tuple_at)
(extern fun _copy)

(export fun make_clone (obj) (
    (var clone (_copy obj))
    (set_slot clone proto obj)
    (var init (get_slot_nocheck clone initialize))
    (if (!= init @C_UNDEF)
        (= clone (runcode (get_bytecode init) clone))
        )
    (return clone)
    ))

(fun remove_slot (obj sym) (
    (var tbl (wrtable_find slots sym))
    (if (!= tbl @C_UNDEF) (wrtable_del tbl sym))
    (return @C_UNDEF)
    ))

(export fun set_slot (obj sym val) (
    (if (== val @C_UNDEF) (return (remove_slot obj sym)))
    (var tbl (wrtable_find slots sym))
    (if (== tbl @C_UNDEF) (do
        (= tbl (make_wrtable))
        (wrtable_add slots sym tbl)
        ))
    (wrtable_add tbl obj val)
    (return val)
    ))

(export fun set_slot_incremental (obj sym val) (
    (var f (get_slot_nocheck obj sym))
    (if (== f @C_UNDEF) (return (set_slot obj sym val)))
    (if (&& (is_function f) (is_function val))
        (return (set_slot obj sym (fusion_function val f)))
        )
    (throw (redefined_var current_loc sym))
    ))

(export fun set_undef_slot (obj sym val) (
    (var v (get_slot_nocheck obj sym))
    (if (!= v @C_UNDEF) (return v))
    (return (set_slot obj sym val))
    ))

(export fun overwrite_slot (obj sym val) (
    (var v (get_slot_norec obj sym))
    (while (== v @C_UNDEF) (do
        (= obj (get_proto obj))
        (if (== obj @C_UNDEF) 
            (throw (undefined_var current_loc sym))
            )
        (= v (get_slot_norec obj sym))
        ))
    (return (set_slot obj sym val))
    ))

(fun get_proto (obj) (
    (var p (wrtable_find proto_tbl obj))
    (if (!= p @C_UNDEF) (return p))
    (return (array_get object proto_special (node_type obj)))
    ))

(export fun get_slot_nocheck (obj sym) (
    (if (== sym proto) (return (get_proto obj)))
    (var tbl (wrtable_find slots sym))
    (if (== tbl @C_UNDEF) (return @C_UNDEF))
    (label retry)
    (var v (wrtable_find tbl obj))
    (if (== v @C_UNDEF) (do
        (= obj (get_proto obj))
        (if (== obj @C_UNDEF) (return (wrtable_find tbl @C_UNDEF)))
        (goto retry)
        ))
    (return v)
    ))

(export fun get_slot (obj sym) (
    (var v (get_slot_nocheck obj sym))
    (if (== v @C_UNDEF)
        (throw (undefined_var current_loc sym))
        )
    (return v)
    ))


(export fun get_slot_norec (obj sym _) (
    (if (== sym proto) (return (get_proto obj)))
    (var tbl (wrtable_find slots sym))
    (if (== tbl @C_UNDEF) (return @C_UNDEF))
    (return (wrtable_find tbl obj))
    ))

(export fun set_special_proto (obj) (
    (array_set object proto_special (node_type obj) obj)
    ))

(export fun has_slot_p (obj sym) (
    (if (!= (get_slot_nocheck obj sym) @C_UNDEF)
        (return @C_TRUE)
        (return @C_FALSE)
        )
    ))

(export fun setup_object (mod) (
    (= proto_special (allocate_array @NUM_NODE_TYPE))
    (for i 0 @NUM_NODE_TYPE
        (array_set object proto_special i @C_UNDEF)
        )

    (add_function1 mod (to_sym "clone") DontCare make_clone 0)
    (add_function3 mod (to_sym "set_slot") DontCare symT DontCare set_slot 0)
    (add_function4 mod (to_sym "set_slot") DontCare symT DontCare (quote (to_sym "incremental")) set_slot_incremental 0)
    (add_function2 mod (to_sym "get_slot") DontCare DontCare get_slot 0)
    (add_function3 mod (to_sym "get_slot") DontCare DontCare (quote (to_sym "norec")) get_slot_norec 0)
    (add_function2 mod (to_sym "has_slot?") DontCare symT has_slot_p 0)
    ))

    ))
