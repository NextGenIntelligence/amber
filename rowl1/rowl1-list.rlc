;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-list.rlc 2012-11-21 15:48:28 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")

(extern object current_loc)
(extern object current_mod)

(fun index_out_of_range () (
    (throw (out_of_range current_loc))
    ))

(fun ls_at (ls i) (
    (= i (unbox i))
    (while (&& (> i 0) ls) (do
        (-= i 1)
        (= ls (cdr ls))
        ))
    (if (! ls) (index_out_of_range))
    (return (car ls))
    ))

(fun ls_store (ls i v) (
    (= i (unbox i))
    (while (&& (> i 0) ls) (do
        (-= i 1)
        (= ls (cdr ls))
        ))
    (if (! ls) (index_out_of_range))
    (setcar ls v)
    (return v)
    ))

(fun ls_length (ls) (
    (return (box (list_len ls)))
    ))

(fun ls_cons (a b) (
    (return (cons a b))
    ))

(fun ls_car (a) (
    (if (! a) (index_out_of_range))
    (return (car a))
    ))
(fun ls_cdr (a) (
    (if (! a) (index_out_of_range))
    (return (cdr a))
    ))

(fun ls_reverse (ls) (
    (return (list_reverse ls))
    ))

(fun ls_append (a b) (
    (return (list_append a b))
    ))

(fun ls_map (ls f) (
    (var new_ls 0)
    (var code (get_bytecode (string "argument for map") f))
    (while ls (do
        (= new_ls (cons (byterun code (car ls)) new_ls))
        (= ls (cdr ls))
        ))
    (return (list_reverse new_ls))
    ))

(fun ls_map2 (ls1 ls2 f) (
    (var new_ls 0)
    (var code (get_bytecode (string "argument for map") f))
    (while (&& ls1 ls2) (do
        (= new_ls (cons (byterun code (car ls1) (car ls2)) new_ls))
        (= ls1 (cdr ls1))
        (= ls2 (cdr ls2))
        ))
    (return (list_reverse new_ls))
    ))

(fun ls_foldl (ls v f) (
    (var code (get_bytecode (string "argument for foldl") f))
    (while ls (do
        (= v (byterun code v (car ls)))
        (= ls (cdr ls))
        ))
    (return v)
    ))

(fun ls_contain (ls v) (
    (var f (lookup_func current_mod (to_sym "equal")))
    (while ls (do
        (if (== (byterun f v (car ls)) true) (return true))
        (= ls (cdr ls))
        ))
    (return false)
    ))

(fun ls_create (n f) (
    (var new_ls 0)
    (var code (get_bytecode (string "argument for create") f))
    (for i 0 (unbox n) (do
        (= new_ls (cons (byterun code (box i)) new_ls))
        ))
    (return (list_reverse new_ls))
    ))

(export fun setup_list (std) (
    (var mod (find_module no_loc std (to_sym "List") @TRUE))
    (add_builtin_function1 std (to_sym "length") listT ls_length 0)
    (add_builtin_function1 std (to_sym "size") listT ls_length 0)
    (add_builtin_function2 std (to_sym "cons") DontCare listT ls_cons 0)
    (add_builtin_function1 std (to_sym "car") listT ls_car 0)
    (add_builtin_function1 std (to_sym "cdr") listT ls_cdr 0)
    (add_builtin_function2 std (to_sym "at") listT intT ls_at 0)
    (add_builtin_function3 std (to_sym "store") listT intT DontCare ls_store 0)
    (add_builtin_function1 std (to_sym "reverse") listT ls_reverse 0)
    (add_builtin_function2 std (to_sym "append") listT listT ls_append 0)
    (add_builtin_function2 std (to_sym "map") listT funT ls_map 0)
    (add_builtin_function3 std (to_sym "map2") listT listT funT ls_map2 0)
    (add_builtin_function3 std (to_sym "foldl") listT DontCare funT ls_foldl 0)
    (add_builtin_function2 std (to_sym "contain") listT DontCare ls_contain 0)
    (add_builtin_function2 mod (to_sym "create") intT funT ls_create 0)
    ))

    ))
