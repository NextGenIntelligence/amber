;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-list.rlc 2014-01-23 03:02:27 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")

(extern object current_loc)

(fun index_out_of_range (list idx) (
    (throw (out_of_range current_loc list (box idx)))
    ))

(fun ls_new (n f) (
    (var new_ls 0)
    (var code (get_bytecode f))
    (for i 0 n (= new_ls (cons (runcode code (box i)) new_ls)))
    (return (list_reverse new_ls))
    ))

(export fun list_at_check (ls i) (
    (var orig ls)
    (var j i)
    (while (&& (> j 0) ls) (do
        (-= j 1)
        (= ls (cdr ls))
        ))
    (if (! ls) (index_out_of_range orig i))
    (return (car ls))
    ))

(fun ls_at (ls i) (
    (return (list_at_check ls (unbox i)))
    ))

(export fun list_store_check (ls i v) (
    (var orig ls)
    (var j i)
    (while (&& (> j 0) ls) (do
        (-= j 1)
        (= ls (cdr ls))
        ))
    (if (! ls) (index_out_of_range orig i))
    (setcar ls v)
    (return v)
    ))

(fun ls_store (ls i v) (
    (return (list_store_check ls (unbox i) v))
    ))

(fun ls_length (ls) (
    (return (box (list_len ls)))
    ))

(fun ls_cons (a b) (
    (return (cons a b))
    ))

(fun ls_car (a) (
    (if (! a) (index_out_of_range a 0))
    (return (car a))
    ))
(fun ls_cdr (a) (
    (if (! a) (index_out_of_range a 1))
    (return (cdr a))
    ))

(fun ls_reverse (ls) (
    (return (list_reverse ls))
    ))

(fun ls_append (a b) (
    (return (list_append a b))
    ))

(fun ls_map (f ls) (
    (var new_ls 0)
    (var code (get_bytecode f))
    (while ls (do
        (= new_ls (cons (runcode code (car ls)) new_ls))
        (= ls (cdr ls))
        ))
    (return (list_reverse new_ls))
    ))

(fun ls_foldl (f v ls) (
    (if (! ls) (return v))
    (var code (get_bytecode f))
    (while ls (do
        (= v (runcode code v (car ls)))
        (= ls (cdr ls))
        ))
    (return v)
    ))

(fun foldr (ls v code) (
    (if (! ls) (return v))
    (return (runcode code (car ls) (foldr (cdr ls) v code)))
    ))

(fun ls_foldr (f ls v) (
    (var code (get_bytecode f))
    (return (foldr ls v code))
    ))

(extern fun tuple2)
(extern fun tuple_at)
(fun ls_zip (a b) (
    (var new_ls 0)
    (while (&& a b) (do
        (= new_ls (cons (tuple2 (car a) (car b)) new_ls))
        (= a (cdr a))
        (= b (cdr b))
        ))
    (return (list_reverse new_ls))
    ))

(fun ls_unzip (ls) (
    (var left 0)
    (var right 0)
    (var orig ls)
    (while ls (do
        (var t (car ls))
        (if (!= (node_type t) @TupleE)
            (throw (invalid_argument current_loc
                (string "List of tuples is required")
                orig)))
        (= left (cons (tuple_at t 0) left))
        (= right (cons (tuple_at t 1) right))
        (= ls (cdr ls))
        ))
    (return (tuple2 (list_reverse left) (list_reverse right)))
    ))

(fun ls_flatten (ls) (
    (var original ls)
    (var new_ls 0)
    (while ls (do
        (var t (car ls))
        (if (!= (node_type t) @ListE)
            (throw (invalid_argument current_loc
                (string "`flatten' requires list of lists")
                original)))
        (while t (do
            (= new_ls (cons (car t) new_ls))
            (= t (cdr t))
            ))
        (= ls (cdr ls))
        ))
    (return (list_reverse new_ls))
    ))

(export fun setup_list (global) (
    (var mod (set_undef_slot global (to_sym "List") (make_module (to_sym "List"))))
    (add_function2 mod (to_sym "new") intT funT ls_new 0)
    (add_function1 global (to_sym "length") listT ls_length 0)
    (add_function1 global (to_sym "size") listT ls_length 0)
    (add_function2 global (to_sym "cons") DontCare listT ls_cons 0)
    (add_function1 global (to_sym "car") listT ls_car 0)
    (add_function1 global (to_sym "cdr") listT ls_cdr 0)
    (add_function2 global (to_sym "at") listT intT ls_at 0)
    (add_function3 global (to_sym "store") listT intT DontCare ls_store 0)
    (add_function1 global (to_sym "reverse") listT ls_reverse 0)
    (add_function2 global (to_sym "append") listT listT ls_append 0)
    (add_function2 global (to_sym "map") funT listT ls_map 0)
    (add_function3 global (to_sym "foldl") funT DontCare listT ls_foldl 0)
    (add_function3 global (to_sym "foldr") funT listT DontCare ls_foldr 0)
    ))

    ))
