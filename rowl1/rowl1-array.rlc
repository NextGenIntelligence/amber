;
; rowl - 1st generation
; Copyright (C) 2012 nineties
;
; $Id: rowl1-array.rlc 2014-02-16 01:13:26 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-object")
(import "rowl1-module")
(import "rowl1-compile")
(import "rowl1-assemble")
(import "rowl1-error")

(extern object current_loc)

(fun index_out_of_range (ary idx) (
    (throw (out_of_range current_loc ary (box idx)))
    ))

(export fun ary_new () (
    (var capa 10)
    (var buf (allocate_array capa))
    (for i 0 capa (do
        (array_set object buf i @C_NIL)
        ))
    (return (variant @ArrayE 1 buf 0 capa))
    ))

(export fun ary_new2 (len) (
    (= len (unbox len))
    (var buf (allocate_array len))
    (for i 0 len (do
        (array_set object buf i @C_NIL)
        ))
    (return (variant @ArrayE 1 buf len len))
    ))

(export fun ary_new3 (len v) (
    (= len (unbox len))
    (var buf (allocate_array len))
    (for i 0 len (do
        (array_set object buf i v)
        ))
    (return (variant @ArrayE 1 buf len len))
    ))

(export fun array_size (ary) (
    (return (field_get ary 2))
    ))

(export fun array_copy (ary) (
    (var len (field_get ary 2))
    (var buffrom (field_get ary 1))
    (var bufto (allocate_array len))
    (for i 0 len (do
        (array_set object bufto i (array_get object buffrom i))
        ))
    (return (variant @ArrayE 1 bufto len len))
    ))

(export fun ary_size (ary) (
    (return (box (field_get ary 2)))
    ))

(fun array_resize (ary new_size) (
    (if (< new_size 0)
        (throw (invalid_argument current_loc (string "size of array must not be negative") (box new_size)))
        )
    (var buf (field_get ary 1))
    (var size (field_get ary 2))
    (var capa (field_get ary 3))
    (if (<= new_size size) (do
        (for i new_size size (array_set object buf i @C_NIL))
        (field_set ary 2 new_size)
        (return ary)
        ))
    (if (<= new_size capa) (do
        (field_set ary 2 new_size)
        (return ary)
        ))
    (var new_buf (allocate_array new_size))
    (memcpy new_buf buf (* 4 size))
    (for i size new_size (array_set object new_buf i @C_NIL))
    (field_set ary 1 new_buf)
    (field_set ary 2 new_size)
    (field_set ary 3 new_size)
    (return ary)
    ))

(export fun array_at (ary i) (
    (var size (array_size ary))
    (if (&& (>= i 0) (< i size))
        (return (array_get object (field_get ary 1) i)))
    (index_out_of_range ary i)
    ))

(export fun ary_at (ary i) (
    (return (array_at ary (unbox i)))
    ))

(export fun array_store (ary i v) (
    (var size (array_size ary))
    (if (< i size) (do
        (array_set object (field_get ary 1) i v)
        (return v)
        ))
    (array_resize ary (+ i 1))
    (array_set object (field_get ary 1) i v)
    (return v)
    ))

(export fun ary_store (ary i v) (
    (return (array_store ary (unbox i) v))
    ))

(export fun ary_push (ary v) (
    (ary_store ary (ary_size ary) v)
    (return ary)
    ))

(export fun ary_pop (ary) (
    (var n (array_size ary))
    (if (== n 0)
        (throw (logic_error1 current_loc
            (string "Can not pop element from empty array")
            ary
        )))
    (var v (array_at ary (- n 1)))
    (array_resize ary (- n 1))
    (return v)
    ))

(export fun array_restof (ary i) (
    (var ls 0)
    (var size (field_get ary 2))
    (var buf (field_get ary 1))
    (rfor j i size (do
        (= ls (cons (array_get object buf j) ls))
        ))
    (return ls)
    ))

(export fun ary_to_list (ary) (
    (var ls 0)
    (var size (field_get ary 2))
    (var buf (field_get ary 1))
    (rfor i 0 size (do
        (= ls (cons (array_get object buf i) ls))
        ))
    (return ls)
    ))

(export fun list_to_ary (ls) (
    (var size (list_len ls))
    (var buf (allocate_array size))
    (for i 0 size (do
        (array_set object buf i (car ls))
        (= ls (cdr ls))
        ))
    (return (variant @ArrayE 1 buf size size))
    ))

(fun ary_reverse (ary) (
    (var size (field_get ary 2))
    (var buf (field_get ary 1))
    (for i 0 (/ size 2) (do
        (var j (- (- size 1) i))
        (var a (array_get object buf i))
        (var b (array_get object buf j))
        (array_set object buf i b)
        (array_set object buf j a)
        ))
    (return ary)
    ))

(fun ary_append (ary1 ary2) (
    (var size1 (field_get ary1 2))
    (var buf1  (field_get ary1 1))
    (var size2 (field_get ary2 2))
    (var buf2  (field_get ary2 1))
    (var new_size (+ size1 size2))
    (var new (allocate_array new_size))
    (for i 0 size1 (do
        (array_set object new i (array_get object buf1 i))
        ))
    (for i 0 size2 (do
        (array_set object new (+ i size1) (array_get object buf2 i))
        ))
    (return (variant @ArrayE 1 new new_size new_size))
    ))

(fun ary_map (f ary) (
    (var size (field_get ary 2))
    (var buf  (field_get ary 1))
    (var new  (allocate_array size))
    (var code (get_bytecode f))
    (for i 0 size (do
        (array_set object buf i (runcode code (array_get object buf i)))
        ))
    (return ary)
    ))

(fun ary_foldl (f v ary) (
    (var buf (field_get ary 1))
    (var size (field_get ary 2))
    (var code (get_bytecode f))
    (for i 0 size (do
        (= v (runcode code v (array_get object buf i)))
        ))
    (return v)
    ))

(fun ary_foldl1 (f ary) (
    (var buf (field_get ary 1))
    (var size (field_get ary 2))
    (var code (get_bytecode f))
    (if (== size 0)
        (throw (invalid_argument current_loc (string "foldl1 requires non-empty array") ary))
        )
    (var v (array_get object buf 0))
    (for i 1 size (do
        (= v (runcode code v (array_get object buf i)))
        ))
    (return v)
    ))

(fun ary_foldr (f ary v) (
    (var buf (field_get ary 1))
    (var size (field_get ary 2))
    (var code (get_bytecode f))
    (rfor i 0 size (do
        (= v (runcode code (array_get object buf i) v))
        ))
    (return v)
    ))

(fun ary_foldr1 (f ary) (
    (var buf (field_get ary 1))
    (var size (field_get ary 2))
    (var code (get_bytecode f))
    (if (== size 0)
        (throw (invalid_argument current_loc (string "foldr1 requires non-empty array") ary))
        )
    (var v (array_get object buf (- size 1)))
    (rfor i 0 (- size 1) (do
        (= v (runcode code (array_get object buf i) v))
        ))
    (return v)
    ))

(export fun setup_array (mod) (
    (add_function0 mod (to_sym "array_new") ary_new 0)
    (add_function1 mod (to_sym "array_new_with_size") intT ary_new2 0)
    (add_function2 mod (to_sym "array_new_with_size_and_initial_value") intT DontCare ary_new3 0)
    (add_function1 mod (to_sym "list_to_array") listT list_to_ary 0)
    (add_function1 mod (to_sym "array_to_list") arrayT ary_to_list 0)

    (add_function1 mod (to_sym "array_length") arrayT ary_size 0)
    (add_function1 mod (to_sym "array_size") arrayT ary_size 0)
    (add_function2 mod (to_sym "array_at") arrayT intT ary_at 0)
    (add_function3 mod (to_sym "array_store") arrayT intT DontCare ary_store 0)
    (add_function2 mod (to_sym "array_push") arrayT DontCare ary_push 0)
    (add_function1 mod (to_sym "array_pop") arrayT ary_pop 0)

    (add_function1 mod (to_sym "array_reverse") arrayT ary_reverse 0)
    (add_function2 mod (to_sym "array_append") arrayT arrayT ary_append 0)
    (add_function2 mod (to_sym "array_map") funT arrayT ary_map 0)
    (add_function3 mod (to_sym "array_foldl") funT DontCare arrayT ary_foldl 0)
    (add_function2 mod (to_sym "array_foldl1") funT arrayT ary_foldl1 0)
    (add_function3 mod (to_sym "array_foldr") funT arrayT DontCare ary_foldr 0)
    (add_function2 mod (to_sym "array_foldr1") funT arrayT ary_foldr1 0)

    ))

    ))
