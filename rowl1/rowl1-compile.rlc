;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-compile.rlc 2012-12-17 10:34:08 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-module")
(import "rowl1-assemble")
(import "rowl1-error")

(var Closure       (to_sym "%Closure"))
(var AllocClsEnv   (to_sym "%AllocClosureEnv"))
(var Ref           (to_sym "%Ref"))
(var Decons        (to_sym "%Decons"))
(var uninitialized (to_sym "%uninitialized"))
(var noguard       (to_sym "%noguard"))
(var closed        (to_sym "%closed"))

; compilers

(extern object current_loc)
(extern object current_mod)
(extern fun set_loc)

(fun trace_func (msg val) (
    (debugs msg)
    (debugpf val)
    (return val)
    ))

(fun trace (asm msg) (
    (put_push asm (string msg))
    (compile_simple_call asm 2 trace_func)
    ))

(fun defined_symbol (expr) (
    (var lhs (node_arg expr 0))
    (if (is_symbol lhs) (return lhs))
    (var hd (node_head lhs))
    (if (== hd Ref) (return (node_arg lhs 2)))
    (return @C_NIL)
    ))

(export fun callable (expr) (
    (var ty (node_type expr))
    (if (== ty @FunctionE) (return @TRUE)
    (if (== ty @BoundFunctionE) (return @TRUE)
        (return @FALSE)))
    ))

(fun iter_args (f node arg level) (
    (if (is_special node) (return arg))
    (if (is_symbol node)
        (if (== level 0) (return (f node arg)) (return arg))
        )
    (if (is_atom node) (return arg))
    (if (is_list node) (do
        (lfor v node (= arg (iter_args f v arg level)))
        (return arg)
        ))
    (var hd (node_head node))
    (if (== hd Quote) (return arg))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote)    (-= level 1)
        ))
    (for i 0 (node_size node)
        (= arg (iter_args f (node_arg node i) arg level))
        )
    (return arg)
    ))

(fun delete_args (node fv) (
    (if (== (node_head node) Where)
        (return (iter_args list_delete (node_arg node 0) fv 0))
        (return (iter_args list_delete node fv 0))
        )
    ))

(fun add_var (sym list) (
    (return (cons sym (list_delete sym list)))
    ))

(fun collect_args (args) (
    (if (== (node_head args) Where)
        (return (iter_args add_var (node_arg args 0) 0 0))
        (return (iter_args add_var args 0 0))
        )
    ))

(fun fv_iter_block (mod stmts fv) (
    (if (! stmts) (return fv))
    (= fv (fv_iter_block mod (cdr stmts) fv))
    (return (fv_iter mod (car stmts) 0 fv))
    ))

(fun fv_iter (mod expr level fv) (
    (if (is_symbol expr) (do
        (if (== level 0) (do
            (if (is_special expr) (return fv))
            (if (== expr DontCare) (return fv))
            (= fv (list_delete expr fv))
            (var info (lookup_symbol mod expr))
            ; module-variables and special symbols are not free.
            (if (== (node_head info) ModuleVariable) (return fv))
            (return (cons expr fv))
            ))
        (return fv)
        ))
    (if (is_atom expr) (return fv))
    (if (is_list expr) (do
        (lfor v expr (= fv (fv_iter mod v level fv)))
        (return fv)
        ))
    (var hd (node_head expr))
    (if (== level 0) (do
        (if (|| (== hd DefVariable) (== hd DefFunction)) (do
            (= fv (fv_iter mod (node_arg expr 1) 0 fv))
            (return (delete_args (node_arg expr 0) fv))
            ))
        (if (== hd Lambda) (do
            (= fv (fv_iter mod (node_arg expr 1) 0 fv))
            (var arg (node_arg expr 0))
            (if (== (node_head arg) Where)
                (= fv (fv_iter mod (node_arg arg 1) 0 fv))
                )
            (return (delete_args (node_arg expr 0) fv))
            ))
        (if (== hd Ref)
            (return (fv_iter mod (node_arg expr 0) 0 fv))
            )
        (if (|| (== hd Block) (== hd Breakable))
            (return (fv_iter_block mod (node_arg_list expr 0) fv))
            )
        (if (== hd Dynamic)
            (return fv)
            )
        ))
    (if (== hd Quote) (return fv))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1)))

    (for i 0 (node_size expr)
        (= fv (fv_iter mod (node_arg expr i) level fv))
        )
    (return fv)
    ))

(fun free_variables (mod expr) (
    (return (fv_iter mod expr 0 0))
    ))

;== alpha-conversion ==

; This routine also translates
; f(... x ... x ...) : body
; to
; f(... x ... y ...) where x==y : body

(fun alpha_args_iter (tbl chk rep expr level) (
    (if (is_symbol expr) (do
        (if (== expr DontCare) (return expr))
        (if (is_special expr) (return expr))
        (if (== level 0) (do
            (if (symtable_find tbl expr)
                (do
                    (var new_sym (unique_sym))
                    (symtable_add tbl expr new_sym)
                    (if (list_member expr (field_get chk 0)) (do
                        (field_set rep 0 (cons (struct 2 expr new_sym)
                            (field_get rep 0)))
                        ))
                    (return new_sym)
                )
                (do
                    (symtable_add tbl expr expr)
                    (field_set chk 0 (cons expr (field_get chk 0)))
                    (return expr)
                ))
            ))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (alpha_args_iter tbl chk rep (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Quote) (return expr))
    (if (== hd Domain)
        (if (== level 0) (do
            (node_arg_set expr 0
                (alpha_args_iter tbl chk rep (node_arg expr 0) 0))
            (var dom (node_arg expr 1))
            (if (! (is_symbol dom))
                (node_arg_set expr 1 (alpha_args_iter tbl chk rep dom 0))
                )
            (return expr)
            ))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1))))
    (for i 0 (node_size expr)
        (node_arg_set expr i
            (alpha_args_iter tbl chk rep (node_arg expr i) level))
        )
    (return expr)
    ))

(fun setup_guard (rep guard) (
    (lfor v (field_get rep 0) (do
        (var v1 (field_get v 0))
        (var v2 (field_get v 1))
        (if (== guard @C_NIL)
            (= guard (make_node2 Equal v1 v2))
            (= guard (make_node2 SeqAnd guard (make_node2 Equal v1 v2)))
            )
        ))
    (return guard)
    ))

(fun alpha_args (tbl args) (
    (var chk (struct 1 0))
    (var rep (struct 1 0))
    (if (== (node_head args) Where)
        (do
            (node_arg_set args 0
                (alpha_args_iter tbl chk rep (node_arg args 0) 0)) 
            (var guard (alpha tbl (node_arg args 1)))
            (node_arg_set args 1 (setup_guard rep guard))
            (return args)
        )
        (do
            (= args (alpha_args_iter tbl chk rep args 0))
            (var guard (setup_guard rep @C_NIL))
            (if (== guard @C_NIL)
                (return args)
                (return (make_node2 Where args guard))
                )
        ))
    ))

(fun alpha (tbl expr) (
    (if (is_symbol expr) (do
        (if (== expr DontCare) (return expr))
        (if (is_special expr) (return expr))
        (var subst (symtable_find tbl expr))
        (if subst (return subst))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (alpha tbl (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Located) (do
        (node_arg_set expr 1 (alpha tbl (node_arg expr 1)))
        (return expr)
        ))
    (if (|| (== hd DefVariable) (== hd DefFunction)) (do
        (node_arg_set expr 0 (alpha_args tbl (node_arg expr 0)))
        (node_arg_set expr 1 (alpha tbl (node_arg expr 1)))
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (var exprs (node_arg_list expr 0))
        (symtable_push tbl)
        (while exprs (do
            (setcar exprs (alpha tbl (car exprs)))
            (= exprs (cdr exprs))
            ))
        (symtable_pop tbl)
        (return expr)
        ))
    (if (== hd Lambda) (do
        (symtable_push tbl)
        (node_arg_set expr 0 (alpha_args tbl (node_arg expr 0)))
        (node_arg_set expr 1 (alpha tbl (node_arg expr 1)))
        (symtable_pop tbl)
        (return expr)
        ))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (alpha_qquote tbl (node_arg expr 0) 0))
        (return expr)
        ))
    (if (== hd Dynamic)
        (return expr)
        )
    (for i 0 (node_size expr)
        (node_arg_set expr i (alpha tbl (node_arg expr i)))
        )
    (return expr)
    ))

(fun alpha_qquote (tbl expr level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (alpha_qquote tbl (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (node_arg_set expr 0 (alpha tbl (node_arg expr 0)))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i (alpha_qquote tbl (node_arg expr i) level))
        )
    (return expr)
    ))

(fun alloc_function (args code guard) (
    (return (variant @FunctionE 4 0 args code guard))
    ))

(fun make_function (args code guard) (
    (var arity (list_len args))
    (= args (cons (box arity) args))
    (return (alloc_function args code guard))
    ))

(fun make_bound (fun1 fun2) (
    (if (! (callable fun1))
        (throw (type_error current_loc (string "function") fun1))
        )
    (if (! (callable fun2))
        (throw (type_error current_loc (string "function") fun2))
        )
    (return (variant @BoundFunctionE 3 0 fun1 fun2))
    ))

(var maybe (to_sym "maybe"))
(fun scan_clsvars (mod expr tbl) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (scan_clsvars mod (car ls) tbl))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Located) (do
        (node_arg_set expr 1 (scan_clsvars mod (node_arg expr 1) tbl))
        (return expr)
        ))
    (if (|| (== hd DefVariable) (== hd DefFunction)) (do
        (var sym (defined_symbol expr))
        (if (! (symtable_find tbl sym)) (do
            (symtable_add tbl sym maybe)
            ))
        (node_arg_set expr 1 (scan_clsvars mod (node_arg expr 1) tbl))
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (var exprs (node_arg_list expr 0))
        (while exprs (do
            (setcar exprs (scan_clsvars mod (car exprs) tbl))
            (= exprs (cdr exprs))
            ))
        (return expr)
        ))
    (if (== hd Lambda) (do
        ; free variables of lambdas will be closure variables.
        (var fv (free_variables mod expr))
        (if (! fv) (return expr))
        (while fv (do
            (var info (symtable_find tbl (car fv)))
            (if (== info maybe) (do
                (symtable_replace tbl (car fv) @C_TRUE)
                ))
            (= fv (cdr fv))
            ))
        (return (make_node2 Closure @C_NIL expr))
        ))
    ; Closure has no closure variables since it is already closed.
    (if (== hd Closure) (return expr))
    (if (== hd Ref) (return expr))
    (if (== hd Quote) (return expr))
    (if (== hd Dynamic) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0
            (scan_clsvars_qquote mod (node_arg expr 0) tbl 0))
        (return expr)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i (scan_clsvars mod (node_arg expr i) tbl))
        )
    (return expr)
    ))

(fun scan_clsvars_qquote (mod expr tbl level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (scan_clsvars_qquote mod (car ls) tbl level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (node_arg_set expr 0 (scan_clsvars mod (node_arg expr 0) tbl))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote) 
        (+= level 1)
        ))
    (for i 0 (node_size)
        (node_arg_set expr i
            (scan_clsvars_qquote mod (node_arg expr i) tbl level))
        )
    (return expr)
    ))

(fun subst_clsvars (tbl cls expr) (
    (if (is_special expr) (return expr))
    (if (is_symbol expr) (do
        (var v (symtable_find tbl expr))
        (if (&& v (!= v maybe)) (return (clone v)))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (subst_clsvars tbl cls (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_head expr))
    (if (== hd Located) (do
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (|| (== hd DefVariable) (== hd DefFunction)) (do
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (node_arg_set expr 0 (subst_clsvars tbl cls (node_arg expr 0)))
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (var exprs (node_arg_list expr 0))
        (while exprs (do
            (setcar exprs (subst_clsvars tbl cls (car exprs)))
            (= exprs (cdr exprs))
            ))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (node_arg expr 0))
        (if (== (node_head lhs) Where)
            (node_arg_set lhs 1 (subst_clsvars tbl cls (node_arg lhs 1)))
            )
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Closure) (do
        (if (== (node_arg expr 0) @C_NIL)
            (node_arg_set expr 0 cls)
            )
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Ref) (do
        (return (make_node3 Ref
            (subst_clsvars tbl cls (node_arg expr 0))
            (node_arg expr 1)
            (node_arg expr 2)
            ))
        ))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (subst_clsvars_qquote tbl cls (node_arg expr 0) 0))
        (return expr)
        ))
    ; The binding of a dynamic variable is resolved at run-time.
    (if (== hd Dynamic) (return expr))
    (for i 0 (node_size expr)
        (node_arg_set expr i (subst_clsvars tbl cls (node_arg expr i)))
        )
    (return expr)
    ))

(fun subst_clsvars_qquote (tbl cls expr level) (
    (if (is_atom expr) (return expr))
    (var hd (node_head expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (node_arg_set expr 0 (subst_clsvars tbl cls (node_arg expr 0)))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote) 
        (+= level 1)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i
            (subst_clsvars_qquote tbl cls (node_arg expr i) level))
        )
    (return expr)
    ))

(extern fun compile_matching)
(export fun lookup_func (mod sym) (
    (var def (lookup_symbol mod sym))
    (if (! def) 
        (throw (undefined_fun current_loc sym))
        )
    (must_be_module_variable sym def)
    (check_init sym def)
    (var box (node_arg def 0))
    (var func (field_get box 0))
    (if (! (callable func))
        (throw (type_error current_loc (string "function") func))
        )
    (var loc (field_get box 1))
    (return (compile_matching loc sym func))
    ))

(export fun get_bytecode (func) (
    (return (compile_matching current_loc func func))
    ))

(var closure_frame null)

(export fun compile_main (mod expr) (
    (var asm (make_assembler))
    (compile asm mod (alpha (make_symtable 10) expr))
    (put_ireturn asm)
    (return (get_code asm))
    ))

(fun compile (asm mod expr) (
    (byterun (lookup_func mod Compile) asm mod expr)
    ))

(export fun call1 (sym arg0) (
    (return (byterun (lookup_func current_mod sym) arg0))
    ))

(export fun call2 (sym arg0 arg1) (
    (return (byterun (lookup_func current_mod sym) arg0 arg1))
    ))

(export fun call3 (sym arg0 arg1 arg2) (
    (return (byterun (lookup_func current_mod sym) arg0 arg1 arg2))
    ))

(fun topscope_only (asm mod expr) (
    (throw (unexpected_error current_loc
        (string "Allowed only in top-level scope")
        expr))
    ))

(fun check_arg_size (name size expr) (
    (if (!= (node_size expr) size)
        (throw (type_error current_loc
            (strcat "expression with "
            (strcat (itos size) " arguments"))
            expr
            ))
        )
    ))

(fun compile_error (asm mod expr) (
    (throw (unknown_expression current_loc expr))
    ))

(fun compile_located (asm mod expr) (
    (set_loc (node_arg expr 0))
    (compile asm mod (node_arg expr 1))
    ))

(fun compile_special (asm mod expr) (
    (put_imm_int16 asm expr)
    ))

(fun compile_const_int (asm mod expr) (
    (put_imm_int asm expr)
    ))

(fun compile_const (asm mod expr) (
    (put_push asm expr)
    ))

(fun compile_qualified (asm mod expr) (
    (var modsig (node_arg expr 0))
    (var module (find_module current_loc mod modsig @FALSE))
    (compile asm module (node_arg expr 1))
    ))

(fun compile_make_node (asm mod expr) (
    (compile asm mod (node_arg expr 1))
    (compile asm mod (node_arg expr 0))
    (compile_simple_call asm 2 make_node)
    ))

(fun compile_head (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (compile_simple_call asm 1 node_head)
    ))

(fun compile_arguments (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (compile_simple_call asm 1 node_args)
    ))

(fun compile_exprat (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (compile asm mod (node_arg expr 1))
    (put_unbox asm)
    (put_iadd1 asm)
    (put_array_get32 asm)
    ))

(fun store_args (tbl args stmts) (
    (var vars (collect_args args))
    (while vars (do
        (var s (symtable_find tbl (car vars)))
        (if (&& s (!= s maybe)) (do 
            ; this argument is a closure-variable.
            (= stmts (cons (make_node2 Assign (clone s) (car vars)) stmts))
            ))
        (= vars (cdr vars))
        ))
    (return stmts)
    ))

(fun setup_closure_env (subst cls) (
    (var entries (symtable_entries subst))
    (var count 0)
    (for i 0 (vector_size entries) (do
        (var entry (vector_at entries i))
        (if (!= (field_get entry 1) maybe) (do
            (field_set entry 1
                (make_node3 Ref cls (box count) (field_get entry 0)))
            (+= count 1)
            ))
        ))
    (return count)
    ))

(var max_lvar_idx 0)
(var break_labels null)
(var continue_labels null)

(fun get_lvar_idx (mod) (
    (var idx (get_variable_count mod))
    (if (>= idx max_lvar_idx) (= max_lvar_idx (+ idx 1)))
    (incr_variable_count mod)
    (return idx)
    ))

(fun compile_function (asm_body asm_guard mod args body guard cls) (
    ;; closure conversion
    (var tbl (make_symtable 10))
    (var vars (collect_args args))
    (while vars (do
        (symtable_add tbl (car vars) maybe)
        (= vars (cdr vars))
        ))
    (if (!= cls @C_NIL)
        (symtable_add tbl cls maybe)
        )
    (= body (scan_clsvars mod body tbl))

    ; this function needs to allocate an environment for closures.
    (var newcls (unique_sym)) ; closures' environment.
    (var clssize (setup_closure_env tbl newcls))
    (if (> clssize 0) (do
        (= body (subst_clsvars tbl newcls body))

        ; allocate closures' environment.
        (var stmts 0)
        (= stmts (cons (defvar newcls
            (make_node1 AllocClsEnv (box clssize))) stmts))
        (if (== cls @C_NIL)
            (= stmts (store_args tbl args stmts))
            (= stmts (store_args tbl (cons cls args) stmts))
            )
        (= stmts (cons body stmts))
        (= body (make_node1 Block (list_reverse stmts)))
        ))
    (push_varscope mod)

    (var cnt_addr (get_address asm_body))
    (put_allocate asm_body 0)

    (var save_max_lvar_idx max_lvar_idx)
    (var save_break_labels break_labels)
    (var save_continue_labels continue_labels)
    (= max_lvar_idx 0)
    (= break_labels 0)
    (= continue_labels 0)

    (reset_variable_count mod)

    (setup_args (get_vartable mod) args)

    (if (!= guard noguard)
        (compile asm_guard mod guard)
        )

    (compile asm_body mod body)

    (put_operand_byte asm_body (+ cnt_addr 1) max_lvar_idx)
    (pop_varscope mod)

    (= max_lvar_idx save_max_lvar_idx)
    (= break_labels save_break_labels)
    (= continue_labels save_continue_labels)
    ))

(fun setup_args (tbl args) (
    (var idx 0)
    (while args (do
        (setup_arg tbl (make_arg idx) (car args) 0)
        (= args (cdr args))
        (+= idx 1)
        ))
    ))

(fun setup_arg (tbl obj arg level) (
    (if (is_special arg) return)
    (if (is_symbol arg) (do
        (if (== level 0) (symtable_add tbl arg obj))
        return
        ))
    (if (is_atom arg) return)
    (var argty (node_head arg))
    (if (== argty Domain) (do
        (if (== level 0) (do
            (var v (node_arg_symbol arg 0))
            (symtable_add tbl v obj)
            (var dom (node_arg arg 1))
            (if (! (is_symbol dom))
                (setup_arg tbl obj dom 0)
                )
            return
            ))
        ))
    (if (== argty List) (do
        (var idx 0)
        (while arg (do
            (var a (car arg))
            (if (== (node_head a) Ellipsis) (do
                (if (cdr arg)
                    (throw (exception current_loc (string
                        "\"...\" node must be placed last in the order of arguments")))
                    )
                (var v (node_arg_symbol a 0))
                (if (== v @C_NIL) return)
                (= obj (make_list_from obj idx))
                (symtable_add tbl v obj)
                return
                ))
            (setup_arg tbl (make_list_at obj idx) a level)
            (= arg (cdr arg))
            (incr idx)
            ))
        return
        ))
    (if (== argty Quote) return)
    (if (== argty Unquote) 
        (return (setup_arg tbl obj (node_arg arg 0) (- level 1)))
        )
    (if (== argty QuasiQuote)
        (return (setup_arg tbl obj (node_arg arg 0) (+ level 1)))
        )
    (if (== argty Ellipsis)
        (throw (exception current_loc (string "Variable-length arguments is not allowed")))
        )
    (for i 0 (node_size arg) (do
        (var a (node_arg arg i))
        (if (== (node_head a) Ellipsis) (do
            (if (!= (+ i 1) (node_size arg))
                (throw (exception current_loc (string
                    "\"...\" must be placed last in the order of arguments"
                ))))
            (var v (node_arg_symbol a 0))
            (if (== v @C_NIL) return)
            (= obj (make_restof obj i))
            (symtable_add tbl v obj)
            return
            ))
        (setup_arg tbl (make_node_at arg obj i) (node_arg arg i) level)
        ))
    ))

(fun var_loc (info) (
    (var hd (node_head info))
    (if (|| (== hd ListAt) (|| (== hd ListFrom) (|| (== hd ExprAt) (== hd RestOf))))
        (return (var_loc (node_arg info 0)))
        )
    (if (== hd ModuleVariable) (do
        (var box (node_arg info 0))
        (if (! box)
            (return no_loc)
            (return (field_get box 1))
            )
        ))
    (return (node_arg info 1))
    ))

(fun make_lvar (idx) (
    (return (make_node2 LocalVariable (box idx) current_loc))
    ))

(export fun get_arity () (
    (return (make_node Arity 0))
    ))

(export fun make_arg (idx) (
    (return (make_node2 Argument (box idx) current_loc))
    ))

(export fun make_list_at (obj idx) (
    (return (make_node2 ListAt obj (box idx)))
    ))

(export fun make_list_from (obj idx) (
    (return (make_node2 ListFrom obj (box idx)))
    ))

(export fun make_node_at (arg obj idx) (
    (if (is_tuple arg) (return (make_node2 TupleAt obj (box idx))))
    (if (is_array arg) (return (make_node2 ArrayAt obj (box idx))))
    (return (make_node2 ExprAt obj (box idx)))
    ))

(export fun make_restof (obj idx) (
    (return (make_node2 RestOf obj (box idx)))
    ))

(fun compile_define_variable (asm mod expr) (
    (var rhs_head (node_head (node_arg expr 1)))
    (if (|| (== rhs_head Lambda) (== rhs_head Bind))
        (compile_define_function asm mod expr)
        (compile_define_variable_ asm mod expr)
        )
    ))
(fun compile_define_variable_ (asm mod expr) (
    (var overwrite @C_FALSE)
    (if (&& (== (node_size expr) 3)
            (== (node_arg expr 2) (to_sym "overwrite")))
        (= overwrite @C_TRUE)
        )
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))

    (if (== (node_head lhs) Ref)
        (return (compile_define_clsref asm mod lhs rhs overwrite))
        )
    (if (! (is_symbol lhs))
        (return (compile_define_multi_variable asm mod lhs rhs overwrite))
        )

    (if (in_top_scope mod)
        (compile_define_variable_top   asm mod lhs rhs overwrite)
        (compile_define_variable_local asm mod lhs rhs overwrite)
        )
    ))

; translate
;
; Foo{x, y, Bar{z}} : e
;
; to
;
; tmp: (t@Foo{x, y, Bar{z}} -> [x,y,z,t])(e)
; x: decons(tmp)
; y: decons(tmp)
; z: decons(tmp)
; car(tmp)
(fun compile_define_multi_variable (asm mod lhs rhs overwrite) (
    (var vars (collect_args lhs))
    (var t (unique_sym))
    (compile asm mod (apply (lambda
        (list1 (make_node2 Domain t lhs))
        (list_append vars (list1 t))) (list1 rhs)))

    (while vars (do
        (var def @C_NIL)
        (if (== overwrite @C_TRUE)
            (= def (make_node3 DefVariable (car vars) Decons (to_sym "overwrite")))
            (= def (make_node2 DefVariable (car vars) Decons))
            )
        (compile_define_variable asm mod def)
        (put_drop asm)

        (= vars (cdr vars))
        ))
    (put_car asm)
    ))

(fun compile_decons (asm mod expr) (
    (put_decons asm)
    ))

(fun compile_define_variable_top (asm mod lhs rhs overwrite) (
    (if (== overwrite @C_FALSE) (check_redefinition mod lhs))
    (compile asm mod rhs)
    (put_push asm overwrite)
    (put_push asm lhs)
    (put_push asm mod)
    (compile_simple_call asm 4 add_module_variable)
    ))

(fun compile_define_variable_local (asm mod lhs rhs overwrite) (
    (if (is_symbol lhs) (do
        (var idx 0)
        (if (== overwrite @C_TRUE)
            (do
                (var info (lookup_symbol mod lhs))
                (= idx (node_arg_int info 0))
            )
            (do
                (check_redefinition mod lhs)
                (= idx (get_lvar_idx mod))
                (add_symbol mod lhs (make_lvar idx))
            ))
        (compile asm mod rhs)
        (put_dup asm)
        (put_store_lvar asm idx)
        return
        ))
    (throw (string "not implemented"))
    ))

(fun compile_define_clsref (asm mod clsref rhs overwrite) (
    (if (== overwrite @C_FALSE) (add_symbol mod (node_arg_symbol clsref 2) clsref))
    (compile asm mod (assign clsref rhs))
    ))

(fun check_redefinition (mod sym) (
    (var info (lookup_symbol_local mod sym))
    (if (! info) return)
    (if (== (node_head info) ModuleVariable) (do
        (if (|| (== (node_arg info 1) @C_FALSE) (== (node_arg info 2) @C_TRUE))
            return
            )
        ))
    (throw (redefined_var current_loc (var_loc info) sym))
    ))

(fun check_init (sym info) (
    (var box (node_arg info 0))
    (if (! box) (do
        (var loc (node_arg info 1))
        (throw (uninitialized_var loc sym))
        ))
    ))

(fun load_module_variable (sym node) (
    (var v (field_get (field_get node 1) 0))
    (if (== v uninitialized) (throw (uninitialized_var current_loc sym)))
    (return v)
    ))

(export fun compile_operand (asm opd sym) (
    (if (== sym closure_frame) (do
        (put_load_closure asm)
        return
        ))

    (var ty (node_head opd))
    (if (== ty ModuleVariable) (do
        (put_push asm opd)
        (put_push asm sym)
        (compile_simple_call asm 2 load_module_variable)
        return
        ))
    (if (== ty LocalVariable) (do
        (put_load_lvar asm (node_arg_int opd 0))
        return
        ))
    (if (== ty Arity) (do
        (put_arity asm)
        (put_box asm)
        return
        ))
    (if (== ty Argument) (do
        (put_arg asm (node_arg_int opd 0))
        return
        ))
    (if (== ty ListAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_list_at asm)
        return
        ))
    (if (== ty ListFrom) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_list_from asm)
        return
        ))
    (if (== ty TupleAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_array_get32 asm)
        return
        ))
    (if (== ty ArrayAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_field_get1 asm)
        (put_imm_int asm (node_arg_int opd 1))
        (put_array_get32 asm)
        ))
    (if (== ty ExprAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (+ (node_arg_int opd 1) 1))
        (put_array_get32 asm)
        return
        ))
    (if (== ty RestOf) (do
        (put_imm_int asm (node_arg_int opd 1))
        (compile_operand asm (node_arg opd 0) sym)
        (compile_simple_call asm 2 node_restof)
        return
        ))
    (not_reachable "compile_operand")
    ))

(fun compile_var (asm mod sym) (
    (var v (lookup_symbol mod sym))
    (if (! v)
        ; `sym' is a module variable
        (= v (add_module_variable_display mod sym (struct 2 uninitialized no_loc)))
    (if (== (node_head v) ModuleVariable) (do
        (var u (lookup_symbol_current_module mod sym))
        (if (! u)
            (= v (add_module_variable_display mod sym (node_arg v 0)))
            )
        )))
    (compile_operand asm v sym)
    ))

(fun lookup_dynamic_var (sym) (
    (var info (lookup_effective_symbol current_mod sym))
    (must_be_module_variable sym info)
    (var box (node_arg info 0))
    (return (field_get box 0))
    ))

(fun compile_dynamic_var (asm mod expr) (
    (var sym (node_arg_symbol expr 0))
    (put_push asm sym)
    (compile_simple_call asm 1 lookup_dynamic_var)
    ))

(fun compile_apply (asm mod expr) (
    (var func (node_arg expr 0))
    (var args (node_arg expr 1))
    
    ; eval and push arguments from right to left
    (= args (list_reverse args))
    (var arity 0)
    (while args (do
        (compile asm mod (car args))
        (= args (cdr args))
        (incr arity)
        ))

    (compile asm mod func)
    (put_push asm func)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity))
    ))

(fun compile_unquote (asm mod expr) (
    (throw (exception current_loc (string "unquotation outside quasi-quotation")))
    ))

(fun compile_quote (asm mod expr) (
    (put_push asm (node_arg expr 0))
    ))

(extern fun tuple2)
(extern fun tuple3)
(extern fun tuple4)
(extern fun tuple5)

(export fun compile_qquote_main (asm mod expr level) (
    (var hd (node_head expr))
    (if (== hd Symbol)
        (return (put_push asm expr)))
    (if (== hd Int)
        (return (put_imm_int asm expr)))
    (if (== hd String)
        (return (put_push asm expr)))
    (if (is_atom expr)
        (return (put_push asm expr)))
    (if (== hd List) (do
        (if (! expr)
            (put_zero asm)
            (do
                (compile_qquote_main asm mod (cdr expr) level)
                (compile_qquote_main asm mod (car expr) level)
                (put_cons asm)
            )
        )
        return
        ))
    (if (== hd Unquote)
        (if (== level 0)
            (return (compile asm mod (node_arg expr 0)))
            (return (compile_qquote_main asm mod (node_arg expr 0) (- level 1))) 
            )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))

    (put_zero asm)
    (rfor i 0 (node_size expr) (do
        (compile_qquote_main asm mod (node_arg expr i) level)
        (put_cons asm)
        ))
    (put_push asm (node_head expr))
    (compile_simple_call asm 2 make_node)
    ))

(fun compile_qquote (asm mod expr) (
    (compile_qquote_main asm mod (node_arg expr 0) 0)
    ))

(fun compile_list (asm mod expr) (
    (if (== expr 0)
        (put_zero asm)
        (do
            (compile asm mod (cdr expr))
            (compile asm mod (car expr))
            (put_cons asm)
        ))
    ))

(extern fun tuple_at)
(fun compile_tuple (asm mod expr) (
    (var n (seq_size expr))
    (put_zero asm)
    (rfor i 0 n (do
        (compile asm mod (tuple_at expr i))
        (put_cons asm)
        ))
    (put_push asm Tuple)
    (compile_simple_call asm 2 make_node)
    ))

(extern fun array_size)
(extern fun array_at)
(fun compile_array (asm mod expr) (
    (var n (array_size expr))
    (put_zero asm)
    (rfor i 0 n (do
        (compile asm mod (array_at expr i))
        (put_cons asm)
        ))
    (put_push asm Array)
    (compile_simple_call asm 2 make_node)
    ))

(fun compile_range (asm mod expr) (
    (compile asm mod (node_arg expr 1))
    (compile asm mod (node_arg expr 0))
    (put_push asm Range)
    (compile_simple_call asm 3 make_node2)
    ))

(fun compile_block_body (asm mod exprs) (
    (if (! exprs) (do
        (put_nil asm)
        return
        ))
    (while exprs (do
        (compile asm mod (car exprs))
        (= exprs (cdr exprs))
        (if exprs (put_drop asm)) ; drop values except the last one
        ))
    ))

(fun compile_block (asm mod expr) (
    (if (in_top_scope mod)
        (return (compile_function asm 0 mod 0 expr noguard @C_NIL))
        )
    (var exprs (node_arg expr 0))
    (push_varscope mod)
    (compile_block_body asm mod exprs)
    (pop_varscope mod)
    ))

(fun compile_breakable (asm mod expr) (
    (if (in_top_scope mod)
        (return (compile_function asm 0 mod 0 expr noguard @C_NIL))
        )
    (var break_lbl (fresh_label asm))
    (var exit_lbl  (fresh_label asm))
    (= break_labels (cons (box break_lbl) break_labels))
    (compile_block asm mod expr)
    (put_goto asm exit_lbl)
    (set_label asm break_lbl)
    (put_nil asm)
    (set_label asm exit_lbl)
    (= break_labels (cdr break_labels))
    ))

(fun compile_seq (asm mod expr) (
    (compile_block_body asm mod (node_arg expr 0))
    ))

(fun compile_scoped (asm mod expr) (
    (var scope (node_arg expr 0))
    (set_variable_count scope (get_variable_count mod))
    (compile asm scope (node_arg expr 1))
    ))

(fun compile_if (asm mod expr) (
    (compile_ifelse_main asm mod (node_arg expr 0) (node_arg expr 1) @C_NIL)
    ))

(fun compile_ifelse (asm mod expr) (
    (compile_ifelse_main asm mod (node_arg expr 0) (node_arg expr 1) (node_arg expr 2))
    ))

(fun compile_ifelse_main (asm mod cnd ifthen ifelse) (
    (var cnd_hd (node_head cnd))
    (var size (node_size cnd))
    (if (&& (== cnd_hd Not) (== size 1))
        (return (compile_ifelse_main asm mod (node_arg cnd 0) ifelse ifthen))
        )
    (if (&& (== cnd_hd SeqAnd) (== size 2))
        (return (compile_ifelse_and asm mod cnd ifthen ifelse))
        )
    (if (&& (== cnd_hd SeqOr) (== size 2))
        (return (compile_ifelse_or asm mod cnd ifthen ifelse))
        )
    (if (== ifthen @C_NIL)
        (if (== ifelse @C_NIL)
            (do
                (compile asm mod cnd)
                (put_drop asm)
                (put_nil asm)
            )
            (do
                (var exit_lbl (fresh_label asm))
                (var cont_lbl (fresh_label asm))
                (compile asm mod cnd)
                (put_if_true asm exit_lbl)
                (compile asm mod ifelse)
                (put_goto asm cont_lbl)
                (set_label asm exit_lbl)
                (put_nil asm)
                (set_label asm cont_lbl)
            ))
        (if (== ifelse @C_NIL)
            (do
                (var exit_lbl (fresh_label asm))
                (var cont_lbl (fresh_label asm))
                (compile asm mod cnd)
                (put_if_false asm exit_lbl)
                (compile asm mod ifthen)
                (put_goto asm cont_lbl)
                (set_label asm exit_lbl)
                (put_nil asm)
                (set_label asm cont_lbl)
            )
            (do
                (var else_lbl (fresh_label asm))
                (var exit_lbl (fresh_label asm))
                (compile asm mod cnd)
                (put_if_false asm else_lbl)
                (compile asm mod ifthen)
                (put_goto asm exit_lbl)
                (set_label asm else_lbl)
                (compile asm mod ifelse)
                (set_label asm exit_lbl)
            ))
        )
    ))

(fun compile_ifelse_and (asm mod cnd ifthen ifelse) (
    (var ifelse_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_false asm mod (node_arg cnd 0) ifelse_lbl)
    (exit_if_false asm mod (node_arg cnd 1) ifelse_lbl)
    (compile asm mod ifthen)
    (put_goto asm exit_lbl)
    (set_label asm ifelse_lbl)
    (compile asm mod ifelse)
    (set_label asm exit_lbl)
    ))

(fun compile_ifelse_or (asm mod cnd ifthen ifelse) (
    (var ifthen_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_true asm mod (node_arg cnd 0) ifthen_lbl)
    (exit_if_true asm mod (node_arg cnd 1) ifthen_lbl)
    (compile asm mod ifelse)
    (put_goto asm exit_lbl)
    (set_label asm ifthen_lbl)
    (compile asm mod ifthen)
    (set_label asm exit_lbl)
    ))

(fun exit_if_true (asm mod expr exit) (
    (var hd (node_head expr))
    (var size (node_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_false asm mod (node_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (exit_if_true asm mod (node_arg expr 0) exit)
        (exit_if_true asm mod (node_arg expr 1) exit)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_false asm mod (node_arg expr 0) fail)
        (exit_if_true asm mod (node_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (compile asm mod expr)
    (put_if_true asm exit)
    ))

(fun exit_if_false (asm mod expr exit) (
    (var hd (node_head expr))
    (var size (node_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_true asm mod (node_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_true asm mod (node_arg expr 0) fail)
        (exit_if_false asm mod (node_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (exit_if_false asm mod (node_arg expr 0) exit)
        (exit_if_false asm mod (node_arg expr 1) exit)
        return
        ))
    (compile asm mod expr)
    (put_if_false asm exit)
    ))

; translate
;
;   While{cnd, body}
;
; to
;
;   if (not c) goto exit
; head:
;   body
;   if (c) goto head
; exit:
;
(fun compile_while (asm mod expr) (
    (var cnd (node_arg expr 0))
    (var body (node_arg expr 1))
    (var exit_lbl (fresh_label asm))
    (var head_lbl (fresh_label asm))

    (= break_labels (cons (box exit_lbl) break_labels))
    (= continue_labels (cons (box head_lbl) continue_labels))

    (compile asm mod cnd)

    (put_if_false asm exit_lbl)
    (set_label asm head_lbl)
    
    (compile asm mod body)
    (put_drop asm)
    (compile asm mod cnd)
    (put_if_true asm head_lbl)
    (set_label asm exit_lbl)
    (put_nil asm)

    (= break_labels (cdr break_labels))
    (= continue_labels (cdr continue_labels))
    ))

; translate for i in ary body to
;
; {
;     iter: ary.each
;     i: iter()
;     while (i != undefined) {
;         body
;         i = iter()
;     }
; }

(fun compile_for (asm mod expr) (
    (var i (node_arg expr 0))
    (var ary (node_arg expr 1))
    (var body (node_arg expr 2))
    (var iter (unique_sym))
    (compile asm mod
        (block (list3
            (defvar iter (apply (to_sym "each") (list1 ary)))
            (defvar i (apply iter 0))
            (make_node2 While
                (make_node1 Not (apply (to_sym "equal") (list2 i @C_UNDEF)))
                (seq (list2
                    body
                    (assign i (apply iter 0))
                    )))
            )))
    ))

(fun compile_revfor (asm mod expr) (
    (var i (node_arg expr 0))
    (var ary (node_arg expr 1))
    (var body (node_arg expr 2))
    (var iter (unique_sym))
    (compile asm mod
        (block (list3
            (defvar iter (apply (to_sym "reverse_each") (list1 ary)))
            (defvar i (apply iter 0))
            (make_node2 While
                (make_node1 Not (apply (to_sym "equal") (list2 i @C_UNDEF)))
                (seq (list2
                    body
                    (assign i (apply iter 0))
                    )))
            )))
    ))

; translate for i in a..b body to
;
; i: {
;     i: a
;     tmp: b
;     while (i <= tmp) {
;         body
;         i += 1
;     }
;     i
; }

(fun compile_range_for (asm mod expr) (
    (var i (node_arg expr 0))
    (var rng (node_arg expr 1))
    (var a (node_arg rng 0))
    (var b (node_arg rng 1))
    (var body (node_arg expr 2))
    (var tmp (unique_sym))

    (compile asm mod 
        (block (list3
            (defvar i a)
            (defvar tmp b)
            (make_node2 While
                (apply (to_sym "le") (list2 i tmp))
                (seq (list2
                    body
                    (assign i (apply (to_sym "add") (list2 i (box 1)))))))
            )))
    ))

; translate revfor i in a..b body to
;
; i: {
;     i: b
;     tmp: a
;     while (i >= tmp) {
;         body
;         i -= 1
;     }
;     i
; }

(fun compile_range_revfor (asm mod expr) (
    (var i (node_arg expr 0))
    (var rng (node_arg expr 1))
    (var a (node_arg rng 0))
    (var b (node_arg rng 1))
    (var body (node_arg expr 2))
    (var tmp (unique_sym))

    (compile asm mod
        (block (list3
            (defvar i b)
            (defvar tmp a)
            (make_node2 While
                (apply (to_sym "ge") (list2 i tmp))
                (seq (list2
                    body
                    (assign i (apply (to_sym "sub") (list2 i (box 1)))))))
            )))
    ))

(fun compile_break (asm mod expr) (
    (if (! break_labels)
        (throw (exception current_loc (string "`break' statement outside loop")))
        )
    (put_goto asm (unbox (car break_labels)))
    ))

(fun compile_continue (asm mod expr) (
    (if (! continue_labels)
        (throw (exception current_loc (string "`continue' statement outside loop")))
        )
    (put_goto asm (unbox (car continue_labels)))
    ))

(fun compile_assign (asm mod expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))
    (if (&& (! (is_symbol lhs)) (!= (node_head lhs) Qualified))
        (return (compile_multi_assign asm mod lhs rhs))
        )

    (compile asm mod rhs)
    (put_dup asm)
    (var v (lookup_symbol mod lhs))
    (if (! v)
        (throw (undefined_var current_loc lhs))
        )
    (var vty (node_head v))
    (if (== vty ModuleVariable) (do
        (put_push asm v)
        (put_field_get1 asm)
        (put_field_set0 asm)
        return
        )
    (if (== vty LocalVariable) (do
        (put_store_lvar asm (node_arg_int v 0))
        return
        )
    (if (== vty Argument) (do
        (put_store_arg asm (node_arg_int v 0))
        return
        ))))
    (throw (bug (string "compile_assign")))
    ))

; translate
;
; Foo{x, y, Bar{z}} = e
;
; to
;
; tmp: (t@Foo{x, y, Bar{z}} -> [x,y,z,t])(e)
; x = decons(tmp)
; y = decons(tmp)
; z = decons(tmp)
; car(tmp)
(fun compile_multi_assign (asm mod lhs rhs) (
    (var vars (collect_args lhs))
    (var t (unique_sym))
    (compile asm mod (apply (lambda
        (list1 (make_node2 Domain t lhs))
        (list_append vars (list1 t))) (list1 rhs)))

    (while vars (do
        (compile_assign asm mod (assign (car vars) Decons))
        (put_drop asm)
        (= vars (cdr vars))
        ))
    (put_car asm)
    ))

(fun compile_return (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (put_ireturn asm)
    ))

; handler must be a lambda
(var default_hdler (lambda (to_sym "x") (make_node1 Throw (to_sym "x"))))
(fun compile_try (asm mod expr) (
    (var stmt (node_arg expr 0))
    (var hdlr (node_arg expr 1))
    (var hdlr_lbl (fresh_label asm))
    (var cont_lbl (fresh_label asm)) 

    (put_unwind_push asm hdlr_lbl)
    (compile asm mod stmt)
    (put_drop asm)

    (put_unwind_pop asm)
    (put_goto asm cont_lbl)
    (set_label asm hdlr_lbl)

    ; here, the thrown exception is on the top of stack.
    (compile asm mod (make_node2 Bind hdlr default_hdler))
    (put_push asm hdlr)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm 4)
    (set_label asm cont_lbl)
    ))

(fun compile_throw (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (put_throw asm)
    ))

(fun compile_eq (asm mod expr) (
    (compile asm mod (make_node2 Apply (to_sym "equal") (node_args expr)))
    ))

(fun compile_ne (asm mod expr) (
    (compile_eq asm mod expr)
    (var else_lbl (fresh_label asm))
    (var exit_lbl (fresh_label asm))
    (put_if_false asm else_lbl)
    (put_false asm)
    (put_goto asm exit_lbl)
    (set_label asm else_lbl)
    (put_true asm)
    (set_label asm exit_lbl)
    ))

(fun compile_logical (asm mod expr) (
	(compile asm mod (ifelse expr @C_TRUE @C_FALSE))
	))

(fun compile_lambda_main (asm mod args body guard cls) (
    (var asm_body (make_assembler))
    (if (!= guard noguard)
        (do
            (var asm_guard (make_assembler))
            (compile_function asm_body asm_guard mod args body guard cls)
            (put_ireturn asm_body)
            (put_push asm (make_function args (get_code asm_body) (get_code asm_guard)))
        )
        (do
            (compile_function asm_body 0 mod args body noguard cls)
            (put_ireturn asm_body)
            (put_push asm (make_function args (get_code asm_body) 0))
        ))
    ))

(fun compile_lambda_ (asm mod expr cls) (
    (var lhs (node_arg expr 0))
    (var body (node_arg expr 1))
    (var hd (node_head lhs))
    (if (== hd List)
        (compile_lambda_main asm mod lhs body noguard cls)
    (if (== hd Where)
        (do
            (var guard (node_arg lhs 1))
            (var args (node_arg lhs 0))
            (= hd (node_head lhs))
            (compile_lambda_main asm mod args body guard cls)
        )
        (compile_lambda_main asm mod (list1 lhs) body noguard cls)
        ))
    ))

(fun compile_lambda (asm mod expr) (
    (return (compile_lambda_ asm mod expr @C_NIL))
    ))

(fun compile_bind (asm mod expr) (
    (compile asm mod (node_arg expr 1))
    (compile asm mod (node_arg expr 0))
    (compile_simple_call asm 2 make_bound)
    ))

(fun build_closure (lam clos) (
    (var args (field_get lam 2))
    (var body (field_get lam 3))
    (var guard (field_get lam 4))
    (var copy (field_get lam 5))
    (var asm (make_assembler))
    (put_push asm clos)
    (put_store_closure asm)
    (put_push asm body)
    (put_jjump asm)
    (return (alloc_function args (get_code asm) guard copy))
    ))

(fun compile_closure (asm mod expr) (
    (compile asm mod (node_arg expr 0))

    (var save_closure_frame closure_frame)
    (= closure_frame (node_arg expr 0))

    (compile_lambda_ asm mod (node_arg expr 1) (node_arg expr 0))
    (compile_simple_call asm 2 build_closure)

    (= closure_frame save_closure_frame)
    ))

(fun compile_alloc_clsenv (asm mod expr) (
    (var size (node_arg_int expr 0))
    (var t size)
    (while (> t 0) (do
        (put_zero asm)
        (-= t 1)
        ))
    (put_struct asm size size)
    ))

(fun compile_clsref (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (put_fieldget asm (node_arg_int expr 1))
    ))

(fun compile_clsref_assign (asm mod expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))
    (compile asm mod rhs)
    (put_dup asm)
    (compile asm mod (node_arg lhs 0))
    (put_fieldset asm (node_arg_int lhs 1))
    ))

(fun compile_fieldref (asm mod expr) (
    (compile asm mod (node_arg expr 0))
    (put_fieldget asm (node_arg_int expr 1))
    ))

(fun compile_fieldref_assign (asm mod expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))
    (compile asm mod rhs)
    (put_dup asm)
    (compile asm mod (node_arg lhs 0))
    (put_fieldset asm (node_arg_int lhs 1))
    ))

(export fun compile_simple_function (asm arity func) (
    (var n arity)
    (while (> n 0) (do
        (decr n)
        (put_arg asm n)
        ))
    (compile_simple_call asm arity func)
    (put_ireturn asm)
    ))

(export fun compile_simple_call (asm arity func) (
    (if @(IS_PRIM func)
        (do
            (put_pcall asm @(PRIM_IDX func) (* 4 arity))
        )
        (do
            (put_imm_int32 asm func)
            (put_dcall asm (* 4 arity))
        ))
    ))

(fun append_function (mod sym newfunc) (
    (var info (lookup_symbol_local mod sym))
    (if info
        (do
            (must_be_module_variable sym info)
            (check_init sym info)
            (var box (node_arg info 0))
            (var func (field_get box 0))
            (if (callable func)
                (= newfunc (make_bound newfunc func))
                )
            (field_set box 0 newfunc)
            return
        ))
    (= info (lookup_symbol mod sym))
    (if info
        (do
            (must_be_module_variable sym info)
            (check_init sym info)
            (var box (node_arg info 0))
            (var func (field_get box 0))
            (if (callable func)
                (= newfunc (make_bound newfunc func))
                )
        ))
    (add_module_variable mod sym @C_FALSE newfunc)
    ))

; DefineFunction{sym, fun} is equivalent to:
; sym: fun                   (when `sym' is not defined)
; sym: fun | sym             (when `sym' is defined in outer scope)
; sym: fun | sym (overwrite) (when `sym' is defined in local scope)
(fun compile_define_function (asm mod expr) (
    (var lhs (node_arg expr 0))
    (var sym @C_NIL)
    (if (== (node_head lhs) Ref)
        (= sym (node_arg_symbol lhs 2))
    (if (is_symbol lhs)
        (= sym lhs)
        (throw (type_error current_loc (string "a symbol") lhs))
        ))

    (var fun (node_arg expr 1))
    (var info (lookup_symbol_local mod sym))
    (if (is_defined_locally info)
        (return (compile_define_variable_ asm mod
            (make_node3 DefVariable lhs
                (make_node2 Bind fun lhs) (to_sym "overwrite"))))
        )
    (= info (lookup_effective_symbol mod sym))
    (if info 
        (return (compile_define_variable_ asm mod
            (make_node2 DefVariable lhs (make_node Bind (list2 fun lhs)))))
        (return (compile_define_variable_ asm mod
            (make_node2 DefVariable lhs fun)))
        )
    ))

(export fun add_function0 (mod sym func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func)
    (var code (get_code asm))
    (append_function mod sym (make_function 0 code guard 0))
    ))

(export fun add_function1 (mod sym pat func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list1 pat) code guard 0))
    ))

(export fun add_function2 (mod sym pat1 pat2 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 2 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list2 pat1 pat2) code guard 0))
    ))

(export fun add_function3 (mod sym pat1 pat2 pat3 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 3 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list3 pat1 pat2 pat3) code guard 0))
    ))

(export fun add_function4 (mod sym pat1 pat2 pat3 pat4 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 4 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list4 pat1 pat2 pat3 pat4) code guard 0))
    ))

(export fun add_function5 (mod sym pat1 pat2 pat3 pat4 pat5 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 5 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list5 pat1 pat2 pat3 pat4 pat5) code guard 0))
    ))

(fun compile_ (expr) (
    (return (byterun (compile_main current_mod expr)))
    ))

(export fun setup_builtin_compilers (mod) (
    (var locT (domainP Loc))

    (add_function1 mod Compile DontCare compile_ 0)

    (add_compiler mod DontCare compile_error)

    (add_compiler mod (make_node2 Located locT DontCare) compile_located)

    ; These commands have been evaluated in parsing phase.
    (add_compiler mod (make_node1 Open DontCare) topscope_only)
    (add_compiler mod (make_node1 Import DontCare) topscope_only)

    (add_compiler mod (make_node2 Qualified symT DontCare) compile_qualified)

    (add_compiler mod (make_node2 MakeNode DontCare DontCare) compile_make_node)
    (add_compiler mod (make_node1 Head DontCare) compile_head)
    (add_compiler mod (make_node1 Arguments DontCare) compile_arguments)

    (add_compiler mod (make_node2 DefVariable DontCare DontCare) compile_define_variable)
    (add_compiler mod (make_node3 DefVariable DontCare DontCare (quote (to_sym "overwrite"))) compile_define_variable)

    (add_compiler mod (make_node2 DefFunction DontCare DontCare) compile_define_function)

    (add_compiler mod (domainP Symbol) compile_var)
    (add_compiler mod (make_node1 Dynamic symT) compile_dynamic_var)
    (add_compiler mod (quote @C_TRUE) compile_special)
    (add_compiler mod (quote @C_FALSE) compile_special)
    (add_compiler mod (quote @C_NIL) compile_special)
    (add_compiler mod (quote @C_UNDEF) compile_special)
    (add_compiler mod (domainP Int) compile_const_int)
    (add_compiler mod (domainP String) compile_const)
    (add_compiler mod (domainP BigInt) compile_const)
    (add_compiler mod (domainP Float) compile_const)

    (add_compiler mod (make_node2 Apply DontCare listT) compile_apply)

    (add_compiler mod (qquote (unquote (unquote DontCare))) compile_unquote)
    (add_compiler mod (qquote (quote (unquote DontCare))) compile_quote)
    (add_compiler mod (qquote (qquote (unquote (unquote DontCare)))) compile_qquote)

    (add_compiler mod (domainP List)  compile_list)
    (add_compiler mod (domainP Tuple) compile_tuple)
    (add_compiler mod (domainP Array) compile_array)
    (add_compiler mod (domainP Range) compile_range)

    (add_compiler mod (make_node1 Block listT) compile_block)
    (add_compiler mod (make_node1 Seq listT) compile_seq)
    (add_compiler mod (make_node2 Scoped (domainP Module) DontCare)
        compile_scoped)
    (add_compiler mod (make_node1 Breakable listT) compile_breakable)

    (add_compiler mod (mkif DontCare DontCare) compile_if)
	(add_compiler mod (ifelse DontCare DontCare DontCare) compile_ifelse)
    (add_compiler mod (make_node2 While DontCare DontCare) compile_while)

    (add_compiler mod (make_node3 For DontCare DontCare DontCare)
        compile_for
        )
    (add_compiler mod (make_node3 RevFor DontCare DontCare DontCare)
        compile_revfor
        )
    (add_compiler mod (make_node3 For DontCare
        (make_node2 Range DontCare DontCare) DontCare)
        compile_range_for)
    (add_compiler mod (make_node3 RevFor DontCare
        (make_node2 Range DontCare DontCare) DontCare)
        compile_range_revfor)

    (add_compiler mod (make_node0 Break) compile_break) 
    (add_compiler mod (make_node0 Continue) compile_continue)
    (add_compiler mod (make_node1 Return DontCare) compile_return)
    (add_compiler mod (make_node2 Try DontCare DontCare) compile_try)
    (add_compiler mod (make_node1 Throw DontCare) compile_throw)

    (add_compiler mod (make_node2 Equal DontCare DontCare) compile_eq)
    (add_compiler mod (make_node2 NotEqual DontCare DontCare) compile_ne)
    (add_compiler mod (make_node1 Not DontCare) compile_logical)
	(add_compiler mod (make_node2 SeqAnd DontCare DontCare) compile_logical)
	(add_compiler mod (make_node2 SeqOr DontCare DontCare) compile_logical)

    (add_compiler mod (make_node2 Assign DontCare DontCare) compile_assign)
    (add_compiler mod (make_node2 Lambda DontCare DontCare) compile_lambda)
    (add_compiler mod (make_node2 Bind DontCare DontCare) compile_bind)


    ; internal expressions
    (add_compiler mod (make_node2 FieldRef DontCare intT) compile_fieldref)
    (add_compiler mod (make_node2 Assign (make_node2 FieldRef DontCare intT) DontCare) compile_fieldref_assign)

    (add_compiler mod (make_node1 AllocClsEnv intT) compile_alloc_clsenv)
    (add_compiler mod (make_node2 Closure DontCare DontCare) compile_closure)
    (add_compiler mod (make_node3 Ref DontCare intT symT) compile_clsref)
    (add_compiler mod (make_node2 Assign
        (make_node3 Ref DontCare intT symT) DontCare) compile_clsref_assign)
    (add_compiler mod (make_node2 ExprAt DontCare intT) compile_exprat)
    (add_compiler mod (quote Decons) compile_decons)
    ))

(export fun add_compiler (mod pat func) (
    (add_function3 mod Compile (domainP Assembler) (domainP Module) pat func 0)
    ))

    ))
