;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-compile.rlc 2012-07-07 22:15:33 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-symtable")
(import "rowl1-module")
(import "rowl1-assemble")
(import "rowl1-error")

(var BuildClosure  (to_sym "%BuildClosure"))
(var Closure       (to_sym "%Closure"))
(var Field         (to_sym "%Field"))
(var uninitialized (to_sym "%uninitialized"))
(var noguard       (to_sym "%noguard"))

; compilers

(extern object current_loc)
(extern object current_mod)
(extern fun set_loc)

(var compiling_closure null)

(fun trace_func (msg val) (
    (debugs msg)
    (debugpf val)
    (return val)
    ))

(fun trace (asm msg) (
    (put_push asm (string msg))
    (compile_simple_call asm 2 trace_func)
    ))

(fun must_be_module_variable (sym val) (
    (if (!= (expr_head val) ModuleVariable) (do
        (output_error stderr current_loc)
        (output_char stderr '`')
        (output_symbol stderr sym)
        (output_string stderr "' must be a module variable\n")
        (exit 1)
        ))
    ))

(fun is_identifier (expr) (
    (var hd (expr_head expr))
    (if (== hd Symbol) (return @TRUE))
    (if (&& (== hd Qualified) (== (expr_size expr) 2)) (do
        (if (!= (expr_head (expr_arg expr 0)) Symbol) (return @FALSE))
        (return (is_identifier (expr_arg expr 1)))
        ))
    (return @FALSE)
    ))

(export fun callable (expr) (
    (var hd (expr_head expr))
    (if (== hd Function)
        (return @TRUE)
        )
    (return @FALSE)
    ))

(fun iter_args (f expr arg level) (
    (var hd (expr_head expr))
    (if (== hd Symbol) (do
        (if (== level 0) (return (f expr arg)))
        (return arg)
        ))
    (if (is_atom expr) (return arg))
    (if (== hd Quote) (return arg))
    (if (== hd QuasiQuote) (+= level 1))
    (if (== hd Unquote) (-= level 1))
    (var args (expr_args expr))
    (while args (do
        (= arg (iter_args f (car args) arg level))
        (= args (cdr args))
        ))
    (return arg)
    ))

(fun delete_var (sym fv) (
    (return (list_delete sym fv))
    ))

(fun delete_args (expr fv) (
    (return (iter_args delete_var expr fv 0))
    ))

(fun add_var (sym tbl) (
    (symtable_add tbl sym sym)
    (return tbl)
    ))

(fun collect_args (tbl expr) (
    (iter_args add_var expr tbl 0)
    ))

(fun fv_iter_block (mod env exprs fv) (
    (if (! exprs) (return fv))
    (= fv (fv_iter_block mod env (cdr exprs) fv))
    (return (fv_iter mod env (car exprs) 0 fv))
    ))

(fun fv_iter (mod env expr level fv) (
    (var hd (expr_head expr))
    (if (== hd Symbol) (do
        (if (== level 0) (do
            (= fv (list_delete expr fv))
            (var info (symtable_find env expr))
            (if (! info) (return fv))
            (return (cons expr fv))
            ))
        (return fv)
        ))
    (if (is_atom expr) (return fv))
    (if (== level 0) (do
        (if (== hd DefineVariable) (do
            (= fv (fv_iter mod env (expr_arg expr 1) 0 fv))
            (return (list_delete (expr_arg_symbol expr 0) fv))
            ))
        (if (== hd Lambda) (do
            (= fv (fv_iter mod env (expr_arg expr 1) 0 fv))
            (return (delete_args (expr_arg expr 0) fv))
            ))
        (if (== hd Block) 
            (return (fv_iter_block mod env (expr_args expr) 0 fv))
            )
        ))
    (if (== hd Quote) (return fv))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1)))
    (var args (expr_args expr))
    (while args (do
        (= fv (fv_iter mod env (car args) level fv))
        (= args (cdr args))
        ))
    (return fv)
    ))

(fun free_variables (mod env expr) (
    (return (fv_iter mod env expr 0 0))
    ))

(fun alloc_function (args code guard) (
    (return (variant @FunctionE 4 0 args code guard))
    ))

(fun make_function (args code guard) (
    (var arity (list_len args))
    (= args (cons (box arity) args))
    (return (alloc_function args code guard))
    ))

(fun make_bound (fun1 fun2) (
    (if (! (callable fun1))
        (throw (type_error current_loc (string "function") fun1))
        )
    (if (! (callable fun2))
        (throw (type_error current_loc (string "function") fun2))
        )
    (return (variant @BoundFunctionE 3 0 fun1 fun2))
    ))

; closure conversion
(fun close (mod env expr) (
    (var hd (expr_head expr))
    (if (== hd Symbol) (do
        (var subst (symtable_find env expr)) 
        (if subst
            (return subst)
            (return expr)
            )
        ))
    (if (is_atom expr) (return expr))
    (if (== hd Located) (do
        (expr_arg_set expr 1 (close mod env (expr_arg expr 1)))
        (return expr)
        ))
    (if (== hd DefineVariable) (do
        (var sym (expr_arg_symbol expr 0))
        (symtable_add env sym sym)
        (expr_arg_set expr 1 (close mod env (expr_arg expr 1)))
        (return expr)
        ))
    (if (== hd Block) (do
        (symtable_push env)
        ; XXX: not correct
        (var exprs (expr_args expr))
        (while exprs (do
            (setcar exprs (close mod env (car exprs)))
            (= exprs (cdr exprs))
            ))
        (return expr)
        (symtable_pop env)
        ))
    (if (== hd Lambda) (do
        (var closed (close_function mod env expr))
        (if (! closed) (return expr))
        (return (close mod env closed))
        ))
    (if (== hd BuildClosure) (do
        (expr_arg_set expr 1 (close mod env (expr_arg expr 1)))
        (return expr)
        ))
    (if (== hd Quote)
        (return expr)
        )
    (if (== hd QuasiQuote) (do
        (expr_arg_set expr 0 (close_qquote mod env (expr_arg expr 0) 0))
        (return expr)
        ))
    (if (== hd Dynamic)
        (return expr)
        )
    (var args (expr_args expr))
    (while args (do
        (setcar args (close mod env (car args)))
        (= args (cdr args))
        ))
    (return expr)
    ))

(fun close_qquote (mod env expr level) (
    (if (is_atom expr) (return expr))
    (var hd (expr_head expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (expr_arg_set expr 0 (close mod env (expr_arg expr 0)))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote) 
        (+= level 1)
        ))
    (var args (expr_args expr))
    (while args (do
        (setcar args (close_qquote mod env (car args) level))
        (= args (cdr args))
        ))
    (return expr)
    ))

(fun close_function (mod env lam) (
    ; XXX: implementation is not completed
    (var fv (free_variables mod env lam))
    (if (! fv) (return 0))
    (var tbl (make_closure_env Closure fv))
    (collect_args tbl (expr_args (expr_arg lam 0)))
    (expr_arg_set lam 1 (close mod tbl (expr_arg lam 1)))
    (return (make_expr BuildClosure (list2 lam fv)))
    ))

(fun make_closure_env (clos fv) (
    (var tbl (make_symtable 10))
    (var i 0)
    (while fv (do
        (symtable_add tbl (car fv) (make_expr Field (list2 clos (box i))))
        (+= i 1)
        (= fv (cdr fv))
        ))
    (return tbl)
    ))

(extern fun compile_matching)
(export fun lookup_func (mod sym) (
    (var def (lookup_symbol mod sym))
    (if (! def) 
        (throw (undefined_fun current_loc sym))
        )
    (must_be_module_variable sym def)
    (check_if_initialized sym def)
    (var box (expr_arg def 0))
    (var func (field_get box 0))
    (if (! (callable func))
        (throw (type_error current_loc (string "function") sym))
        )
    (var loc (field_get box 1))
    (return (compile_matching loc sym func))
    ))

(export fun get_bytecode (obj func) (
    (return (compile_matching current_loc obj func))
    ))

(export fun compile (asm mod expr) (
    (var code (lookup_func mod Compile))
    (byterun code asm mod expr)
    ))

(export fun call1 (sym arg0) (
    (var code (lookup_func current_mod sym))
    (return (byterun code arg0))
    ))

(export fun call2 (sym arg0 arg1) (
    (var code (lookup_func current_mod sym))
    (return (byterun code arg0 arg1))
    ))

(export fun call3 (sym arg0 arg1 arg2) (
    (var code (lookup_func current_mod sym))
    (return (byterun code arg0 arg1 arg2))
    ))

(fun do_nothing (asm mod expr) (
    (put_push asm nil)
    ))

(fun check_arg_size (name size expr) (
    (if (!= (expr_size expr) size)
        (throw (type_error current_loc
            (strcat "expression with "
            (strcat (itos size) " arguments"))
            expr
            ))
        )
    ))

(fun compile_error (asm mod expr) (
    (throw (unknown_expression current_loc expr))
    ))

(fun compile_located (asm mod expr) (
    (set_loc (expr_arg expr 0))
    (compile asm mod (expr_arg expr 1))
    ))

(fun compile_const (asm mod expr) (
    (put_push asm expr)
    ))

(fun compile_qualified (asm mod expr) (
    (var modsig (expr_arg expr 0))
    (var module (find_module current_loc mod modsig @FALSE))
    (compile asm module (expr_arg expr 1))
    ))

(fun compile_make_expr (asm mod expr) (
    (compile asm mod (expr_arg expr 1))
    (compile asm mod (expr_arg expr 0))
    (compile_simple_call asm 2 make_expr_user)
    ))

(fun compile_head (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (compile_simple_call asm 1 expr_head)
    ))

(fun compile_arguments (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (compile_simple_call asm 1 expr_args)
    ))

(fun compile_subscript (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (put_field_get2 asm)
    (compile asm mod (expr_arg expr 1))
    (put_imm_i1 asm)
    (put_sar asm)
    (put_list_at asm)
    ))

(var max_lvar_idx 0)
(fun compile_function (asm_body asm_guard mod args body guard) (
    (push_varscope mod)
    (setup_args (get_vartable mod) args)

    (if (!= guard noguard)
        (compile asm_guard mod guard)
        )

    (var cnt_addr (get_address asm_body))
    (put_allocate asm_body 0)

    ; closure conversion
    (var vtbl (make_symtable 10))
    (collect_args vtbl args)
    (= body (close mod vtbl body))

    (var save_max_lvar_idx max_lvar_idx)
    (= max_lvar_idx 0)
    (reset_variable_count mod)

    (compile asm_body mod body)
    (put_ireturn asm_body)
    (if compiling_closure
        (put_operand_byte asm_body (+ cnt_addr 1) (+ max_lvar_idx 2))
        (put_operand_byte asm_body (+ cnt_addr 1) (+ max_lvar_idx 1))
        )

    (pop_varscope mod)

    (= max_lvar_idx save_max_lvar_idx)
    ))

(fun setup_args (tbl args) (
    (var orig args)
    (var idx 0)
    (while args (do
        (setup_arg tbl (make_arg idx) (car args) 0)
        (= args (cdr args))
        (+= idx 1)
        ))
    (return orig)
    ))

(fun setup_arg (tbl obj arg level) (
    (var argty (expr_head arg))
    (if (|| (== argty Int) (== argty String))
        return
        )
    (if (== argty Symbol) (do
        (if (== level 0) (symtable_add tbl arg obj))
        return
        ))
    (if (== argty Domain) (do
        (if (== level 0) (do
            (var head (expr_arg_symbol arg 1))
            (var v (expr_arg_symbol arg 0))
            (symtable_add tbl v obj)
            return
            ))
        ))
    (if (== argty List) (do
        (var idx 0)
        (while arg (do
            (var a (car arg))
            (if (== (expr_head a) Ellipsis) (do
                (if (cdr arg)
                    (throw (exception current_loc (string "Ellipsis node must be placed last in the order of arguments")))
                    )
                (if (> (expr_size a) 0) (do
                    (var v (expr_arg_symbol a 0))
                    (symtable_add tbl v (make_list_from obj idx))
                    ))
                return
                ))
            (setup_arg tbl (make_list_at obj idx) a level)
            (= arg (cdr arg))
            (incr idx)
            ))
        return
        ))
    (if (== argty Quote)
        return
        )
    (if (== argty Unquote) 
        (return (setup_arg tbl obj (expr_arg arg 0) (- level 1)))
        )
    (if (== argty QuasiQuote)
        (return (setup_arg tbl obj (expr_arg arg 0) (+ level 1)))
        )
    (if (== argty Ellipsis)
        (throw (exception current_loc (string "Variable-length arguments is not allowed")))
        )
    (var idx 0)
    (var args (expr_args arg))
    (while args (do
        (var a (car args))
        (if (== (expr_head a) Ellipsis) (do
            (if (cdr args)
                (throw (exception current_loc (string "Ellipsis node must be placed last in the order of arguments")))
                )
            (if (> (expr_size a) 0) (do
                (var v (expr_arg_symbol a 0))
                (symtable_add tbl v (make_expr_from obj idx))
                ))
            return
            ))
        (setup_arg tbl (make_expr_at obj idx) (car args) level)
        (= args (cdr args))
        (incr idx)
        ))
    ))

(fun var_loc (info) (
    (var hd (expr_head info))
    (if (|| (== hd ListAt) (|| (== hd ListFrom) (|| (== hd ExprAt) (== hd ExprFrom))))
        (return (var_loc (expr_arg info 0)))
        )
    (if (== hd ModuleVariable) (do
        (var box (expr_arg info 0))
        (if (! box)
            (return no_loc)
            (return (field_get box 1))
            )
        ))
    (return (expr_arg info 1))
    ))

(fun make_lvar (idx) (
    (return (make_expr LocalVariable (list2 (box idx) current_loc)))
    ))

(fun make_label (lbl) (
    (return (make_expr Label (list2 (box lbl) current_loc)))
    ))

(export fun get_arity () (
    (return (make_expr Arity 0))
    ))

(export fun make_arg (idx) (
    (return (make_expr Argument (list2 (box idx) current_loc)))
    ))

(export fun make_list_at (obj idx) (
    (return (make_expr ListAt (list2 obj (box idx))))
    ))

(export fun make_list_from (obj idx) (
    (return (make_expr ListFrom (list2 obj (box idx))))
    ))

(export fun make_expr_at (obj idx) (
    (return (make_expr ExprAt (list2 obj (box idx))))
    ))

(export fun make_expr_from (obj idx) (
    (return (make_expr ExprFrom (list2 obj (box idx))))
    ))

(fun compile_define_variable (asm mod expr) (
    (var overwrite false)
    (if (&& (== (expr_size expr) 3)
            (== (expr_arg expr 2) (to_sym "overwrite")))
        (= overwrite true)
        )
    (var size (expr_size expr))
    (var sym (expr_arg_symbol expr 0))

    (var val (expr_arg expr 1))
    (var tbl (get_vartable mod))
    (if (== overwrite false) (check_redefinition mod sym))

    (if (in_top_scope mod)
        (do
            (put_push asm overwrite)
            (compile asm mod val)
            (put_push asm sym)
            (put_push asm mod)
            (compile_simple_call asm 4 add_module_variable)
        )
        (do
            (var idx (get_variable_count mod))
            (if (> idx max_lvar_idx) (= max_lvar_idx idx))
            (incr_variable_count mod)

            (compile asm mod val)
            (if compiling_closure
                (put_store_lvar asm (+ idx 1))
                (put_store_lvar asm idx)
                )
            (add_symbol mod sym (make_lvar idx))
        ))
    ))

(fun check_redefinition (mod sym) (
    (var info (lookup_symbol_local mod sym))
    (if (! info) return)
    (if (== (expr_head info) ModuleVariable) (do
        (if (|| (== (expr_arg info 1) false) (== (expr_arg info 2) true))
            return
            )
        ))
    (throw (redefined_var current_loc (var_loc info) sym))
    ))

(fun check_if_initialized (sym info) (
    (var box (expr_arg info 0))
    (if (! box) (do
        (var loc (expr_arg info 1))
        (throw (uninitialized_var loc sym))
        ))
    ))

(export fun compile_operand (asm opd sym) (
    (var ty (expr_head opd))
    (if (== ty ModuleVariable) (do
        (var lbl (fresh_label asm))
        (put_push asm (expr_args opd)) ; variable-display
        (put_car asm)
        (put_car asm)

        ; check if initialized
        (put_dup asm)
        (put_push asm uninitialized)
        (put_if_ne asm lbl)
        (put_push asm sym)
        (put_push asm current_loc)
        (compile_simple_call asm 2 uninitialized_var)
        (put_throw asm)
        (set_label asm lbl)
        return
        ))
    (if (== ty LocalVariable) (do
        (if compiling_closure
            (put_load_lvar asm (+ (expr_arg_int opd 0) 1))
            (put_load_lvar asm (expr_arg_int opd 0))
            )
        return
        ))
    (if (== ty Arity) (do
        (put_arity asm)
        (put_imm_i1 asm)
        (put_shl asm)
        (put_iadd1 asm)
        return
        ))
    (if (== ty Argument) (do
        (put_arg asm (expr_arg_int opd 0))
        return
        ))
    (if (== ty ListAt) (do
        (compile_operand asm (expr_arg opd 0) sym)
        (put_imm_int asm (expr_arg_int opd 1))
        (put_list_at asm)
        return
        ))
    (if (== ty ListFrom) (do
        (compile_operand asm (expr_arg opd 0) sym)
        (put_imm_int asm (expr_arg_int opd 1))
        (put_list_from asm)
        return
        ))
    (if (== ty ExprAt) (do
        (compile_operand asm (expr_arg opd 0) sym)
        (put_field_get2 asm)
        (put_imm_int asm (expr_arg_int opd 1))
        (put_list_at asm)
        return
        ))
    (if (== ty ExprAt) (do
        (compile_operand asm (expr_arg opd 0) sym)
        (put_field_get2 asm)
        (put_imm_int asm (expr_arg_int opd 1))
        (put_list_from asm)
        return
        ))
    (not_reachable "compile_operand")
    ))

(fun compile_var (asm mod sym) (
    (if (== sym Closure) (do
        ; closure is always placed to 1st local variable position.
        (put_load_lvar asm 0)
        return
        ))

    (var v (lookup_symbol mod sym))
    (if (! v)
        ; `sym' is a module variable
        (= v (add_module_variable_display mod sym (struct 2 uninitialized no_loc)))
    (if (== (expr_head v) ModuleVariable) (do
        (var u (lookup_symbol_current_module mod sym))
        (if (! u)
            (= v (add_module_variable_display mod sym (expr_arg v 0)))
            )
        )))
    (compile_operand asm v sym)
    ))

(fun lookup_dynamic_var (sym) (
    (var info (lookup_effective_symbol current_mod sym))
    (must_be_module_variable sym info)
    (var box (expr_arg info 0))
    (return (field_get box 0))
    ))

(fun compile_dynamic_var (asm mod expr) (
    (var sym (expr_arg_symbol expr 0))
    (put_push asm sym)
    (compile_simple_call asm 1 lookup_dynamic_var)
    ))

(fun compile_apply (asm mod expr) (
    (var func (expr_arg expr 0))
    (var args (expr_arg expr 1))
    
    ; eval and push arguments from right to left
    (= args (list_reverse args))
    (var arity 0)
    (while args (do
        (compile asm mod (car args))
        (= args (cdr args))
        (incr arity)
        ))

    (compile asm mod func)
    (put_push asm func)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity))
    ))

(fun compile_quote (asm mod expr) (
    (put_push asm (expr_arg expr 0))
    ))

(export fun compile_qquote_main (asm mod expr level) (
    (var hd (expr_head expr))
    (if (== hd Symbol)
        (return (put_push asm expr)))
    (if (== hd Int)
        (return (put_imm_int asm expr)))
    (if (== hd String)
        (return (put_push asm expr)))
    (if (== hd List) (do
        (if (! expr)
            (put_push asm 0)
            (do
                (compile_qquote_main asm mod (cdr expr) level)
                (compile_qquote_main asm mod (car expr) level)
                (put_cons asm)
            )
        )
        return
        ))
    (if (== hd Unquote)
        (if (== level 0)
            (return (compile asm mod (expr_arg expr 0)))
            (return (compile_qquote_main asm mod (expr_arg expr 0) (- level 1))) 
            )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))
    (compile_qquote_main asm mod (expr_args expr) level)
    (put_push asm (expr_head expr))
    (compile_simple_call asm 2 make_expr_user)
    ))

(fun compile_qquote (asm mod expr) (
    (compile_qquote_main asm mod (expr_arg expr 0) 0)
    ))

(fun compile_int (asm mod val) (
    (put_imm_int asm val)
    ))

(fun compile_string (asm mod val) (
    (put_push asm val)
    ))

(fun compile_list (asm mod expr) (
    (if (== expr 0)
        (put_zero asm)
        (do
            (compile asm mod (cdr expr))
            (compile asm mod (car expr))
            (put_cons asm)
        ))
    ))

(fun compile_tuple (asm mod expr) (
    (compile_list asm mod (expr_args expr))
    (put_push asm Tuple)
    (compile_simple_call asm 2 make_expr_user)
    ))

(fun compile_block_body (asm mod exprs) (
    (if (! exprs) (do
        (put_push asm nil)
        return
        ))
    (while exprs (do
        (compile asm mod (car exprs))
        (= exprs (cdr exprs))
        (if exprs (put_drop asm)) ; drop values except the last one
        ))
    ))

(fun compile_block (asm mod expr) (
    (var exprs (expr_args expr))
    (push_varscope mod)
    (if (in_top_scope mod)
        (do
            (var save_max_lvar_idx max_lvar_idx)
            (= max_lvar_idx 0)
            (reset_variable_count mod)

            (var cnt_addr (get_address asm))
            (put_allocate asm 0)
            (compile_block_body asm mod exprs)
            (put_operand_byte asm (+ cnt_addr 1) (+ max_lvar_idx 1))

            (= max_lvar_idx save_max_lvar_idx)
        )
        (do
            (compile_block_body asm mod exprs)
        ))
    (pop_varscope mod)
    ))

(fun compile_openblock (asm mod expr) (
    (var exprs (expr_args expr))
    (if (in_top_scope mod)
        (do
            (var save_max_lvar_idx max_lvar_idx)
            (= max_lvar_idx 0)
            (reset_variable_count mod)

            (var cnt_addr (get_address asm))
            (put_allocate asm 0)
            (compile_block_body asm mod exprs)
            (put_operand_byte asm (+ cnt_addr 1) (+ max_lvar_idx 1))

            (= max_lvar_idx save_max_lvar_idx)
        )
        (do
            (compile_block_body asm mod exprs)
        ))
    ))

(fun compile_scoped (asm mod expr) (
    (compile asm (expr_arg expr 0) (expr_arg expr 1))
    ))

(fun compile_seq (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (put_drop asm)
    (compile asm mod (expr_arg expr 1))
    ))

(fun put_if_true (asm lbl) (
    (put_push asm true)
    (put_if_eq asm lbl)
    ))

(fun put_if_false (asm lbl) (
    (put_push asm false)
    (put_if_eq asm lbl)
    ))

(fun compile_if (asm mod expr) (
    (compile_ifelse_main asm mod (expr_arg expr 0) (expr_arg expr 1) nil)
    ))

(fun compile_ifelse (asm mod expr) (
    (compile_ifelse_main asm mod (expr_arg expr 0) (expr_arg expr 1) (expr_arg expr 2))
    ))

(fun compile_ifelse_main (asm mod cnd ifthen ifelse) (
    (var cnd_hd (expr_head cnd))
    (var size (expr_size cnd))
    (if (&& (== cnd_hd Not) (== size 1))
        (return (compile_ifelse_main asm mod (expr_arg cnd 0) ifelse ifthen))
        )
    (if (&& (== cnd_hd SeqAnd) (== size 2))
        (return (compile_ifelse_and asm mod cnd ifthen ifelse))
        )
    (if (&& (== cnd_hd SeqOr) (== size 2))
        (return (compile_ifelse_or asm mod cnd ifthen ifelse))
        )
    (if (== ifthen nil)
        (if (== ifelse nil)
            (do
                (compile asm mod cnd)
                (put_push asm nil)
            )
            (do
                (var exit_lbl (fresh_label asm))
                (put_push asm nil)
                (compile asm mod cnd)
                (put_if_true asm exit_lbl)
                (put_drop asm mod)
                (compile asm mod ifelse)
                (set_label asm exit_lbl)
            ))
        (if (== ifelse nil)
            (do
                (var exit_lbl (fresh_label asm))
                (put_push asm nil)
                (compile asm mod cnd)
                (put_if_false asm exit_lbl)
                (put_drop asm mod)
                (compile asm mod ifthen)
                (set_label asm exit_lbl)
            )
            (do
                (var else_lbl (fresh_label asm))
                (var exit_lbl (fresh_label asm))
                (compile asm mod cnd)
                (put_if_false asm else_lbl)
                (compile asm mod ifthen)
                (put_goto asm exit_lbl)
                (set_label asm else_lbl)
                (compile asm mod ifelse)
                (set_label asm exit_lbl)
            ))
        )
    ))

(fun compile_ifelse_and (asm mod cnd ifthen ifelse) (
    (var ifelse_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_false asm mod (expr_arg cnd 0) ifelse_lbl)
    (exit_if_false asm mod (expr_arg cnd 1) ifelse_lbl)
    (compile asm mod ifthen)
    (put_goto asm exit_lbl)
    (set_label asm ifelse_lbl)
    (compile asm mod ifelse)
    (set_label asm exit_lbl)
    ))

(fun compile_ifelse_or (asm mod cnd ifthen ifelse) (
    (var ifthen_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_true asm mod (expr_arg cnd 0) ifthen_lbl)
    (exit_if_true asm mod (expr_arg cnd 1) ifthen_lbl)
    (compile asm mod ifelse)
    (put_goto asm exit_lbl)
    (set_label asm ifthen_lbl)
    (compile asm mod ifthen)
    (set_label asm exit_lbl)
    ))

(fun exit_if_true (asm mod expr exit) (
    (var hd (expr_head expr))
    (var size (expr_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_false asm mod (expr_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (exit_if_true asm mod (expr_arg expr 0) exit)
        (exit_if_true asm mod (expr_arg expr 1) exit)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_false asm mod (expr_arg expr 0) fail)
        (exit_if_true asm mod (expr_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (compile asm mod expr)
    (put_if_true asm exit)
    ))

(fun exit_if_false (asm mod expr exit) (
    (var hd (expr_head expr))
    (var size (expr_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_true asm mod (expr_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_true asm mod (expr_arg expr 0) fail)
        (exit_if_false asm mod (expr_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (exit_if_false asm mod (expr_arg expr 0) exit)
        (exit_if_false asm mod (expr_arg expr 1) exit)
        return
        ))
    (compile asm mod expr)
    (put_if_false asm exit)
    ))

; translate
;
;   While{cnd, body}
;
; to
;
;   if (not c) goto exit
; head:
;   body
;   if (c) goto head
; exit:
;
(fun compile_while (asm mod expr) (
    (var cnd (expr_arg expr 0))
    (var body (expr_arg expr 1))
    (var exit_lbl (fresh_label asm))
    (var head_lbl (fresh_label asm))

    (add_symbol mod BreakLabel (make_label exit_lbl))
    (add_symbol mod ContinueLabel (make_label head_lbl))

    (compile asm mod cnd)
    (put_if_false asm exit_lbl)
    (set_label asm head_lbl)
    (compile asm mod body)
    (put_drop asm)
    (compile asm mod cnd)
    (put_if_true asm head_lbl)
    (set_label asm exit_lbl)
    (put_push asm nil)

    (delete_symbol mod ContinueLabel)
    (delete_symbol mod BreakLabel)
    ))

(fun compile_break (asm mod expr) (
    (var lbl (lookup_symbol mod BreakLabel))
    (if (! lbl)
        (throw (exception current_loc (string "`break' statement outside loop")))
        )
    (if (!= (expr_head lbl) Label)
        (not_reachable "compile_break")
        )
    (put_push asm nil)
    (put_goto asm (expr_arg_int lbl 0))
    ))

(fun compile_continue (asm mod expr) (
    (var lbl (lookup_symbol mod ContinueLabel))
    (if (! lbl)
        (throw (exception current_loc (string "`continue' statement outside loop")))
        )
    (if (!= (expr_head lbl) Label)
        (not_reachable "compile_continue")
        )
    (put_push asm nil)
    (put_goto asm (expr_arg_int lbl 0))
    ))

(fun compile_assign (asm mod expr) (
    (var lhs (expr_arg expr 0))
    (var rhs (expr_arg expr 1))
    (compile asm mod rhs)
    (var v (lookup_symbol mod lhs))
    (if (! v)
        (throw (undefined_var current_loc lhs))
        )
    (var vty (expr_head v))
    (if (== vty ModuleVariable) (do
        (put_push asm (expr_args v))
        (put_car asm)
        (put_setcar asm)
        return
        )
    (if (== vty LocalVariable) (do
        (if compiling_closure
            (put_store_lvar asm (+ (expr_arg_int v 0) 1))
            (put_store_lvar asm (expr_arg_int v 0))
            )
        return
        )
    (if (== vty Argument) (do
        (put_store_arg asm (expr_arg_int v 0))
        return
        ))))
    (output_error stderr current_loc)
    (pretty_print stderr lhs)
    (output_string stderr " is not lvalue\n")
    (exit 1)
    ))

(fun compile_return (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (put_ireturn asm)
    ))

; handler must be a lambda
(var default_hdler (make_expr Lambda (list2 (to_sym "x")
    (make_expr Throw (list1 (to_sym "x"))))))
(fun compile_try (asm mod expr) (
    (var stmt (expr_arg expr 0))
    (var hdlr (expr_arg expr 1))
    (var hdlr_lbl (fresh_label asm))
    (var cont_lbl (fresh_label asm)) 

    (put_unwind_push asm hdlr_lbl)
    (compile asm mod stmt)
    (put_drop asm)

    (put_unwind_pop asm)
    (put_goto asm cont_lbl)
    (set_label asm hdlr_lbl)

    ; here, the thrown exception is on the top of stack.
    (compile asm mod (make_expr Bind (list2 hdlr default_hdler)))
    (put_push asm hdlr)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm 4)
    (put_drop asm)
    (set_label asm cont_lbl)
    (put_push asm nil)
    ))

(fun compile_throw (asm mod expr) (
    (compile asm mod (expr_arg expr 0))
    (put_throw asm)
    ))

(fun compile_eq (asm mod expr) (
    (compile asm mod (make_expr Apply (list2 (to_sym "equal") (expr_args expr))))
    ))

(fun compile_ne (asm mod expr) (
    (compile_eq asm mod expr)
    (var else_lbl (fresh_label asm))
    (var exit_lbl (fresh_label asm))
    (put_if_false asm else_lbl)
    (put_push asm false)
    (put_goto asm exit_lbl)
    (set_label asm else_lbl)
    (put_push asm true)
    (set_label asm exit_lbl)
    ))

(fun compile_logical (asm mod expr) (
	(compile asm mod (ifelse expr true false))
	))

(fun compile_lambda_main (asm mod args body guard) (
    (var asm_body (make_assembler))
    (if (!= guard noguard)
        (do
            (var asm_guard (make_assembler))
            (compile_function asm_body asm_guard mod args body guard)
            (put_push asm (make_function args (get_code asm_body) (get_code asm_guard)))
        )
        (do
            (compile_function asm_body 0 mod args body noguard)
            (put_push asm (make_function args (get_code asm_body) 0))
        ))
    ))

(fun compile_lambda (asm mod expr) (
    (var lhs (expr_arg expr 0))
    (var body (expr_arg expr 1))
    (var hd (expr_head lhs))
    (if (== hd Tuple)
        (compile_lambda_main asm mod (expr_args lhs) body noguard)
    (if (!= hd Where)
        (compile_lambda_main asm mod (list1 lhs) body noguard)
        (do
            (var guard (expr_arg lhs 1))
            (= lhs (expr_arg lhs 0))
            (= hd (expr_head lhs))
            (if (== hd Tuple)
                (compile_lambda_main asm mod (expr_args lhs) body guard)
                (compile_lambda_main asm mod (list1 lhs) body guard)
                )
        )))
    ))

(fun compile_bind (asm mod expr) (
    (compile asm mod (expr_arg expr 1))
    (compile asm mod (expr_arg expr 0))
    (compile_simple_call asm 2 make_bound)
    ))

(fun build_closure (lam clos) (
    (var args (field_get lam 2))
    (= args (cdr args)) ; here, args[0] is the arity.
    (var body (field_get lam 3))
    (var guard (field_get lam 4))
    (var asm (make_assembler))
    (put_push asm clos)
    (put_push asm body)
    (put_jjump asm)
    (var f (alloc_function args (get_code asm) guard))
    (return f)
    ))

(fun compile_build_closure (asm mod expr) (
    (var lam (expr_arg expr 0))
    (var fv (list_reverse (expr_arg expr 1)))
    ; allocate free variables
    (var clos_len 0)
    (while fv (do
        (compile asm mod (car fv))
        (+= clos_len 1)
        (= fv (cdr fv))
        ))
    (put_struct asm clos_len clos_len)

    (var save_compiling_closure compiling_closure)
    (= compiling_closure true)
    (compile asm mod lam)
    (= compiling_closure save_compiling_closure)

    (compile_simple_call asm 2 build_closure)
    ))

(fun compile_fieldref (asm mod expr) (
    (var obj (expr_arg expr 0))
    (var idx (expr_arg_int expr 1))
    (compile asm mod obj)
    (put_fieldget asm idx)
    ))

(fun compile_fieldassign (asm mod expr) (
    (var lhs (expr_arg expr 0))
    (var rhs (expr_arg expr 1))
    (var obj (expr_arg lhs 0))
    (var idx (expr_arg_int lhs 1))
    (compile asm mod rhs)
    (compile asm mod obj)
    (put_fieldset asm idx)
    ))

(export fun compile_simple_function (asm arity func) (
    (var n arity)
    (while (> n 0) (do
        (decr n)
        (put_arg asm n)
        ))
    (compile_simple_call asm arity func)
    (put_ireturn asm)
    ))

(export fun compile_simple_call (asm arity func) (
    (if @(IS_PRIM func)
        (do
            (put_pcall asm @(PRIM_IDX func) (* 4 arity))
        )
        (do
            (put_imm_int32 asm func)
            (put_dcall asm (* 4 arity))
        ))
    ))

(fun append_function (mod sym newfunc) (
    (var info (lookup_symbol_local mod sym))
    (if info
        (do
            (must_be_module_variable sym info)
            (check_if_initialized sym info)
            (var box (expr_arg info 0))
            (var func (field_get box 0))
            (if (callable func)
                (= newfunc (make_bound newfunc func))
                )
            (field_set box 0 newfunc)
            return
        ))
    (= info (lookup_symbol mod sym))
    (if info
        (do
            (must_be_module_variable sym info)
            (check_if_initialized sym info)
            (var box (expr_arg info 0))
            (var func (field_get box 0))
            (if (callable func)
                (= newfunc (make_bound newfunc func))
                )
        ))
    (add_module_variable mod sym newfunc false)
    ))

; AppendFunction{sym, fun} is equivalent to:
; sym: fun                   (when `sym' is not defined)
; sym: fun | sym             (when `sym' is defined in outer scope)
; sym: fun | sym (overwrite) (when `sym' is defined in local scope)
(fun compile_define_function (asm mod expr) (
    (var sym (expr_arg_symbol expr 0))
    (var fun (expr_arg expr 1))
    (var info (lookup_symbol_local mod sym))
    (if (is_defined_locally info)
        (return (compile asm mod
            (make_expr DefineVariable (list3 sym (make_expr Bind (list2 fun sym)) (to_sym "overwrite")))))
        )
    (= info (lookup_effective_symbol mod sym))
    (if info 
        (return (compile asm mod
            (make_expr DefineVariable (list2 sym (make_expr Bind (list2 fun sym))))))
        (return (compile asm mod
            (make_expr DefineVariable (list2 sym fun))))
        )
    ))

(export fun add_builtin_function0 (mod sym func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func)
    (var code (get_code asm))
    (append_function mod sym (make_function 0 code guard))
    ))

(export fun add_builtin_function1 (mod sym pat func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 1 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list1 pat) code guard))
    ))

(export fun add_builtin_function2 (mod sym pat1 pat2 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 2 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list2 pat1 pat2) code guard))
    ))

(export fun add_builtin_function3 (mod sym pat1 pat2 pat3 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 3 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list3 pat1 pat2 pat3) code guard))
    ))

(export fun add_builtin_function4 (mod sym pat1 pat2 pat3 pat4 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 4 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list4 pat1 pat2 pat3 pat4) code guard))
    ))

(export fun add_builtin_function5 (mod sym pat1 pat2 pat3 pat4 pat5 func guard) (
    (var asm (make_assembler))
    (compile_simple_function asm 5 func)
    (var code (get_code asm))
    (append_function mod sym (make_function (list5 pat1 pat2 pat3 pat4 pat5) code guard))
    ))

(export fun setup_builtin_compilers (mod) (
    (var blockT (domainP Block))
    (var locT (make_expr Loc (list3 stringT intT intT)))

    (add_compiler mod DontCare compile_error)

    (add_compiler mod (make_expr Located (list2 locT DontCare)) compile_located)

    ; These commands have been evaluated in parsing phase.
    (add_compiler mod (make_expr Import (list1 DontCare)) do_nothing)
    (add_compiler mod (make_expr Include (list1 DontCare)) do_nothing)

    (add_compiler mod (make_expr Qualified (list2 symT DontCare)) compile_qualified)

    (add_compiler mod (make_expr MakeExpr (list2 DontCare DontCare)) compile_make_expr)
    (add_compiler mod (make_expr Head (list1 DontCare)) compile_head)
    (add_compiler mod (make_expr Arguments (list1 DontCare)) compile_arguments)

    (add_compiler mod (make_expr DefineVariable (list2 symT DontCare)) compile_define_variable)
    (add_compiler mod (make_expr DefineVariable (list3 symT DontCare (to_sym "overwrite"))) compile_define_variable)
    (add_compiler mod (make_expr DefineFunction (list2 symT DontCare)) compile_define_function)

    (add_compiler mod (domainP Symbol) compile_var)
    (add_compiler mod (make_expr Dynamic (list1 symT)) compile_dynamic_var)
    (add_compiler mod (quote true) compile_const)
    (add_compiler mod (quote false) compile_const)
    (add_compiler mod (quote nil) compile_const)

    (add_compiler mod (make_expr Apply (list2 DontCare listT)) compile_apply)

    (add_compiler mod (qquote (quote (unquote DontCare))) compile_quote)
    (add_compiler mod (qquote (qquote (unquote (unquote DontCare)))) compile_qquote)

    (add_compiler mod (domainP Int) compile_int)
    (add_compiler mod (domainP String) compile_string)
    (add_compiler mod (domainP List) compile_list)
    (add_compiler mod (domainP Tuple) compile_tuple)

    (add_compiler mod (domainP Block) compile_block)
    (add_compiler mod (domainP OpenBlock) compile_openblock)
    (add_compiler mod (make_expr Scoped (list2 (domainP Module) DontCare))
        compile_scoped)

    (add_compiler mod (make_seq DontCare DontCare) compile_seq)
    (add_compiler mod (make_expr If (list2 DontCare DontCare)) compile_if)
	(add_compiler mod (ifelse DontCare DontCare DontCare) compile_ifelse)
    (add_compiler mod (make_expr While (list2 DontCare DontCare)) compile_while)
    (add_compiler mod (quote Break) compile_break) 
    (add_compiler mod (quote Continue) compile_continue)
    (add_compiler mod (make_expr Return (list1 DontCare)) compile_return)
    (add_compiler mod (make_expr Try (list2 DontCare DontCare)) compile_try)
    (add_compiler mod (make_expr Throw (list1 DontCare)) compile_throw)

    (add_compiler mod (make_expr Equal (list2 DontCare DontCare)) compile_eq)
    (add_compiler mod (make_expr NotEqual (list2 DontCare DontCare)) compile_ne)
    (add_compiler mod (make_expr Not (list1 DontCare)) compile_logical)
	(add_compiler mod (make_expr SeqAnd (list2 DontCare DontCare)) compile_logical)
	(add_compiler mod (make_expr SeqOr (list2 DontCare DontCare)) compile_logical)

    (add_compiler mod (make_expr Assign (list2 symT DontCare)) compile_assign)
    (add_compiler mod (make_expr Assign (list2 (qualified DontCare DontCare) DontCare))
         compile_assign)
    (add_compiler mod (make_expr Lambda (list2 DontCare DontCare)) compile_lambda)
    (add_compiler mod (make_expr Bind (list2 DontCare DontCare)) compile_bind)


    ; internal expressions
    (add_compiler mod (make_expr BuildClosure (list2 DontCare DontCare)) compile_build_closure)
    (add_compiler mod (make_expr Field (list2 DontCare DontCare)) compile_fieldref)
    (add_compiler mod (make_expr Assign
        (list2 (make_expr Field (list2 DontCare DontCare)) DontCare)) compile_fieldassign)
    (add_compiler mod (make_expr ExprAt (list2 DontCare intT)) compile_subscript)
    ))

(export fun add_compiler (mod pat func) (
    (add_builtin_function3 mod Compile (domainP Assembler) (domainP Module) pat func 0)
    ))

    ))
