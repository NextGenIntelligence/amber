;
; rowl - 1st generation
; Copyright (C) 2010 nineties
;
; $Id: rowl1-compile.rlc 2014-01-25 08:11:28 nineties $
;

(import "rlvm-compile")
(import "rowl1-types")

(compile `object `(

(import "rowl1-util")
(import "rowl1-node")
(import "rowl1-error")
(import "rowl1-symtable")
(import "rowl1-assemble")

(var AllocClsEnv   (to_sym "%AllocClosureEnv"))
(var Ref           (to_sym "%Ref"))
(var Decons        (to_sym "%Decons"))
(var noguard       (to_sym "%noguard"))
(var closed        (to_sym "%closed"))

(export fun unwrap_internal (node) (
    ;(if (== (node_head node) Ref)
    ;    (return (unwrap_internal (node_arg node 2))))
    (return node)
    ))

; compilers

(extern object global)
(extern object variables)
(extern object current_loc)
(extern fun set_loc)

(extern fun set_slot)
(extern fun get_slot)
(extern fun store_variable)

(fun trace_func (msg val) (
    (debugs msg)
    (debugpf val)
    (return val)
    ))

(fun trace (asm msg) (
    (put_push asm (string msg))
    (compile_simple_call asm 2 trace_func)
    ))

; variable table
(fun lookup_symbol (sym) (
    (var v (symtable_find variables sym))
    (if v (return v))
    (return (make_gvar sym))
    ))

(fun lookup_symbol_check (sym) (
    (var v (symtable_find variables sym))
    (if v (return v))
    (= v (get_slot global sym))
    (if (!= v @C_UNDEF) (return (make_gvar sym)))
    (throw (undefined_var current_loc sym))
    ))

(fun lookup_symbol_current_scope (sym) (
    (if (== (symtable_depth variables) 0)
        (do
            (var v (get_slot global sym))
            (if (== v @C_UNDEF) (return 0))
            (return v)
        )
        (return (symtable_find_local variables sym))
        )
    ))

(fun iter_args (f node arg level) (
    (if (is_special node) (return arg))
    (if (is_symbol node)
        (if (== level 0) (return (f node arg)) (return arg))
        )
    (if (is_atom node) (return arg))
    (if (is_list node) (do
        (lfor v node (= arg (iter_args f v arg level)))
        (return arg)
        ))
    (var hd (node_bhead node))
    (if (== hd Ref)
        (if (== level 0)
            (return (f (node_arg_symbol node 2) arg))
            (return arg)
        ))
    (if (== hd Quote) (return arg))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote)    (-= level 1)
        ))
    (for i 0 (node_size node)
        (= arg (iter_args f (node_arg node i) arg level))
        )
    (return arg)
    ))

(fun delete_args (node fv) (
    (if (== (node_bhead node) When)
        (return (iter_args list_delete (node_arg node 0) fv 0))
        (return (iter_args list_delete node fv 0))
        )
    ))

(fun add_var (sym list) (
    (return (cons sym (list_delete sym list)))
    ))

(fun collect_args (args) (
    (if (== (node_bhead args) When)
        (return (iter_args add_var (node_arg args 0) 0 0))
        (return (iter_args add_var args 0 0))
        )
    ))

(fun fv_iter_block (stmts fv) (
    (if (! stmts) (return fv))
    (= fv (fv_iter_block (cdr stmts) fv))
    (return (fv_iter (car stmts) 0 fv))
    ))

(fun fv_iter (expr level fv) (
    (if (is_symbol expr) (do
        (if (== level 0) (do
            (if (is_special expr) (return fv))
            (if (== expr DontCare) (return fv))
            (= fv (list_delete expr fv))
            ; global variables are not free
            (if (!= (get_slot global expr) @C_UNDEF) (return fv))
            (return (cons expr fv))
            ))
        (return fv)
        ))
    (if (is_atom expr) (return fv))
    (if (is_list expr) (do
        (lfor v expr (= fv (fv_iter v level fv)))
        (return fv)
        ))
    (var hd (node_bhead expr))
    (if (== level 0) (do
        (if (== hd Define) (do
            (= fv (fv_iter (node_arg expr 1) 0 fv))
            (return (delete_args (node_arg expr 0) fv))
            ))
        (if (== hd Lambda) (do
            (= fv (fv_iter (node_arg expr 1) 0 fv))
            (var arg (node_arg expr 0))
            (if (== (node_bhead arg) When)
                (= fv (fv_iter (node_arg arg 1) 0 fv))
                )
            (return (delete_args (node_arg expr 0) fv))
            ))
        (if (== hd Ref)
            (return (fv_iter (node_arg expr 0) 0 fv))
            )
        (if (|| (== hd Block) (== hd Breakable))
            (return (fv_iter_block (node_arg_list expr 0) fv))
            )
        ))
    (if (== hd Quote) (return fv))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1)))

    (for i 0 (node_size expr)
        (= fv (fv_iter (node_arg expr i) level fv))
        )
    (return fv)
    ))

(fun free_variables (expr) (
    (return (fv_iter expr 0 0))
    ))

;== alpha-conversion ==

; This routine also translates
; f(... x ... x ...) : body
; to
; f(... x ... y ...) when x==y : body
(extern fun _copy)
(fun alpha_args_iter (tbl chk rep expr level) (
    (if (is_symbol expr) (do
        (if (== expr DontCare) (return expr))
        (if (is_special expr) (return expr))
        (if (== level 0) (do
            (if (symtable_find_local tbl expr)
                (throw (redefined_var current_loc expr))
                )
            (if (symtable_find tbl expr)
                (do
                    (var new_sym (unique_sym))
                    (symtable_add tbl expr new_sym)
                    (if (list_member expr (field_get chk 0)) (do
                        (field_set rep 0 (cons (struct 2 expr new_sym)
                            (field_get rep 0)))
                        ))
                    (return new_sym)
                )
                (do
                    (symtable_add tbl expr expr)
                    (field_set chk 0 (cons expr (field_get chk 0)))
                    (return expr)
                ))
            ))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (alpha_args_iter tbl chk rep (car ls) level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Quote) (return expr))
    (if (== hd Domain)
        (if (== level 0) (do
            (node_arg_set expr 0
                (alpha_args_iter tbl chk rep (node_arg expr 0) 0))
            (var dom (node_arg expr 1))
            (if (! (is_symbol dom))
                (node_arg_set expr 1 (alpha_args_iter tbl chk rep dom 0))
                )
            (return expr)
            ))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1))))

    (for i 0 (node_size expr)
        (node_arg_set expr i
            (alpha_args_iter tbl chk rep (node_arg expr i) level))
        )
    (return expr)
    ))

(fun setup_guard (rep guard) (
    (lfor v (field_get rep 0) (do
        (var v1 (field_get v 0))
        (var v2 (field_get v 1))
        (if (== guard @C_NIL)
            (= guard (make_object2 Equal v1 v2))
            (= guard (make_object2 SeqAnd guard (make_object2 Equal v1 v2)))
            )
        ))
    (return guard)
    ))

(fun alpha_args (tbl args) (
    (var chk (struct 1 0))
    (var rep (struct 1 0))
    (if (== (node_bhead args) When)
        (do
            (node_arg_set args 0
                (alpha_args_iter tbl chk rep (node_arg args 0) 0)) 
            (var guard (alpha tbl (node_arg args 1)))
            (node_arg_set args 1 (setup_guard rep guard))
            (return args)
        )
        (do
            (= args (alpha_args_iter tbl chk rep args 0))
            (var guard (setup_guard rep @C_NIL))
            (if (== guard @C_NIL)
                (return args)
                (return (make_object2 When args guard))
                )
        ))
    ))

(fun alpha (tbl expr) (
    (if (is_symbol expr) (do
        (if (== expr DontCare) (return expr))
        (if (is_special expr) (return expr))
        (var subst (symtable_find tbl expr))
        (if subst (return subst))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var new 0)
        (while expr (do
            (= new (cons (alpha tbl (car expr)) new))
            (= expr (cdr expr))
            ))
        (return (list_reverse new))
        ))
    (var hd (node_bhead expr))
    (if (== hd Located)
        (return (make_object2 Located
            (node_arg expr 0)
            (alpha tbl (node_arg expr 1))))
        )
    (if (== hd Define) (do
        (= expr (_copy expr))
        (node_arg_set expr 1 (alpha tbl (node_arg expr 1)))
        (if (!= (node_bhead (node_arg expr 0)) Apply)
            (node_arg_set expr 0 (alpha_args tbl (node_arg expr 0)))
            )
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (symtable_push tbl)
        (var exprs (node_arg_list expr 0))
        (var new_exprs 0)
        (while exprs (do
            (= new_exprs (cons (alpha tbl (car exprs)) new_exprs))
            (= exprs (cdr exprs))
            ))
        (symtable_pop tbl)
        (return (make_object1 hd (list_reverse new_exprs)))
        ))
    (if (== hd Lambda) (do
        (symtable_push tbl)
        (= expr (_copy expr))
        (node_arg_set expr 0 (alpha_args tbl (node_arg expr 0)))
        (node_arg_set expr 1 (alpha tbl (node_arg expr 1)))
        (symtable_pop tbl)
        (return expr)
        ))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote)
        (return (make_object1 QuasiQuote
            (alpha_qquote tbl (node_arg expr 0) 0)))
        )

    (= expr (_copy expr))
    (for i 0 (node_size expr)
        (node_arg_set expr i (alpha tbl (node_arg expr i)))
        )
    (return expr)
    ))

(fun alpha_qquote (tbl expr level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ret 0)
        (while expr (do
            (= ret (cons (alpha_qquote tbl (car expr) level) ret))
            (= expr (cdr expr))
            ))
        (return (list_reverse ret))
        ))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0)
            (return (make_object1 Unquote (alpha tbl (node_arg expr 0))))
            )
        (-= level 1)
        )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))
    (= expr (_copy expr))
    (for i 0 (node_size expr)
        (node_arg_set expr i (alpha_qquote tbl (node_arg expr i) level))
        )
    (return expr)
    ))

(fun unqualified_args_iter (expr ret level) (
    (if (is_symbol expr) (do
        (field_set ret 1 (cons expr (field_get ret 1)))
        (field_set ret 2 (cons expr (field_get ret 2)))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (unqualified_args_iter (car ls) ret level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Quote) (return expr))
    (if (== hd Subscript) (do
        (var v (unique_sym))
        (field_set ret 1 (cons v (field_get ret 1)))
        (field_set ret 2 (cons expr (field_get ret 2)))
        (return v)
        ))
    (if (== hd Domain)
        (if (== level 0) (do
            (node_arg_set expr 0
                (unqualified_args_iter (node_arg expr 0) ret 0))
            (var dom (node_arg expr 1))
            (if (! (is_symbol dom))
                (node_arg_set expr 1 (unqualified_args_iter dom ret 0))
                )
            (return expr)
            ))
    (if (== hd QuasiQuote) (+= level 1)
    (if (== hd Unquote) (-= level 1))))

    (for i 0 (node_size expr)
        (node_arg_set expr i
            (unqualified_args_iter (node_arg expr i) ret level))
        )
    (return expr)
    ))

(fun unqualified_args (args) (
    (var ret (struct 3 0 0 0))
    (field_set ret 0 (unqualified_args_iter args ret 0))
    (return ret)
    ))

(fun alloc_function (args code guard clos use_self) (
    (return (variant @FunctionE 5 0 args code guard clos use_self))
    ))

(fun args_len (args) (
    (var len 0)
    (while args (do
        (if (== (node_bhead (car args)) Rest) (do
            (return (make_object1 VariableLength (box len)))
            ))
        (+= len 1)
        (= args (cdr args))
        ))
    (return (box len))
    ))

(fun make_function (args code guard use_self) (
    (var arity (args_len args))
    (= args (cons arity args))
    (return (alloc_function args code guard 0 use_self))
    ))

(fun alloc_builtin_function (args func guard use_self) (
    (return (variant @BuiltinFunctionE 3 0 args guard func use_self))
    ))

(fun make_builtin_function (args func guard use_self) (
    (var arity (args_len args))
    (= args (cons arity args))
    (return (alloc_builtin_function args func guard use_self))
    ))

(export fun fusion_function (fun1 fun2) (
    (if (== fun1 @C_UNDEF) (return fun2))
    (if (== fun2 @C_UNDEF) (return fun1))
    (if (! (is_function fun1)) (throw (type_error current_loc (string "function") fun1)))
    (if (! (is_function fun2)) (throw (type_error current_loc (string "function") fun2)))
    (return (variant @BoundFunctionE 3 0 fun1 fun2))
    ))

(var maybe (to_sym "maybe"))
(fun scan_clsvars (expr tbl) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (scan_clsvars (car ls) tbl))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Located) (do
        (node_arg_set expr 1 (scan_clsvars (node_arg expr 1) tbl))
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (var exprs (node_arg_list expr 0))
        (while exprs (do
            (setcar exprs (scan_clsvars (car exprs) tbl))
            (= exprs (cdr exprs))
            ))
        (return expr)
        ))
    (if (== hd Define) (do
        (var syms (collect_args (node_arg expr 0)))
        (while syms (do
            (var sym (car syms))
            (if (! (symtable_find tbl sym)) (do
                (symtable_add tbl sym maybe)
                ))
            (= syms (cdr syms))
            ))
        (node_arg_set expr 1 (scan_clsvars (node_arg expr 1) tbl))
        (return expr)
        ))
    (if (== hd Lambda) (do
        ; free variables of lambdas will be closure variables.
        (var fv (free_variables expr))
        (if (! fv) (return expr))
        (var mkcls @FALSE)
        (while fv (do
            (var info (symtable_find tbl (car fv)))
            (if info (= mkcls @TRUE))
            (if (== info maybe) (do
                (symtable_replace tbl (car fv) @C_TRUE)
                ))
            (= fv (cdr fv))
            ))
        (if (! mkcls) (return expr))
        (return (make_object2 Closure @C_NIL expr))
        ))
    ; Closure has no closure variables since it is already closed.
    (if (== hd Closure) (return expr))
    (if (== hd Ref) (return expr))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0
            (scan_clsvars_qquote (node_arg expr 0) tbl 0))
        (return expr)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i (scan_clsvars (node_arg expr i) tbl))
        )
    (return expr)
    ))

(fun scan_clsvars_qquote (expr tbl level) (
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (scan_clsvars_qquote (car ls) tbl level))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (node_arg_set expr 0 (scan_clsvars (node_arg expr 0) tbl))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote) 
        (+= level 1)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i
            (scan_clsvars_qquote (node_arg expr i) tbl level))
        )
    (return expr)
    ))

(fun subst_clsvars (tbl cls expr) (
    (if (is_special expr) (return expr))
    (if (is_symbol expr) (do
        (var v (symtable_find tbl expr))
        (if (&& v (!= v maybe)) (return (copy v)))
        (return expr)
        ))
    (if (is_atom expr) (return expr))
    (if (is_list expr) (do
        (var ls expr)
        (while ls (do
            (setcar ls (subst_clsvars tbl cls (car ls)))
            (= ls (cdr ls))
            ))
        (return expr)
        ))
    (var hd (node_bhead expr))
    (if (== hd Located) (do
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Define) (do
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (node_arg_set expr 0 (subst_clsvars tbl cls (node_arg expr 0)))
        (return expr)
        ))
    (if (|| (== hd Block) (== hd Breakable)) (do
        (var exprs (node_arg_list expr 0))
        (while exprs (do
            (setcar exprs (subst_clsvars tbl cls (car exprs)))
            (= exprs (cdr exprs))
            ))
        (return expr)
        ))
    (if (== hd Lambda) (do
        (var lhs (node_arg expr 0))
        (if (== (node_bhead lhs) When)
            (node_arg_set lhs 1 (subst_clsvars tbl cls (node_arg lhs 1)))
            )
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Closure) (do
        (if (== (node_arg expr 0) @C_NIL)
            (node_arg_set expr 0 cls)
            )
        (node_arg_set expr 1 (subst_clsvars tbl cls (node_arg expr 1)))
        (return expr)
        ))
    (if (== hd Ref) (do
        (return (make_object3 Ref
            (subst_clsvars tbl cls (node_arg expr 0))
            (node_arg expr 1)
            (node_arg expr 2)
            ))
        ))
    (if (== hd Quote) (return expr))
    (if (== hd QuasiQuote) (do
        (node_arg_set expr 0 (subst_clsvars_qquote tbl cls (node_arg expr 0) 0))
        (return expr)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i (subst_clsvars tbl cls (node_arg expr i)))
        )
    (return expr)
    ))

(fun subst_clsvars_qquote (tbl cls expr level) (
    (if (is_atom expr) (return expr))
    (var hd (node_bhead expr))
    (if (== hd Unquote) (do
        (if (== level 0) (do
            (node_arg_set expr 0 (subst_clsvars tbl cls (node_arg expr 0)))
            (return expr)
            ))
        (-= level 1)
        )
    (if (== hd QuasiQuote) 
        (+= level 1)
        ))
    (for i 0 (node_size expr)
        (node_arg_set expr i
            (subst_clsvars_qquote tbl cls (node_arg expr i) level))
        )
    (return expr)
    ))

(extern fun compile_matching)
(export fun lookup_func (mod sym) (
    (var func (get_slot mod sym))
    (if (== func @C_UNDEF) (do
        (throw (undefined_fun current_loc sym))
        ))
    (if (! (is_function func))
        (throw (type_error current_loc (string "function") func))
        )
    (return (compile_matching current_loc sym func))
    ))

(export fun get_bytecode (func) (
    (return (compile_matching current_loc func func))
    ))

(var closure_frame null)
(var compiling_lambda @FALSE)
(var use_self @FALSE)

(export fun compile_main (expr) (
    (var asm (make_assembler))
    (var tbl (make_symtable 10))
    (symtable_push tbl)
    (compile asm (alpha tbl expr))
    (put_ireturn asm)
    (return (get_code asm))
    ))

(fun compile (asm expr) (
    (runcode (lookup_func global Compile) asm expr)
    ))

(export fun call0 (sym) (
    (return (runcode (lookup_func global sym)))
    ))

(export fun call1 (sym arg0) (
    (return (runcode (lookup_func global sym) arg0))
    ))

(export fun call2 (sym arg0 arg1) (
    (return (runcode (lookup_func global sym) arg0 arg1))
    ))

(export fun call3 (sym arg0 arg1 arg2) (
    (return (runcode (lookup_func global sym) arg0 arg1 arg2))
    ))

(fun topscope_only (asm expr) (
    (throw (unexpected_error current_loc
        (string "Allowed only in top-level scope")
        expr))
    ))

(fun check_arg_size (name size expr) (
    (if (!= (node_size expr) size)
        (throw (type_error current_loc
            (strcat "expression with "
            (strcat (itos size) " arguments"))
            expr
            ))
        )
    ))

(fun compile_error (asm expr) (
    (throw (unknown_expression current_loc expr))
    ))

(fun define_slot (obj sym val) (
    (if (!= (get_slot obj sym) @C_UNDEF)
        (throw (redefined_slot current_loc obj sym))
        )
    (return (set_slot obj sym val))
    ))

(fun append_slot (obj sym val) (
    (var f (get_slot obj sym))
    (if (== f @C_UNDEF)
        (return (set_slot obj sym val))
        )
    (if (&& (is_function val) (is_function f))
        (return (set_slot obj sym (fusion_function val f)))
        )
    (throw (redefined_slot current_loc obj sym))
    ))

(fun append_module_slot (obj sym val) (
    (var f (get_slot obj sym))
    (if (== f @C_UNDEF)
        (return (store_variable obj sym val))
        )
    (if (&& (is_function val) (is_function f))
        (return (set_slot obj sym (fusion_function val f)))
        )
    (throw (redefined_slot current_loc obj sym))
    ))

; obj.f
(fun compile_slot (asm expr) (
    (var obj (node_arg expr 0))
    (var sym (node_arg expr 1))
    (var not_found (fresh_label asm))
    (var exit (fresh_label asm))

    (put_push asm sym)
    (compile asm obj)
    (compile_simple_call asm 2 get_slot)
    ))

; obj.f = v
(fun compile_assign_slot (asm lhs rhs) (
    (var obj (node_arg lhs 0))
    (var sym (node_arg lhs 1))
    (compile asm rhs)
    (put_push asm sym)
    (compile asm obj)
    (compile_simple_call asm 3 set_slot)
    ))

; obj.f: v
(fun compile_define_slot (asm lhs rhs) (
    (var obj (node_arg lhs 0))
    (var sym (node_arg lhs 1))
    (compile asm rhs)
    (put_push asm sym)
    (compile asm obj)
    (compile_simple_call asm 3 define_slot)
    ))

(fun compile_located (asm expr) (
    (set_loc (node_arg expr 0))
    (compile asm (node_arg expr 1))
    ))

(fun compile_special (asm expr) (
    (put_imm_int16 asm expr)
    ))

(fun compile_const_int (asm expr) (
    (put_imm_int asm expr)
    ))

(fun compile_const (asm expr) (
    (put_push asm expr)
    ))

(fun compile_make_object (asm expr) (
    (compile asm (node_arg expr 1))
    (compile asm (node_arg expr 0))
    (compile_simple_call asm 2 make_object)
    ))

(fun store_args (tbl args stmts) (
    (var vars (collect_args args))
    (while vars (do
        (var s (symtable_find tbl (car vars)))
        (if (&& s (!= s maybe)) (do 
            ; this argument is a closure-variable.
            (= stmts (cons (make_object2 Assign (copy s) (car vars)) stmts))
            ))
        (= vars (cdr vars))
        ))
    (return stmts)
    ))

(fun setup_closure_env (subst cls) (
    (var entries (symtable_entries subst))
    (var count 0)
    (for i 0 (vector_size entries) (do
        (var entry (vector_at entries i))
        (if (!= (field_get entry 1) maybe) (do
            (field_set entry 1
                (make_object3 Ref cls (box count) (field_get entry 0)))
            (+= count 1)
            ))
        ))
    (return count)
    ))

(var max_lvar_idx 0)
(var break_labels null)
(var continue_labels null)

(fun get_lvar_idx () (
    (var idx (symtable_count variables))
    (if (>= idx max_lvar_idx) (= max_lvar_idx (+ idx 1)))
    (return idx)
    ))

(fun compile_function (asm_body asm_guard args body guard cls) (
    ;; closure conversion
    (var tbl (make_symtable 10))
    (symtable_push tbl)
    (var vars (collect_args args))
    (while vars (do
        (symtable_add tbl (car vars) maybe)
        (= vars (cdr vars))
        ))
    (if (!= cls @C_NIL)
        (symtable_add tbl cls maybe)
        )
    (= body (scan_clsvars body tbl))

    ; this function needs to allocate an environment for closures.
    (var newcls (unique_sym)) ; closures' environment.
    (var clssize (setup_closure_env tbl newcls))
    (if (> clssize 0) (do
        (= body (subst_clsvars tbl newcls body))

        ; allocate closures' environment.
        (var stmts 0)
        (= stmts (cons (defvar newcls
            (make_object1 AllocClsEnv (box clssize))) stmts))
        (if (== cls @C_NIL)
            (= stmts (store_args tbl args stmts))
            (= stmts (store_args tbl (cons cls args) stmts))
            )
        (= stmts (cons body stmts))
        (= body (make_object1 Block (list_reverse stmts)))
        ))

    (symtable_push variables)

    (var cnt_addr (get_address asm_body))
    (put_allocate asm_body 0)

    (var save_max_lvar_idx max_lvar_idx)
    (var save_break_labels break_labels)
    (var save_continue_labels continue_labels)
    (= max_lvar_idx 0)
    (= break_labels 0)
    (= continue_labels 0)

    (setup_args variables args)

    (if (!= guard noguard)
        (compile asm_guard guard)
        )

    (compile asm_body body)

    (put_operand_byte asm_body (+ cnt_addr 1) max_lvar_idx)
    (symtable_pop variables)

    (= max_lvar_idx save_max_lvar_idx)
    (= break_labels save_break_labels)
    (= continue_labels save_continue_labels)
    ))

(fun setup_args (tbl args) (
    (if (!= (node_bhead args) @List)
        (throw (type_error current_loc (string "a list") args)
        ))
    (var idx 0)
    (while args (do
        (var arg (car args))
        (if (== (node_bhead arg) Rest) (do
            (if (cdr args)
                (throw (exception current_loc (string
                        "\"...\" must be the last argument")))
                )
            (if (== (node_size arg) 0) return)
            (var v (node_arg_symbol arg 0))
            (symtable_add tbl v (make_args_from idx))
            return
            ))
        (setup_arg tbl (make_arg idx) arg 0)
        (= args (cdr args))
        (+= idx 1)
        ))
    ))

(fun setup_arg (tbl obj arg level) (
    (if (is_special arg) return)
    (if (is_symbol arg) (do
        (if (== level 0) (symtable_add tbl arg obj))
        return
        ))
    (if (is_atom arg) return)
    (var argty (node_bhead arg))
    (if (== argty Domain) (do
        (if (== level 0) (do
            (var v (node_arg_symbol arg 0))
            (symtable_add tbl v obj)
            (var dom (node_arg arg 1))
            (if (! (is_symbol dom))
                (setup_arg tbl obj dom 0)
                )
            return
            ))
        ))
    (if (== argty List) (do
        (var idx 0)
        (while arg (do
            (var a (car arg))
            (if (== (node_bhead a) Rest) (do
                (if (cdr arg)
                    (throw (exception current_loc (string
                        "\"...\" must be the last argument")))
                    )
                (if (== (node_size a) 0) return)
                (var v (node_arg_symbol a 0))
                (= obj (make_list_from obj idx))
                (symtable_add tbl v obj)
                return
                ))
            (setup_arg tbl (make_list_at obj idx) a level)
            (= arg (cdr arg))
            (incr idx)
            ))
        return
        ))
    (if (== argty Quote) return)
    (if (== argty Unquote) 
        (return (setup_arg tbl obj (node_arg arg 0) (- level 1)))
        )
    (if (== argty QuasiQuote)
        (return (setup_arg tbl obj (node_arg arg 0) (+ level 1)))
        )

    (for i 0 (node_size arg) (do
        (var a (node_arg arg i))
        (if (== (node_bhead a) Rest) (do
            (if (!= (+ i 1) (node_size arg))
                (throw (exception current_loc (string
                        "\"...\" must be the last argument")))
                )
            (if (== (node_size a) 0) return)
            (var v (node_arg_symbol a 0))
            (= obj (make_restof obj i))
            (symtable_add tbl v obj)
            return
            ))
        (setup_arg tbl (make_object_at arg obj i) (node_arg arg i) level)
        ))
    ))

(fun make_gvar (sym) (
    (return (make_object1 GlobalVariable sym))
    ))

(fun make_lvar (idx) (
    (return (make_object1 LocalVariable (box idx)))
    ))

(export fun get_arity () (
    (return (make_object Arity 0))
    ))

(export fun make_arg (idx) (
    (return (make_object1 Argument (box idx)))
    ))

(export fun make_args_from (idx) (
    (return (make_object1 ArgumentsFrom (box idx)))
    ))

(export fun make_list_at (obj idx) (
    (return (make_object2 ListAt obj (box idx)))
    ))

(export fun make_list_from (obj idx) (
    (return (make_object2 ListFrom obj (box idx)))
    ))

(export fun make_object_at (arg obj idx) (
    (if (is_tuple arg) (return (make_object2 TupleAt obj (box idx))))
    (if (is_array arg) (return (make_object2 ArrayAt obj (box idx))))
    (return (make_object2 FieldRef obj (box idx)))
    ))

(export fun make_restof (obj idx) (
    (return (make_object2 RestOf obj (box idx)))
    ))

(fun append_function (mod sym newfunc) (
    (var func (get_slot mod sym))
    (if (!= func @C_UNDEF)
        (if (&& (is_function func) (is_function newfunc))
            (return (store_variable mod sym (fusion_function newfunc func)))
            (throw (redefined_slot current_loc mod sym))
            )
        (return (store_variable mod sym newfunc))
        )
    ))

; v: e  (in global scope)
; v: e  (in local scope)
;
; (x,y,z): e     (in global scope)
; (x,y,z): e     (in local scope)
;
; f(x,y,z): e   (in global scope)
; f(x,y,z): e   (in local scope)
(fun compile_define (asm expr) (
    (if (== (symtable_depth variables) 0)
        (compile_define_global asm expr)
        (compile_define_local asm expr)
        )
    ))

; v: e              (in global scope)
; (x,y,z): e        (in global scope)
; f(x,y,z): e       (in global scope)
(fun compile_define_global (asm expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))
    (var ty (node_bhead lhs))
    (if (&& (== (node_size expr) 3) (== (node_arg expr 2) (to_sym "partial")))
        (return (compile_define_global_function asm lhs rhs))
        )
    (if (== ty Apply)
        (throw (unknown_expression current_loc expr))
    (if (== ty BSymbol)
        (return (compile_define_global_variable asm lhs rhs))
    (if (== ty Tuple)
        (return (compile_define_multi_variable asm lhs rhs))
    (if (== ty Slot)
        (return (compile_define_slot asm lhs rhs))
        ))))
    (throw (unknown_expression current_loc expr))
    ))

; v: e              (in local scope)
; (x,y,z): e        (in local scope)
; f(x,y,z): e       (in local scope)
(fun compile_define_local (asm expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))
    (if (&& (== (node_size expr) 3) (== (node_arg expr 2) (to_sym "partial")))
        (return (compile_define_local_function asm lhs rhs))
        )
    (var ty (node_bhead lhs))
    (if (== ty Apply)
        (return (unknown_expression current_loc expr))
    (if (|| (== ty BSymbol) (== ty Ref))
        (return (compile_define_local_variable asm lhs rhs))
    (if (== ty Tuple)
        (return (compile_define_multi_variable asm lhs rhs))
    (if (== ty Slot)
        (return (compile_define_slot asm lhs rhs))
        ))))
    (throw (unknown_expression current_loc expr))
    ))

(fun compile_define_global_variable (asm sym val) (
    (check_variable sym)
    (compile asm val)
    (put_push asm sym)
    (put_push asm global)
    (compile_simple_call asm 3 store_variable)
    ))

; translate
;
; (x, y, z): e
;
; to
;
; tmp: ((t@(x, y, z)) -> [x, y, z, t])(e)
; if tmp == undef then Error
; x: decons(tmp)
; y: decons(tmp)
; z: decons(tmp)
; car(tmp)
(fun compile_define_multi_variable (asm vars val) (
    (var lbl (fresh_label asm))
    (var tup (unqualified_args vars))
    (var pattern (field_get tup 0))
    (var tvars   (field_get tup 1))
    (var rvars   (field_get tup 2))
    (var t (unique_sym))
    (compile asm (apply (lambda
        (list1 (make_object2 Domain t pattern))
        (list_append tvars (list1 t))) (list1 val)))
    (put_dup asm)
    (put_undef asm)
    (put_if_ne asm lbl)
    (put_push asm (make_object2 Define vars val))
    (compile_simple_call asm 1 matching_failed)
    (put_throw asm)

    (set_label asm lbl)
    (while rvars (do
        (compile_define asm (make_object2 Define (car rvars) Decons))
        (put_drop asm)
        (= rvars (cdr rvars))
        ))
    (put_car asm)
    ))

(fun compile_define_global_function (asm lhs lam) (
    (var ty (node_bhead lhs))
    (if (== ty Slot) (do
        (var obj (node_arg lhs 0))
        (var sym (node_arg_symbol lhs 1))
        (compile asm lam)
        (put_push asm sym)
        (compile asm obj)
        (compile_simple_call asm 3 append_module_slot)
        return
        ))

    (compile asm lam)
    (put_push asm lhs)
    (put_push asm global)
    (compile_simple_call asm 3 append_function)
    ))

(fun compile_define_local_variable (asm sym val) (
    (check_variable (variable_name sym))
    (if (== (node_head sym) Ref) (do
        (compile asm val)
        (put_dup asm)
        (compile asm (node_arg sym 0))
        (put_fieldset asm (node_arg_int sym 1))
        ))
    (var info (symtable_find_local variables sym))
    (var idx 0)
    (if info
        (= idx (node_arg_int info 0))
        (do
            (= idx (get_lvar_idx))
            (symtable_add variables sym (make_lvar idx))
        ))
    (compile asm val)
    (put_dup asm)
    (put_store_lvar asm idx)
    ))

(fun compile_define_local_function (asm lhs lam) (
    (var ty (node_bhead lhs))
    (if (== ty Slot) (do
        (var obj (node_arg lhs 0))
        (var sym (node_arg_symbol lhs 1))
        (compile asm lam)
        (put_push asm sym)
        (compile asm obj)
        (compile_simple_call asm 3 append_slot)
        return
        ))

    (if (&& (!= ty BSymbol) (!= ty Ref))
        (throw (unknown_expression current_loc (make_object2 Define lhs lam))) 
        )

    (if (symtable_find_local variables (variable_name lhs))
        (return (compile_define_local_variable asm lhs
            (apply (to_sym "fusion") (list2 lam lhs))))
        (return (compile_define_local_variable asm lhs lam))
        )
    ))

(fun compile_decons (asm expr) (
    (put_decons asm)
    ))

(fun compile_define_clsref (asm clsref rhs overwrite) (
    (if (== overwrite @C_FALSE) (do
        (symtable_add variables (node_arg_symbol clsref 2) clsref)
        ))
    (compile asm (assign clsref rhs))
    ))

(fun check_variable (sym) (
    (if (|| (!= (node_type sym) @SymbolE) (is_special sym))
        (throw (invalid_varname current_loc sym))
        )
    (if (== (symtable_depth variables) 0)
        (if (== (get_slot global sym) @C_UNDEF) return)
        (if (! (symtable_find_local variables sym)) return)
        )
    (throw (redefined_var current_loc sym))
    ))

(fun check_init (sym info) (
    (if (!= (node_bhead info) GlobalVariable) (do
        (throw (unexpected_error current_loc
            (string "module variable is required")
            sym))
        ))
    (var box (node_arg info 0))
    (if (! box) (do
        (var loc (node_arg info 1))
        (throw (undefined_var loc sym))
        ))
    ))

(fun load_global_variable (global sym) (
    (var v (get_slot global sym))
    (if (== v @C_UNDEF)
        (throw (undefined_var current_loc sym))
        )
    (return v)
    ))

(export fun compile_operand (asm opd sym) (
    (if (== sym closure_frame) (do
        (put_load_closure asm)
        return
        ))

    (var ty (node_bhead opd))
    (if (== ty GlobalVariable) (do
        (put_push asm sym)
        (put_push asm global)
        (compile_simple_call asm 2 load_global_variable)
        return
        ))
    (if (== ty LocalVariable) (do
        (put_load_lvar asm (node_arg_int opd 0))
        return
        ))
    (if (== ty Arity) (do
        (put_arity asm)
        (put_box asm)
        return
        ))
    (if (== ty Argument) (do
        (put_arg asm (node_arg_int opd 0))
        return
        ))
    (if (== ty ArgumentsFrom) (do
        (put_args asm (node_arg_int opd 0))
        return
        ))
    (if (== ty ListAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_list_at asm)
        return
        ))
    (if (== ty ListFrom) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_list_from asm)
        return
        ))
    (if (== ty TupleAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (node_arg_int opd 1))
        (put_array_get32 asm)
        return
        ))
    (if (== ty ArrayAt) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_field_get1 asm)
        (put_imm_int asm (node_arg_int opd 1))
        (put_array_get32 asm)
        return
        ))
    (if (== ty FieldRef) (do
        (compile_operand asm (node_arg opd 0) sym)
        (put_imm_int asm (+ (node_arg_int opd 1) 1))
        (put_array_get32 asm)
        return
        ))
    (if (== ty RestOf) (do
        (put_imm_int asm (node_arg_int opd 1))
        (compile_operand asm (node_arg opd 0) sym)
        (compile_simple_call asm 2 node_restof)
        return
        ))
    (not_reachable "compile_operand")
    ))

(fun compile_getself (asm expr) (
    (if (! compiling_lambda)
        (throw (exception current_loc (string "`self' outside lambda")))
        )
    (= use_self @TRUE)
    (put_self asm)
    ))

(fun compile_var (asm sym) (
    (compile_operand asm (lookup_symbol sym) sym)
    ))

(fun compile_apply (asm expr) (
    (var func (node_arg expr 0))
    (var args (node_arg expr 1))
    
    ; eval and push arguments from right to left
    (= args (list_reverse args))
    (var arity 0)
    (while args (do
        (compile asm (car args))
        (= args (cdr args))
        (incr arity)
        ))

    (compile asm func)
    (put_push asm func)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity) @FALSE)
    ))

(fun get_slot_swap (sym obj) (
    (var f (get_slot obj sym))
    (if (== f @C_UNDEF)
        (throw (field_not_found current_loc obj sym))
        )
    (return f)
    ))

(fun compile_send (asm expr) (
    (var obj  (node_arg expr 0))
    (var sym  (node_arg expr 1))
    (var args (node_arg expr 2))
    
    ; eval and push arguments from right to left
    (= args (list_reverse args))
    (var arity 0)
    (while args (do
        (compile asm (car args))
        (= args (cdr args))
        (incr arity)
        ))

    (compile asm obj)   ; self;arg1;arg2;...
    (put_dup asm)       ; self;self;arg1;arg2;..
    (put_push asm sym)
    (compile_simple_call asm 2 get_slot_swap)   ; fun;self;arg1;arg2;..
    (put_push asm (slot obj sym))
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity) @TRUE)
    ))

(fun compile_unquote (asm expr) (
    (throw (exception current_loc (string "unquotation outside quasi-quotation")))
    ))

(fun compile_quote (asm expr) (
    (put_push asm (node_arg expr 0))
    ))

(extern fun tuple2)
(extern fun tuple3)
(extern fun tuple4)
(extern fun tuple5)

(export fun compile_qquote_main (asm expr level) (
    (var hd (node_bhead expr))
    (if (== hd BSymbol)
        (return (put_push asm expr)))
    (if (== hd BInt)
        (return (put_imm_int asm expr)))
    (if (== hd BString)
        (return (put_push asm expr)))
    (if (is_atom expr)
        (return (put_push asm expr)))
    (if (== hd List) (do
        (if (! expr)
            (put_zero asm)
            (do
                (compile_qquote_main asm (cdr expr) level)
                (compile_qquote_main asm (car expr) level)
                (put_cons asm)
            )
        )
        return
        ))
    (if (== hd Unquote)
        (if (== level 0)
            (return (compile asm (node_arg expr 0)))
            (return (compile_qquote_main asm (node_arg expr 0) (- level 1))) 
            )
    (if (== hd QuasiQuote)
        (+= level 1)
        ))

    (put_zero asm)
    (rfor i 0 (node_size expr) (do
        (compile_qquote_main asm (node_arg expr i) level)
        (put_cons asm)
        ))
    (put_push asm (node_bhead expr))
    (compile_simple_call asm 2 make_object)
    ))

(fun compile_qquote (asm expr) (
    (compile_qquote_main asm (node_arg expr 0) 0)
    ))

(fun compile_list (asm expr) (
    (if (== expr 0)
        (put_zero asm)
        (do
            (compile asm (cdr expr))
            (compile asm (car expr))
            (put_cons asm)
        ))
    ))

(extern fun tuple_at)
(fun compile_tuple (asm expr) (
    (var n (seq_size expr))
    (put_zero asm)
    (rfor i 0 n (do
        (compile asm (tuple_at expr i))
        (put_cons asm)
        ))
    (put_push asm Tuple)
    (compile_simple_call asm 2 make_object)
    ))

(extern fun array_size)
(extern fun array_at)
(fun compile_array (asm expr) (
    (var n (array_size expr))
    (put_zero asm)
    (rfor i 0 n (do
        (compile asm (array_at expr i))
        (put_cons asm)
        ))
    (put_push asm Array)
    (compile_simple_call asm 2 make_object)
    ))

(fun compile_range (asm expr) (
    (var size (node_size expr))
    (if (== size 2)
        (do
            (compile asm (node_arg expr 1))
            (compile asm (node_arg expr 0))
            (put_push asm Range)
            (compile_simple_call asm 3 make_object2)
        )
    (if (== size 3)
        (do
            (compile asm (node_arg expr 2))
            (compile asm (node_arg expr 1))
            (compile asm (node_arg expr 0))
            (put_push asm Range)
            (compile_simple_call asm 4 make_object3)
        )
        (throw (unknown_expression current_loc expr))
        ))
    ))

(fun compile_block_body (asm exprs) (
    (if (! exprs) (do
        (put_nil asm)
        return
        ))
    (while exprs (do
        (compile asm (car exprs))
        (= exprs (cdr exprs))
        (if exprs (put_drop asm)) ; drop values except the last one
        ))
    ))

(fun compile_block (asm expr) (
    (if (== (symtable_depth variables) 0)
        (return (compile_function asm 0 0 expr noguard @C_NIL))
        )
    (var exprs (node_arg expr 0))
    (symtable_push variables)
    (compile_block_body asm exprs)
    (symtable_pop variables)
    ))

(fun compile_breakable (asm expr) (
    (if (== (symtable_depth variables) 0)
        (return (compile_function asm 0 0 expr noguard @C_NIL))
        )
    (var break_lbl (fresh_label asm))
    (var exit_lbl  (fresh_label asm))
    (= break_labels (cons (box break_lbl) break_labels))
    (compile_block asm expr)
    (put_goto asm exit_lbl)
    (set_label asm break_lbl)
    (put_nil asm)
    (set_label asm exit_lbl)
    (= break_labels (cdr break_labels))
    ))

(fun compile_seq (asm expr) (
    (compile_block_body asm (node_arg expr 0))
    ))

(fun compile_if (asm expr) (
    (if (== (symtable_depth variables) 0)
        (return (compile_function asm 0 0 expr noguard @C_NIL))
        )
    (compile_ifelse_main asm (node_arg expr 0) (node_arg expr 1) @C_NIL)
    ))

(fun compile_ifelse (asm expr) (
    (if (== (symtable_depth variables) 0)
        (return (compile_function asm 0 0 expr noguard @C_NIL))
        )
    (compile_ifelse_main asm (node_arg expr 0) (node_arg expr 1) (node_arg expr 2))
    ))

(fun compile_ifelse_main (asm cnd ifthen ifelse) (
    (var cnd_hd (node_bhead cnd))
    (var size (node_size cnd))
    (if (&& (== cnd_hd Not) (== size 1))
        (return (compile_ifelse_main asm (node_arg cnd 0) ifelse ifthen))
        )
    (if (&& (== cnd_hd SeqAnd) (== size 2))
        (return (compile_ifelse_and asm cnd ifthen ifelse))
        )
    (if (&& (== cnd_hd SeqOr) (== size 2))
        (return (compile_ifelse_or asm cnd ifthen ifelse))
        )
    (if (== ifthen @C_NIL)
        (if (== ifelse @C_NIL)
            (do
                (compile asm cnd)
                (put_drop asm)
                (put_nil asm)
            )
            (do
                (var exit_lbl (fresh_label asm))
                (var cont_lbl (fresh_label asm))
                (compile asm cnd)
                (put_if_true asm exit_lbl)
                (compile asm ifelse)
                (put_goto asm cont_lbl)
                (set_label asm exit_lbl)
                (put_nil asm)
                (set_label asm cont_lbl)
            ))
        (if (== ifelse @C_NIL)
            (do
                (var exit_lbl (fresh_label asm))
                (var cont_lbl (fresh_label asm))
                (compile asm cnd)
                (put_if_false asm exit_lbl)
                (compile asm ifthen)
                (put_goto asm cont_lbl)
                (set_label asm exit_lbl)
                (put_nil asm)
                (set_label asm cont_lbl)
            )
            (do
                (var else_lbl (fresh_label asm))
                (var exit_lbl (fresh_label asm))
                (compile asm cnd)
                (put_if_false asm else_lbl)
                (compile asm ifthen)
                (put_goto asm exit_lbl)
                (set_label asm else_lbl)
                (compile asm ifelse)
                (set_label asm exit_lbl)
            ))
        )
    ))

(fun compile_ifelse_and (asm cnd ifthen ifelse) (
    (var ifelse_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_false asm (node_arg cnd 0) ifelse_lbl)
    (exit_if_false asm (node_arg cnd 1) ifelse_lbl)
    (compile asm ifthen)
    (put_goto asm exit_lbl)
    (set_label asm ifelse_lbl)
    (compile asm ifelse)
    (set_label asm exit_lbl)
    ))

(fun compile_ifelse_or (asm cnd ifthen ifelse) (
    (var ifthen_lbl (fresh_label asm))
    (var exit_lbl   (fresh_label asm))
    (exit_if_true asm (node_arg cnd 0) ifthen_lbl)
    (exit_if_true asm (node_arg cnd 1) ifthen_lbl)
    (compile asm ifelse)
    (put_goto asm exit_lbl)
    (set_label asm ifthen_lbl)
    (compile asm ifthen)
    (set_label asm exit_lbl)
    ))

(fun exit_if_true (asm expr exit) (
    (var hd (node_bhead expr))
    (var size (node_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_false asm (node_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (exit_if_true asm (node_arg expr 0) exit)
        (exit_if_true asm (node_arg expr 1) exit)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_false asm (node_arg expr 0) fail)
        (exit_if_true asm (node_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (compile asm expr)
    (put_if_true asm exit)
    ))

(fun exit_if_false (asm expr exit) (
    (var hd (node_bhead expr))
    (var size (node_size expr))
    (if (&& (== hd Not) (== size 1))
        (return (exit_if_true asm (node_arg expr 0) exit))
        )
    (if (&& (== hd SeqOr) (== size 2)) (do
        (var fail (fresh_label asm))
        (exit_if_true asm (node_arg expr 0) fail)
        (exit_if_false asm (node_arg expr 1) exit)
        (set_label asm fail)
        return
        ))
    (if (&& (== hd SeqAnd) (== size 2)) (do
        (exit_if_false asm (node_arg expr 0) exit)
        (exit_if_false asm (node_arg expr 1) exit)
        return
        ))
    (compile asm expr)
    (put_if_false asm exit)
    ))

; translate
;
;   While{cnd, body}
;
; to
;
;   if (not c) goto exit
; head:
;   body
;   if (c) goto head
; exit:
;
(fun compile_while (asm expr) (
    (if (== (symtable_depth variables) 0)
        (return (compile_function asm 0 0 expr noguard @C_NIL))
        )

    (var cnd (node_arg expr 0))
    (var body (node_arg expr 1))
    (var next @C_NIL)
    (if (== (node_size expr) 3)
        (= next (node_arg expr 2))
        )
    (var exit_lbl (fresh_label asm))
    (var cont_lbl (fresh_label asm))
    (var head_lbl (fresh_label asm))

    (= break_labels (cons (box exit_lbl) break_labels))
    (= continue_labels (cons (box cont_lbl) continue_labels))

    (compile asm cnd)

    (put_if_false asm exit_lbl)
    (set_label asm head_lbl)
    
    (compile asm body)
    (put_drop asm)
    (set_label asm cont_lbl)
    (if (!= next @C_NIL) (do
        (compile asm next)
        (put_drop asm)
        ))
    (compile asm cnd)
    (put_if_true asm head_lbl)
    (set_label asm exit_lbl)
    (put_nil asm)

    (= break_labels (cdr break_labels))
    (= continue_labels (cdr continue_labels))
    ))

; translate for i in ary body to
;
; {
;     iter: ary.each
;     v: nil
;     while ((v = iter()) != undef) {
;         i = v
;         body
;     }
; }

(fun compile_for (asm expr) (
    (var i (node_arg expr 0))
    (var ary (node_arg expr 1))
    (var body (node_arg expr 2))
    (var iter (unique_sym))
    (var v (unique_sym))
    (compile asm
        (block (list3
            (defvar iter (apply (to_sym "each") (list1 ary)))
            (defvar v @C_NIL)
            (make_object2 While
                (make_object1 Not (apply (to_sym "equal") (list2
                (assign v (apply iter 0)) @C_UNDEF)))
                (block (list2
                    (defvar i v)
                    body
                    )))
            )))
    ))

(fun compile_revfor (asm expr) (
    (var i (node_arg expr 0))
    (var ary (node_arg expr 1))
    (var body (node_arg expr 2))
    (var iter (unique_sym))
    (var v (unique_sym))
    (compile asm
        (block (list3
            (defvar iter (apply (to_sym "reverse_each") (list1 ary)))
            (defvar v @C_NIL)
            (make_object2 While
                (make_object1 Not (apply (to_sym "equal") (list2
                    (assign v (apply iter 0)) @C_UNDEF)))
                (block (list2
                    (defvar i v)
                    body
                    )))
            )))
    ))

; translate for i in a..b body to
;
; j: a
; n: b
; while (j <= n) {
;     i: j
;     body
;     j += 1
; }

(fun compile_range_for (asm expr) (
    (var i (node_arg expr 0))
    (var rng (node_arg expr 1))
    (var a (node_arg rng 0))
    (var b (node_arg rng 1))
    (var body (node_arg expr 2))
    (var j   (unique_sym))
    (var n (unique_sym))

    (compile asm
        (block (list3
            (defvar j a)
            (defvar n b)
            (make_object3 While
                (apply (to_sym "le") (list2 j n))
                (block (list2
                    (defvar i j)
                    body
                    ))
                (assign j (apply (to_sym "add") (list2 j (box 1)))))
            )))
    ))

; translate revfor i in a..b body to
;
; j: b
; n: a
; while (j >= n) {
;     i: j
;     body
;     j -= 1
; }

(fun compile_range_revfor (asm expr) (
    (var i (node_arg expr 0))
    (var rng (node_arg expr 1))
    (var a (node_arg rng 0))
    (var b (node_arg rng 1))
    (var body (node_arg expr 2))
    (var j (unique_sym))
    (var n (unique_sym))

    (compile asm
        (block (list3
            (defvar j b)
            (defvar n a)
            (make_object3 While
                (apply (to_sym "ge") (list2 j n))
                (block (list2
                    (defvar i j)
                    body))
                (assign j (apply (to_sym "sub") (list2 j (box 1)))))
            )))
    ))

(fun compile_break (asm expr) (
    (if (! break_labels)
        (throw (exception current_loc (string "`break' statement outside loop")))
        )
    (put_goto asm (unbox (car break_labels)))
    ))

(fun compile_continue (asm expr) (
    (if (! continue_labels)
        (throw (exception current_loc (string "`continue' statement outside loop")))
        )
    (put_goto asm (unbox (car continue_labels)))
    ))

(fun compile_assign (asm expr) (
    (var lhs (node_arg expr 0))
    (var rhs (node_arg expr 1))

    ; f(x) = e is equivarent to f = x -> e | f
    (if (&& (== (node_size expr) 3) (== (node_arg expr 2) (to_sym "partial"))) (do
        (return (compile asm (assign lhs (apply (to_sym "fusion") (list2 rhs lhs)))))
        ))

    (var lty (node_bhead lhs))
    (if (== lty Apply)
        (throw (unknown_expression current_loc expr))
        )
    (if (== lty Slot)
        (return (compile_assign_slot asm lhs rhs))
        )
    (if (== lty Subscript)
        (return (compile_subscript_assign asm lhs rhs))
        )
    (if (== lty FieldRef)
        (return (compile_fieldref_assign asm lhs rhs))
        )
    (if (== lty Ref)
        (return (compile_clsref_assign asm lhs rhs))
        )

    (if (! (is_symbol lhs))
        (return (compile_multi_assign asm lhs rhs))
        )

    (var v (lookup_symbol_check lhs))
    (var vty (node_bhead v))
    (if (== vty GlobalVariable) (do
        (compile asm rhs)
        (put_push asm (node_arg_symbol v 0))
        (put_push asm global)
        (compile_simple_call asm 3 store_variable)
        return
        ))

    (compile asm rhs)
    (put_dup asm)
    (if (== vty LocalVariable) (do
        (put_store_lvar asm (node_arg_int v 0))
        return
        )
    (if (== vty Argument) (do
        (put_store_arg asm (node_arg_int v 0))
        return
        )))
    (throw (bug (string "compile_assign")))
    ))

(fun compile_subscript (asm expr) (
    (var opd (node_arg expr 0))
    (var args (node_arg_list expr 1))

    (= args (list_reverse args))
    (var arity 0)
    (while args (do
        (compile asm (car args))
        (= args (cdr args))
        (incr arity)
        ))
    (compile asm opd)
    (incr arity)

    (compile asm (to_sym "at"))
    (put_push asm (to_sym "at"))
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity) @FALSE)
    ))

(fun compile_subscript_assign (asm lhs rhs) (
    (var opd (node_arg lhs 0))
    (var args (node_arg_list lhs 1))

    (compile asm rhs)

    (= args (list_reverse args))
    (var arity 1)
    (while args (do
        (compile asm (car args))
        (= args (cdr args))
        (incr arity)
        ))
    (compile asm opd)
    (incr arity)

    (compile asm (to_sym "store"))
    (put_push asm (to_sym "store"))
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm (* 4 arity) @FALSE)
    ))

; translate
;
; Foo{x, y, Bar{z}} = e
;
; to
;
; tmp: (t@Foo{x, y, Bar{z}} -> [x,y,z,t])(e)
; x = decons(tmp)
; y = decons(tmp)
; z = decons(tmp)
; car(tmp)
(fun compile_multi_assign (asm lhs rhs) (
    (var lbl (fresh_label asm))

    (var tup (unqualified_args lhs))
    (var pattern (field_get tup 0))
    (var tvars   (field_get tup 1))
    (var rvars   (field_get tup 2))

    (var t (unique_sym))
    (compile asm (apply (lambda
        (list1 (make_object2 Domain t pattern))
        (list_append tvars (list1 t))) (list1 rhs)))

    (put_dup asm)
    (put_undef asm)
    (put_if_ne asm lbl)
    (put_push asm (assign lhs rhs))
    (compile_simple_call asm 1 matching_failed)
    (put_throw asm)
    (set_label asm lbl)

    (while rvars (do
        (compile asm (assign (car rvars) Decons))
        (put_drop asm)
        (= rvars (cdr rvars))
        ))
    (put_car asm)
    ))

(fun compile_return (asm expr) (
    (compile asm (node_arg expr 0))
    (put_ireturn asm)
    ))

; handler must be a lambda
(var default_hdler (lambda (to_sym "x") (make_object1 Throw (to_sym "x"))))
(fun compile_try (asm expr) (
    (var stmt (node_arg expr 0))
    (var hdlr (node_arg expr 1))
    (var hdlr_lbl (fresh_label asm))
    (var cont_lbl (fresh_label asm)) 

    (put_unwind_push asm hdlr_lbl)
    (compile asm stmt)
    (put_unwind_pop asm)
    (put_goto asm cont_lbl)
    (set_label asm hdlr_lbl)

    ; here, the thrown exception is on the top of stack.
    (compile asm (apply (to_sym "fusion") (list2 hdlr default_hdler)))
    (put_push asm hdlr)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm 4 @FALSE)
    (set_label asm cont_lbl)
    ))

(fun compile_throw (asm expr) (
    (compile asm (node_arg expr 0))
    (put_throw asm)
    ))

(fun compile_eq (asm expr) (
    (compile asm (make_object2 Apply (to_sym "equal") (node_args expr)))
    ))

(fun compile_ne (asm expr) (
    (compile_eq asm expr)
    (var else_lbl (fresh_label asm))
    (var exit_lbl (fresh_label asm))
    (put_if_false asm else_lbl)
    (put_false asm)
    (put_goto asm exit_lbl)
    (set_label asm else_lbl)
    (put_true asm)
    (set_label asm exit_lbl)
    ))

(fun compile_logical (asm expr) (
	(compile asm (ifelse expr @C_TRUE @C_FALSE))
	))

(fun compile_lambda_main (asm args body guard cls) (
    (var save_compiling_lambda compiling_lambda)
    (= compiling_lambda @TRUE)
    (var save_use_self use_self)
    (= use_self @FALSE)
    (var asm_body (make_assembler))
    (if (!= guard noguard)
        (do
            (var asm_guard (make_assembler))
            (compile_function asm_body asm_guard args body guard cls)
            (put_ireturn asm_body)
            (put_push asm (make_function args (get_code asm_body) (get_code asm_guard) use_self))
        )
        (do
            (compile_function asm_body 0 args body noguard cls)
            (put_ireturn asm_body)
            (put_push asm (make_function args (get_code asm_body) 0 use_self))
        ))
    (= compiling_lambda save_compiling_lambda)
    (= use_self save_use_self)
    ))

(fun compile_lambda_ (asm expr cls) (
    (var lhs (node_arg expr 0))
    (var body (node_arg expr 1))
    (var hd (node_bhead lhs))
    (if (== hd List)
        (compile_lambda_main asm lhs body noguard cls)
    (if (== hd When)
        (do
            (var guard (node_arg lhs 1))
            (var args (node_arg lhs 0))
            (= hd (node_bhead lhs))
            (compile_lambda_main asm args body guard cls)
        )
        (compile_lambda_main asm (list1 lhs) body noguard cls)
        ))
    ))

(fun compile_lambda (asm expr) (
    (return (compile_lambda_ asm expr @C_NIL))
    ))

(fun build_closure (lam clos) (
    (var args (field_get lam 2))
    (var body (field_get lam 3))
    (var guard (field_get lam 4))
    (var use_self (field_get lam 6))
    (return (alloc_function args body guard clos use_self))
    ))

(fun compile_closure (asm expr) (
    (compile asm (node_arg expr 0))

    (var save_closure_frame closure_frame)
    (= closure_frame (node_arg expr 0))

    (compile_lambda_ asm (node_arg expr 1) (node_arg expr 0))
    (compile_simple_call asm 2 build_closure)

    (= closure_frame save_closure_frame)
    ))

(fun compile_alloc_clsenv (asm expr) (
    (var size (node_arg_int expr 0))
    (var t size)
    (while (> t 0) (do
        (put_zero asm)
        (-= t 1)
        ))
    (put_struct asm size size)
    ))

(fun compile_clsref (asm expr) (
    (compile asm (node_arg expr 0))
    (put_fieldget asm (node_arg_int expr 1))
    ))

(fun compile_clsref_assign (asm lhs rhs) (
    (compile asm rhs)
    (put_dup asm)
    (compile asm (node_arg lhs 0))
    (put_fieldset asm (node_arg_int lhs 1))
    ))

(fun compile_fieldref (asm expr) (
    (compile asm (node_arg expr 0))
    (put_fieldget asm (node_arg_int expr 1))
    ))

(fun compile_fieldref_assign (asm lhs rhs) (
    (compile asm rhs)
    (put_dup asm)
    (compile asm (node_arg lhs 0))
    (put_fieldset asm (node_arg_int lhs 1))
    ))

(export fun compile_simple_function (asm arity func) (
    (var n arity)
    (while (> n 0) (do
        (decr n)
        (put_arg asm n)
        ))
    (compile_simple_call asm arity func)
    (put_ireturn asm)
    ))

(export fun compile_simple_call (asm arity func) (
    (put_imm_int32 asm func)
    (put_acall asm (* 4 arity))
    ))

(fun variable_name (lhs) (
    (if (== (node_bhead lhs) Ref)
        (return (node_arg_symbol lhs 2))
        )
    (if (is_symbol lhs) (return lhs))
    (throw (type_error current_loc (string "a symbol") lhs))
    ))

; f(x) = e is equivarent to f = f | (x -> e)
(fun compile_function_assign (asm lhs rhs) (
    (var func (node_arg lhs 0))
    (var args (node_arg lhs 1))
    (compile asm (assign func (lambda args rhs)))
    ))

(export fun add_function0 (mod sym func guard) (
    (append_function mod sym (make_builtin_function 0 func guard @FALSE))
    ))

(export fun add_function1 (mod sym pat func guard) (
    (append_function mod sym (make_builtin_function (list1 pat) func guard @FALSE))
    ))

(export fun add_function2 (mod sym pat1 pat2 func guard) (
    (append_function mod sym (make_builtin_function (list2 pat1 pat2) func guard @FALSE))
    ))

(export fun add_function3 (mod sym pat1 pat2 pat3 func guard) (
    (append_function mod sym (make_builtin_function (list3 pat1 pat2 pat3) func guard @FALSE))
    ))

(export fun add_function4 (mod sym pat1 pat2 pat3 pat4 func guard) (
    (append_function mod sym (make_builtin_function (list4 pat1 pat2 pat3 pat4) func guard @FALSE))
    ))

(export fun add_function5 (mod sym pat1 pat2 pat3 pat4 pat5 func guard) (
    (append_function mod sym (make_builtin_function (list5 pat1 pat2 pat3 pat4 pat5) func guard @FALSE))
    ))

(fun compile_ (expr) (
    (return (runcode (compile_main expr)))
    ))

; g * f == (x -> g(f(x)))
(export fun compose_function (g f) (
    (var x (unique_sym))
    (var asm (make_assembler))
    (var lbl1 (fresh_label asm))
    (var lbl2 (fresh_label asm))

    (put_arg0 asm)
    (put_push asm f)
    (put_dup asm)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm 4 @FALSE)

    (put_dup asm)
    (put_undef asm)
    (put_if_ne asm lbl1)
    (put_push asm f)
    (compile_simple_call asm 1 matching_failed)
    (put_throw asm)
    (set_label asm lbl1)

    (put_push asm g)
    (put_dup asm)
    (put_push asm current_loc)
    (compile_simple_call asm 3 compile_matching)
    (put_jcall asm 4 @FALSE)

    (put_dup asm)
    (put_undef asm)
    (put_if_ne asm lbl2)
    (put_push asm g)
    (compile_simple_call asm 1 matching_failed)
    (put_throw asm)
    (set_label asm lbl2)

    (put_ireturn asm)
    (return (make_function (list1 x) (get_code asm) 0 @FALSE))
    ))

(export fun setup_builtin_compilers () (
    (var locT (domainP Loc))

    (add_function1 global Compile DontCare compile_ 0)

    (add_compiler global DontCare compile_error)
    (add_compiler global (make_object2 Located locT DontCare) compile_located)

    ; These commands have been evaluated in parsing phase.
    (add_compiler global (make_object1 Import DontCare) topscope_only)

    (add_compiler global (make_object2 MakeObject DontCare DontCare) compile_make_object)
    (add_compiler global (make_object0 GetSelf) compile_getself)
    (add_compiler global symT compile_var)
    (add_compiler global (quote @C_TRUE) compile_special)
    (add_compiler global (quote @C_FALSE) compile_special)
    (add_compiler global (quote @C_NIL) compile_special)
    (add_compiler global (quote @C_UNDEF) compile_special)
    (add_compiler global intT compile_const_int)
    (add_compiler global stringT compile_const)
    (add_compiler global bintT compile_const)
    (add_compiler global (domainP Float) compile_const)

    (add_compiler global (make_object2 Apply DontCare listT) compile_apply)
    (add_compiler global (make_object3 Send DontCare symT listT) compile_send)

    (add_compiler global (qquote (unquote (unquote DontCare))) compile_unquote)
    (add_compiler global (qquote (quote (unquote DontCare))) compile_quote)
    (add_compiler global (qquote (qquote (unquote (unquote DontCare)))) compile_qquote)

    (add_compiler global (domainP List)  compile_list)
    (add_compiler global (domainP Tuple) compile_tuple)
    (add_compiler global (domainP Array) compile_array)
    (add_compiler global (domainP Range) compile_range)

    (add_compiler global (make_object1 Block listT) compile_block)
    (add_compiler global (make_object1 Seq listT) compile_seq)
    (add_compiler global (make_object1 Breakable listT) compile_breakable)

    (add_compiler global (mkif DontCare DontCare) compile_if)
	(add_compiler global (ifelse DontCare DontCare DontCare) compile_ifelse)
    (add_compiler global (make_object2 While DontCare DontCare) compile_while)
    (add_compiler global (make_object3 While DontCare DontCare DontCare) compile_while)

    (add_compiler global (make_object3 For DontCare DontCare DontCare)
        compile_for
        )
    (add_compiler global (make_object3 RevFor DontCare DontCare DontCare)
        compile_revfor
        )
    (add_compiler global (make_object3 For DontCare
        (make_object2 Range DontCare DontCare) DontCare)
        compile_range_for)
    (add_compiler global (make_object3 RevFor DontCare
        (make_object2 Range DontCare DontCare) DontCare)
        compile_range_revfor)

    (add_compiler global (make_object0 Break) compile_break) 
    (add_compiler global (make_object0 Continue) compile_continue)
    (add_compiler global (make_object1 Return DontCare) compile_return)
    (add_compiler global (make_object2 Try DontCare DontCare) compile_try)
    (add_compiler global (make_object1 Throw DontCare) compile_throw)

    (add_compiler global (make_object2 Equal DontCare DontCare) compile_eq)
    (add_compiler global (make_object2 NotEqual DontCare DontCare) compile_ne)
    (add_compiler global (make_object1 Not DontCare) compile_logical)
	(add_compiler global (make_object2 SeqAnd DontCare DontCare) compile_logical)
	(add_compiler global (make_object2 SeqOr DontCare DontCare) compile_logical)

    (add_compiler global (make_object2 Lambda DontCare DontCare) compile_lambda)

    (add_compiler global (make_object2 Subscript DontCare DontCare) compile_subscript)

    (add_compiler global (domainP Define) compile_define)
    (add_compiler global (domainP Assign) compile_assign)

    (add_compiler global (make_object2 Slot DontCare symT) compile_slot)

    ; internal expressions
    (add_compiler global (make_object2 FieldRef DontCare intT) compile_fieldref)
    (add_compiler global (make_object1 AllocClsEnv intT) compile_alloc_clsenv)
    (add_compiler global (make_object2 Closure DontCare DontCare) compile_closure)
    (add_compiler global (make_object3 Ref DontCare intT symT) compile_clsref)
    (add_compiler global (quote Decons) compile_decons)

    ; vertical composition
    (add_function2 global (to_sym "mul") funT funT compose_function 0)

    ; horizontal composition
    (add_function2 global (to_sym "fusion") funT funT fusion_function 0)
    (add_function2 global (to_sym "fusion") @C_UNDEF funT fusion_function 0)
    (add_function2 global (to_sym "fusion") funT @C_UNDEF fusion_function 0)
    ))

(export fun add_compiler (mod pat func) (
    (add_function2 mod Compile (domainP Assembler) pat func 0)
    ))

    ))
