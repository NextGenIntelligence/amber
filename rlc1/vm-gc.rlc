;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vm-gc.rlc 2010-06-15 22:14:42 nineties $
;

(var SYS_MUNMAP  91)
(var SYS_MMAP2   192)

; mmap options
(var PROT_READ  0x1)
(var PROT_WRITE 0x2)
(var PROT_EXEC  0x4)
(var PROT_SEM   0x8)
(var PROT_NONE  0x0)
(var MAP_SHARED     0x1)
(var MAP_PRIVATE    0x2)
(var MAP_TYPE       0xf)
(var MAP_FIXED      0x10)
(var MAP_ANONYMOUS  0x20)

; structure of page descriptor. It's size must be 4-word.
;
; 32 bit : joined flag   (1 if the page is joined with previous page)
; 32 bit : generation    (ID number of generation whic this page belongs to)
; 32 bit : void *first   (Address of the beginning of the page)
; 32 bit : void *next    (Pointer to the next page in the page queue)

(define pdescr->joined      (addr)  `([] @addr 0))
(define pdescr->generation  (addr)  `([] @addr 1))
(define pdescr->first       (addr)  `([] @addr 3))
(define pdescr->next        (addr)  `([] @addr 4))

(define pdescr->joined=      (addr val)  `([]= @addr 0 @val))
(define pdescr->generation=  (addr val)  `([]= @addr 1 @val))
(define pdescr->first=       (addr val)  `([]= @addr 3 @val))
(define pdescr->next=        (addr val)  `([]= @addr 4 @val))

; structure of block descriptor.
; 32 bit : void *next    (Pointer to the next block)
; 32 bit : void *first   (Address of the beginning of the block)

(define bdescr->next    (addr)  `([] @addr 0))
(define bdescr->first   (addr)  `([] @addr 1))

(define bdescr->next=    (addr val)  `([]= @addr 0 @val))
(define bdescr->first=   (addr val)  `([]= @addr 1 @val))

(var PDESCR_SIZE    16)
(var PDESCR_SHIFT   4)  ; PDESCR_SIZE = 2^PDESCR_SHIFT
(var BDESCR_SIZE    8)

(var BLOCK_SHIFT 20)    ; 1MB
(var BLOCK_SIZE (<< 1 BLOCK_SHIFT))
(var BLOCK_MASK (- BLOCK_SIZE 1))
(define BLOCK_ROUNDUP (addr)    `(& (+ @addr @BLOCK_SIZE -1) (~ @BLOCK_MASK)))

(var PAGE_SHIFT 9)      ; 512B
(var PAGE_SIZE (<< 1 PAGE_SHIFT))
(var PAGE_MASK (- PAGE_SIZE 1))
(define PAGE_ROUNDUP (addr)     `(& (+ @addr @PAGE_SIZE -1) (~ @PAGE_MASK)))

(var GENERATION_SHIFT 31)
(var GENERATION_MASK (<< 1 GENERATION_SHIFT))
(define ADVANCE_GENERATION (old) `(& (+ @old 1) @GENERATION_MASK))

; the page descriptor of the page
(define PDESCR (page)
    `(| (>> (& @page @BLOCK_MASK @(~ PAGE_MASK)) @(- PAGE_SHIFT PDESCR_SHIFT))
        (& @page @(~ BLOCK_MASK))
    ))

; offset of first page from beginning of the block
(var FIRST_PAGE_OFF (eval (PAGE_ROUNDUP (* PDESCR_SIZE (/ BLOCK_SIZE PAGE_SIZE)))))
(define FIRST_PAGE (block_addr) `(+ @FIRST_PAGE_OFF @block_addr))
(define LAST_PAGE (block_addr)  `(+ @block_addr @BLOCK_SIZE @(- PAGE_SIZE)))

(var FIRST_PDESCR_OFF (>> FIRST_PAGE_OFF (- PAGE_SHIFT PDESCR_SHIFT)))
(var LAST_PDESCR_OFF  (>> (- BLOCK_SIZE PAGE_SIZE) (- PAGE_SHIFT PDESCR_SHIFT)))

(define FIRST_PDESCR (block_addr) `(+ @block_addr @FIRST_PDESCR_OFF))
(define LAST_PDESCR  (block_addr) `(+ @block_addr @LAST_PDESCR_OFF))

(define IS_FIRST_PDESCR (addr)  `(== (& @addr @BLOCK_MASK) @FIRST_PDESCR_OFF))
(define IS_LAST_PDESCR  (addr)  `(== (& @addr @BLOCK_MASK) @LAST_PDESCR_OFF))

(var PAGES_PER_BLOCK (/ (- BLOCK_SIZE FIRST_PAGE_OFF) PAGE_SIZE))

(var MAX_BLOCKS 4096) ; 4096 is enough for 32-bit machine
(define BLOCK_INDEX (addr)   `(>> @addr @BLOCK_SHIFT))
(define BLOCK_ADDR  (idx)    `(<< @idx  @BLOCK_SHIFT))
(define IS_POINTER_TO_HEAP  (addr)  `(!= @(blockmap->first (BLOCK_INDEX addr)) 0))

(define blockmap[] (idx)    `(+ block_map (* 2 @idx)))
(define blockmap->next  (idx)       `([] block_map (* 2 @idx)))
(define blockmap->first (idx)       `([] block_map (+ (* 2 @idx) 1)))
(define blockmap->next=  (idx val)  `([]= block_map (* 2 @idx) @val))
(define blockmap->first= (idx val)  `([]= block_map (+ (* 2 @idx) 1) @val))

(var vm-gc-code `(


(byte[] @(* BDESCR_SIZE MAX_BLOCKS) block_map)
(int stack_base)    ; address of stack bottom
(int current_gen)   ; current generation ID
(int next_gen)      ; next generation ID (used during GC)
(int num_block)     ; number of allocated blocks
(void* next_addr 0)
(int[] @MAX_BLOCKS block_used)
(void* current_block)   ; bdescr of current free block
(void* page_queue_head) ; page queue for breadth first scanning
(void* page_queue_tail) ; page queue for breadth first scanning
(void* freepage)        ; pdescr  of current free page

(fun mmap2 (addr size) (
    (void* ptr (syscall @SYS_MMAP2 addr size
        @(| PROT_READ PROT_WRITE PROT_EXEC) @(| MAP_ANONYMOUS MAP_PRIVATE) -1 0))
    (if (&& (<= -128 ptr) (< ptr 0))  ((error "ERROR: mmap2 failed\n")))
    (return ptr)
    ))

(fun munmap (addr size) (
    (syscall @SYS_MUNMAP addr size)
    ))

; `size` must be a multiple of BLOCK_SIZE
(fun alloc_block (size) (
    (+= size @BLOCK_SIZE)
    (void* ptr (mmap2 0 size))
    (void* slop (& ptr @BLOCK_MASK))
    (if (< (munmap ptr (- @BLOCK_SIZE slop)) 0) ((error "ERROR: munmap failed\n")))
    (if (&& (> slop 0) (< (munmap (- (+ ptr size) slop) slop) 0))
        ((error "ERROR: munmap failed\n")))
    (= ptr (- (+ ptr @BLOCK_SIZE) slop))
    ([]= block_used (/ ptr @BLOCK_SIZE) (/ size @BLOCK_SIZE))
    (return ptr)
    ))


(fun alloc_new_block () (
    (void* addr)
    (if (> (+ num_block 1) @MAX_BLOCKS) ((error "ERROR: too many blocks\n")))
    (if (== next_addr 0)
        ((= addr (alloc_block @BLOCK_SIZE)))
        (
            (= addr (mmap2 next_addr @BLOCK_SIZE))
            (if (!= (& addr @BLOCK_MASK) 0)
                (
                    (if (< (munmap addr @BLOCK_SIZE) 0) ((error "ERROR: munmap failed\n")))
                    (= addr (alloc_block @BLOCK_SIZE))
                )
                (
                    ([]= block_used (/ addr @BLOCK_SIZE) 1)
                )
            )
        ))
    (= next_addr (+ addr @BLOCK_SIZE))
    (init_pdescrs addr)
    (void* blk @(blockmap[] (BLOCK_INDEX addr)))
    (incl num_block)
    ))

(fun init_pdescrs (block_addr) (
    (void* page @(FIRST_PAGE block_addr))
    (void* pdf  @(FIRST_PDESCR block_addr))
    (void* pdl  @(LAST_PDESCR block_addr))
    (while (<= pdf pdl) (
        @(pdescr->generation= pdf 0)
        @(pdescr->first=      pdf page)
        @(pdescr->next=       pdf 0)
        (+= pdf @PDESCR_SIZE)
        (+= page @PAGE_SIZE)
        ))
    ))

(fun init_gc (stack_base_) (
    (int x)
    (if (! stack_base_) ((= stack_base_ (address x))))
    (= stack_base stack_base_)
    (memset block_map 0 @(* BDESCR_SIZE MAX_BLOCKS))
    (= current_gen 1)
    (= next_gen 1)
    (= num_block 0)
    (alloc_new_block)
    (= page_queue_head 0)
    (= page_queue_tail 0)
    ;(= freepage @(FIRST_PDESCR (bdescr->first current_block)))
    ))

(fun cleanup_gc () (
    (for i 0 @MAX_BLOCKS (
        (if ([] block_used i) (
            (munmap 0 @BLOCK_SIZE)
            ))
        ))
    ))

))
