;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rlc1-lex.rlc 2010-10-09 11:14:04 nineties $
;

(import "rowl-compile")

; Regular expressions
;
; comment    : #[^\n]*
; spaces     : [\n\r\t ]
; letter     : [A-Za-z_]
; deciaml    : 0|([1-9][0-9]*(e[0-9]+)?)
; binary     : 0b[01]+
; octal      : 0o[0-7]+
; hex        : 0x[0-9a-fA-F]+
; float      : [0-9]*\.[0-9]+(e(+|-)?[0-9]+)?
; escape     : \\['"\\abfnrtv0]
; character  : \'({escape}|[^\\\'\n])\'
; string     : \"({escape}|[^\\\"\n]*\"
; opchar     : [!#$%&=-^|@+*:/?<>.,]
; identifier : {letter}({letter}|[0-9_])*

; character group

(var CH_EOF        0) ; "\0"
(var CH_SPACES     1) ; "\t\r "
(var CH_NL         2) ; "\n"
(var CH_0          3) ; "0"
(var CH_1          4) ; "1"
(var CH_2_7        5) ; "1234567"
(var CH_8_9        6) ; "89"
(var CH_af         7) ; "af"
(var CH_b          8) ; "b"
(var CH_e          9) ; "e"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_HEX       14) ; "ABCDEFabcdef"
(var CH_OTHER     15) ; "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
(var CH_SQUOTE    16) ; "'"
(var CH_DQUOTE    17) ; "\""
(var CH_SLASH     18) ; "/"
(var CH_BACKSLASH 19) ; "\\"
(var CH_SHARP     20) ; "#"
(var CH_PLUSMINUS 21) ; "+-"
(var CH_SYMBOL    22) ; "!$%&=^|@*:;/?<>.,~`()[]{}"
(var CH_INVALID   23)

; === state transition diagram ===
;
; error state:
;
;    spaces
;   +---+--------------------+
;   v   |                    |
; +---+ |  EOF  +---+        |
; | 0 +-+------>|@12| (end)  |
; +---+ |       +---+        |
;       |  #    +---+        | (comment)
;       +------>| 13+-+------+
;       |       +---+ |
;       |         ^   |[^\n]
;       |         +---+
;       | 0     +---+
;       +------>|@14|            +---+
;               +-+-+            v   |
;                 | b  +---+01 +---+ |01
;                 +--->| 15+-->|@16+-+
;                 |    +---+   +---+
;
;
; 1 : accept token
;
; erro state:
; 2 : invalid character
; 3 : invalid decimal integer literal
; 4 : invalid binary integer literal
; 5 : invalid octal integer literal
; 6 : invalid hexadecimal integer literal
; 7 : invalid floating point literal
; 8 : invalid escape sequence
; 9 : unterminated character literal
; 10: unterminated string literal
; 11: invalid symbol character

; tokens
(var TOK_NONE     256)
(var TOK_EOF      257)
(var TOK_CHAR     258)
(var TOK_INT      259)
(var TOK_FLOAT    260)
(var TOK_STRING   261)
(var TOK_IDENT    262)
(var TOK_OPERATOR 263)

(compile `object `(

(array char chgroup (
     0 23 23 23 23 23 23 23 23  1  2 23 23  1 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
     1 22 17 20 22 22 22 16 22 22 22 21 22 23 22 18
     3  4  5  5  5  5  5  5  6  6 22 22 22 21 22 22
    22 14 14 14 14 14 14 15 15 15 15 15 15 15 15 15
    15 15 15 15 15 15 15 15 15 15 15 22 19 22 22 15
    22  7  8 14 14  9  7 15 15 15 15 15 15 15 13 10
    15 15 11 15 11 15 11 15 12 15 15 22 22 22 22 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
    ))

;                     C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C
;                     H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H
;                     _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
;                     E  S  N  0  1  2  8  a  b  e  o  r  x  n  H  O  S  D  S  B  S  P  S  I
;                     O  P  L  :  :  _  _  f  :  :  :  t  :  :  E  T  Q  Q  L  A  H  L  Y  N
;                     F  A  :  :  :  7  9  :  :  :  :  v  :  :  X  H  U  U  A  C  A  U  M  V
;                     :  C  :  :  :  :  :  :  :  :  :  :  :  :  :  E  O  O  S  K  R  S  B  A
;                     :  E  :  :  :  :  :  :  :  :  :  :  :  :  :  R  T  T  H  S  P  M  O  L
;                     :  S  :  :  :  :  :  :  :  :  :  :  :  :  :  :  E  E  :  L  :  I  L  I
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  A  :  N  :  D
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  S  :  U  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  H  :  S  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :
(array char s0next  (12  2  2 14  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2 13  2  2  2))
(array char s14next ( 1  1  1  3  3  3  3  3 15  3 16  3 17  3  3  3  1  1  1  1  1  1  1  2))
(array char s16next ( 1  1  1 16 16  4  4  4  4  4  4  4  4  4  4  4  1  1  1  1  1  1  1  2))

(var lexichan null)
(var lexbuf null)
(var lexbuf_end 0)
(var token_tag @TOK_NONE)
(var token_value 0) ; for integer and character
(var token_buf null)
(var srcfile null)
(var srcline 1)
(var srcclmn 1)
(var unputted 0)

(fun token_text () ((return (cvector_ptr token_buf))))
(fun token_len  () ((return (- (cvector_size token_buf) 1))))

(fun init_token_buf () (
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (cvector_resize token_buf 0)
    (cvector_pushback token_buf '\0')
    return
    ))

(fun lookahead () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (return @CH_EOF))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (if (== c -1) (return @CH_EOF))
    (return (array_get char chgroup c))
    ))

(fun consume () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (error "unexpected EOF"))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (incr lexbuf_end)
    (if (== c '\n') (do
        (incr srcline)
        (= srcclmn 1)
        )
        (incr srcclmn)
        )
    (cvector_put token_buf (- (cvector_size token_buf) 1) c)
    (cvector_pushback token_buf '\0')
    (return c)
    ))

(fun unput () (
    (if unputted (error "ERROR: try to unput two or more tokens\n"))
    (= unputted 1)
    return
    ))

(fun next_state (table) (
    (return (array_get char table (lookahead)))
    ))

(fun accept (tag) (
    (= token_tag tag)
    return
    ))

(fun lex_error (msg) (
    (flush stdout)
    (output_string stderr srcfile)
    (output_char   stderr ':')
    (output_int    stderr srcline)
    (output_char   stderr ':')
    (output_int    stderr srcclmn)

    (output_string stderr ": ")
    (output_string stderr msg)
    (output_char   stderr '\n')
    (exit 1)
    ))

(export fun init_lexer (fname ichan) (
    (= srcfile fname)
    (= srcline 1)
    (= srcclmn 1)
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (= unputted 0)
    (= lexichan ichan)
    (= token_buf (make_cvector 0))
    (cvector_pushback token_buf '\0')
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)
    return
    ))

(export fun lex () (
    (var state 0)

    (label lex_loop)
    (tswitch state (
        (0 . (do
            (var c (lookahead))
            (while (|| (== c @CH_SPACES) (== c @CH_NL)) (do
                (consume)
                (= c (lookahead))
                ))
            (init_token_buf)
            (= state (next_state s0next))
            (goto lex_loop)
            ))
        (1 . (return token_tag))
        (2  . (lex_error "invalid character"))
        (3  . (lex_error "invalid decimal integer literal"))
        (4  . (lex_error "invalid binary integer literal"))
        (5  . (lex_error "invalid octal integer literal"))
        (6  . (lex_error "invalid hexadecimal integer literal"))
        (7  . (lex_error "invalid floating point literal"))
        (8  . (lex_error "invalid escape sequenc"))
        (9  . (lex_error "unterminated character literal"))
        (10 . (lex_error "unterminated string literal"))
        (11 . (lex_error "invalid symbol characte"))
        (12 . (return @TOK_EOF))
        (13 . (do
            ; comment
            (consume)
            (while (!= (lookahead) @CH_NL) (consume))
            (consume)
            (= state 0)
            (goto lex_loop)
            ))
        (14 . (do
            (consume)
            (= token_value 0)
            (accept @TOK_INT)
            (= state (next_state s14next))
            (goto lex_loop)
            ))
        (15 . (do
            (consume)
            (= token_value 0)
            (var c (lookahead))
            (if (&& (!= c @CH_0) (!= c @CH_1)) (do
                (= state 4)
                (goto lex_loop)
                ))
            ; fall through
            ))
        (16 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_value 1)
            (|= token_value (- c '0'))
            (print_int token_value)
            (print_char '\n')
            (= state (next_state s16next))
            (goto lex_loop)
            ))
        (default . (error "BUG: invalid state"))
        ))
    (error "BUG: not reachable")
    ))

    ))
