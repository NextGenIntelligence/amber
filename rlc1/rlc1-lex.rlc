;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rlc1-lex.rlc 2010-10-17 13:41:12 nineties $
;

(import "rowl-compile")
(import "rlc1-types")

; Regular expressions
;
; comment    : #[^\n]*
; spaces     : [\n\r\t ]
; letter     : [A-Za-z_]
; deciaml    : 0|([1-9][0-9]*(e[1-9][0-9]*)?)
; binary     : 0b[01]+
; octal      : 0o[0-7]+
; hex        : 0x[0-9a-fA-F]+
; float      : {decimal}\.[0-9]+(e(+|-)?[0-9]+)?
; escape     : \\['"\\abfnrtv0]
; character  : \'({escape}|[^\\\'\n])\'
; string     : \"({escape}|[^\\\"\n]*\"
; opchar     : [!#$%&=-^|@+*:/?<>.,]
; identifier : {letter}({letter}|[0-9_])*

; character group

(var CH_EOF        0) ; "\0"
(var CH_SPACES     1) ; "\t\r "
(var CH_NL         2) ; "\n"
(var CH_0          3) ; "0"
(var CH_1          4) ; "1"
(var CH_2_7        5) ; "1234567"
(var CH_8_9        6) ; "89"
(var CH_af         7) ; "af"
(var CH_b          8) ; "b"
(var CH_e          9) ; "e"
(var CH_o         10) ; "o"
(var CH_rtv       11) ; "rtv"
(var CH_x         12) ; "x"
(var CH_n         13) ; "n"
(var CH_HEX       14) ; "ABCDEFabcdef"
(var CH_OTHER     15) ; "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
(var CH_SQUOTE    16) ; "'"
(var CH_DQUOTE    17) ; "\""
(var CH_SLASH     18) ; "/"
(var CH_BACKSLASH 19) ; "\\"
(var CH_SHARP     20) ; "#"
(var CH_DOT       21) ; "."
(var CH_PLUSMINUS 22) ; "+-"
(var CH_SPECIAL   23) ; ",()[]{}"
(var CH_SYMBOL    24) ; "!$%&=^|@*:;/\\?<>~`"
(var CH_INVALID   25)

; === state transition diagram ===
;
;    spaces
;   +---+--------------------+
;   v   |                    |
; +---+ | EOF   +---+        |
; | 0 +-+------>|@12| (end)  |
; +---+ |       +---+        |
;       | #     +---+        | (comment)
;       +------>| 13+-+------+
;       |       +---+ |
;       |         ^   |[^\n]
;       |         +---+
;       | 0     +---+
;       +------>|@14|              +---+
;       |       +-+-+              v   |01
;       |         | b  +---+01   +---+ |
;       |         +--->| 15+---->|@16+-+   +---+
;       |         |    +---+     +---+     v   |0-7
;       |         | o         +---+0-7   +---+ |
;       |         +---------->| 17+----->|@18+-+    +---+
;       |         |           +---+      +---+      v   |{hex}
;       |         | x                +---+        +---+ |
;       |         +----------------->| 19+------->|@20+-+                 +---+
;       |         +-------+.         +---+ {hex}  +---+                   v   |0-9
;       | 1-9   +---+  .  |   +---+      +---+  e    +---+ 1-9          +---+ |
;       +------>|@21+-+---+-->| 22+----->|@23+-+---->| 24+-----------+->|@26+-+
;       |       +---+ |       +---+ 0-9  +---+ |     +-+-+           |  +---+
;       |         A   |0-9                 A   |0-9    | +-   +---+  |
;       |         +---+                    +---+       +----->| 25+--+
;       | '     +---+ [^\\\n]        +---+ '    +---+         +---+ 1-9
;       +------>| 27+--------------->| 28+----->|@1 |
;       |       +-+-+                +---+      +---+
;       |         |\    +---+ '"\\abfnrtv0   +---+ '  +---+
;       |         +---->| 29+--------------->| 30+--->|@1 |
;       |               +---+                +---+    +---+
;       | "     +---+              "    +---+
;       +------>| 31+-+----------+----->|@33|
;       |       +---+ |          |      +---+
;       |         A   |[^\\\"\n] |\
;       |         +---+          |
;       |         |              v
;       |         |'"\\abfnrtv0+---+
;       |         +------------+ 32|
;       |                      +---+
;       |{letter}+---+
;       +------->|@34+-+
;       |        +---+ |{letter}|[0-9_]
;       |          A   |
;       |          +---+
;       |{opchar}+---+           +---+
;       +------->| 35+-+-------->|@36|
;       |        +---+ |         +---+
;       |          A   |{opchar}
;       |          +---+
;       |{special} +---+
;       +--------->|@37|
;                  +---+
;
;
;
; 1 : accept token
;
; error state:
;
; 2 : invalid character
; 3 : invalid decimal integer literal
; 4 : invalid binary integer literal
; 5 : invalid octal integer literal
; 6 : invalid hexadecimal integer literal
; 7 : invalid floating point literal
; 8 : invalid escape sequence
; 9 : unterminated character literal
; 10: unterminated string literal
; 11: undefined operator

(compile `object `(

(import "rlc1-util")
(import "rlc1-node")

(array char chgroup (
     0 25 25 25 25 25 25 25 25  1  2 25 25  1 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
     1 24 17 20 24 24 24 16 23 23 24 22 23 22 21 18
     3  4  5  5  5  5  5  5  6  6 24 24 24 24 24 24
    24 14 14 14 14 14 14 15 15 15 15 15 15 15 15 15
    15 15 15 15 15 15 15 15 15 15 15 23 19 23 24 15
    24  7  8 14 14  9  7 15 15 15 15 15 15 15 13 10
    15 15 11 15 11 15 11 15 12 15 15 23 24 23 24 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25
    ))

;                     C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C
;                     H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H
;                     _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
;                     E  S  N  0  1  2  8  a  b  e  o  r  x  n  H  O  S  D  S  B  S  D  P  S  S  I
;                     O  P  L  :  :  _  _  f  :  :  :  t  :  :  E  T  Q  Q  L  A  H  O  L  P  Y  N
;                     F  A  :  :  :  7  9  :  :  :  :  v  :  :  X  H  U  U  A  C  A  T  U  E  M  V
;                     :  C  :  :  :  :  :  :  :  :  :  :  :  :  :  E  O  O  S  K  R  :  S  C  B  A
;                     :  E  :  :  :  :  :  :  :  :  :  :  :  :  :  R  T  T  H  S  P  :  M  I  O  L
;                     :  S  :  :  :  :  :  :  :  :  :  :  :  :  :  :  E  E  :  L  :  :  I  A  L  I
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  A  :  :  N  L  :  D
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  S  :  :  U  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  H  :  :  S  :  :  :
;                     :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :
(array char s0next  (12  2  2 14 21 21 21 34 34 34 34 34 34 34 34 34 27 31 35 35 13 35 35 37 35  2))
(array char s14next ( 1  1  1  3  3  3  3  3 15  3 17  3 19  3  3  3  1  1  1  1  1 22  1  1  1  2))
(array char s16next ( 1  1  1 16 16  4  4  4  4  4  4  4  4  4  4  4  1  1  1  1  1  4  1  1  1  2))
(array char s18next ( 1  1  1 18 18 18  5  5  5  5  5  5  5  5  5  5  1  1  1  1  1  5  1  1  1  2))
(array char s20next ( 1  1  1 20 20 20 20 20 20 20  6  6  6  6 20  6  1  1  1  1  1  6  1  1  1  2))
(array char s21next ( 1  1  1 21 21 21 21  3  3 22  3  3  3  3  3  3  1  1  1  1  1 22  1  1  1  2))
(array char s23next ( 1  1  1 23 23 23 23  7  7 24  7  7  7  7  7  7  1  1  1  1  1  7  1  1  1  2))
(array char s26next ( 1  1  1 26 26 26 26  7  7  7  7  7  7  7  7  7  1  1  1  1  1  7  1  1  1  2))
(array char s27next ( 9 28  9 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 29 28 28 28 28 28  2))
(array char s29next ( 8  8  8 30  8  8  8 30 30  8  8 30  8 30  8  8 30 30  8 30  8  8  8  8  8  2))
(array char s31next (10 31 10 31 31 31 31 31 31 31 31 31 31 31 31 31 31 33 31 32 31 31 31 31 31  2))
(array char s32next ( 8  8  8 31  8  8  8 31 31  8  8 31  8 31  8  8 31 31  8 31  8  8  8  8  8  2))
(array char s34next ( 1  1  1 34 34 34 34 34 34 34 34 34 34 34 34 34  1  1  1  1  1  1  1  1  1  2))
(array char s35next (36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 35 35 36 35 35 36 35  2))

(array char grp_0_9 ( 0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_1_9 ( 0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_oct ( 0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0))
(array char grp_hex ( 0  0  0  1  1  1  1  1  1  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0))

(var lexichan null)
(var lexbuf null)
(var lexbuf_end 0)
(var token_tag @TOK_NONE)
(var token_value 0) ; for integer and character
(var token_buf null)
(var next_srcfile null)
(var next_srcline 1)
(var next_srcclmn 1)
(var srcfile null)
(var srcline 1)
(var srcclmn 1)
(var unputted 0)
(var operator_table null)

(fun is_member_of (c group) ((return (array_get char group c))))

(export fun print_token () (
    (if (< token_tag 256)
        (print_char token_tag)
        (print_string (get_token_text))
        )
    ))

(export fun get_token_text () ((return (cvector_ptr token_buf))))
(export fun get_token_len  () ((return (- (cvector_size token_buf) 1))))
(export fun get_token_value () ((return token_value)))
(export fun get_loc () ((return (tuple 1 srcfile srcline srcclmn next_srcline next_srcclmn))))

(array char esc2val_table (
    34 0 0 0 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 0 0 0 0 0 0 0 0 0 92 0 0 0 0 7 8 0 0 0 12 0
     0 0 0 0 0 0 10 0 0 0 13 0 9 0 11
    ))
(fun esc2val (c) (
    (return (- (array_get char esc2val_table c) '"'))
    ))

(fun init_token_buf () (
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (cvector_resize token_buf 0)
    (cvector_pushback token_buf '\0')
    return
    ))

(fun lookahead () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (return @CH_EOF))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (if (== c -1) (return @CH_EOF))
    (return (array_get char chgroup c))
    ))

(fun consume () (
    (var c)
    (if (== lexbuf_end (cvector_size lexbuf))
        (do
            (if (< (input_char (address c) lexichan) 0)
                (error "unexpected EOF"))
            (cvector_pushback lexbuf c)
        ))
    (= c (cvector_at lexbuf lexbuf_end))
    (incr lexbuf_end)
    (if (== c '\n') (do
        (incr next_srcline)
        (= next_srcclmn 1)
        )
        (incr next_srcclmn)
        )
    (cvector_put token_buf (- (cvector_size token_buf) 1) c)
    (cvector_pushback token_buf '\0')
    (return c)
    ))

(export fun unput () (
    (if unputted (error "try to unput two or more tokens\n"))
    (= unputted 1)
    return
    ))

(fun next_state (table) (
    (return (array_get char table (lookahead)))
    ))

(fun accept (tag) (
    (= token_tag tag)
    return
    ))

(export fun output_token (ochan t) (
    (if (== t @TOK_CHAR) (output_string ochan "character")
    (if (== t @TOK_INT) (output_string ochan "integer")
    (if (== t @TOK_FLOAT) (output_string ochan "floating point")
    (if (== t @TOK_STRING) (output_string ochan "string")
    (if (== t @TOK_SYMBOL) (output_string ochan "symbol")
    (if (== t @TOK_PREFIX) (output_string ochan "prefix operator")
    (if (== t @TOK_POSTFIX) (output_string ochan "postfix operator")
    (if (== t @TOK_INFIX) (output_string ochan "infix operator")
        (do
            (if (>= t 256) (error "BUG: output_token : not reachable"))
            (output_char ochan ''')
            (output_char_escape ochan t)
            (output_char ochan ''')
        )))))))))
    ))

(export fun output_loc (ochan) (
    (if srcfile (do
        (output_string ochan srcfile)
        (output_char   ochan ':')
        (output_int    ochan srcline)
        (output_char   ochan ':')
        (output_int    ochan srcclmn)
        (output_string ochan ": ")
        ))
    ))

(fun lex_error (msg) (
    (flush stdout)
    (output_loc stderr)
    (output_string stderr msg)
    (output_string stderr ": ")
    (output_string stderr (get_token_text))
    (output_char   stderr '\n')
    (exit 1)
    ))

(export fun init_lexer (fname ichan) (
    (= next_srcfile (strdup fname))
    (= next_srcline 1)
    (= next_srcclmn 1)
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (= unputted 0)
    (= lexichan ichan)
    (= token_buf (make_cvector 0))
    (cvector_pushback token_buf '\0')
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)
    (= operator_table (make_idtable))
    return
    ))

(export fun lex () ((return (lex_main 0))))
(export fun lex_infix () ((return (lex_main 1))))

(fun lex_main (infix_p) (
    (if unputted (do
        (= unputted 0)
        (return token_tag)
        ))
    (= srcfile next_srcfile)
    (= srcline next_srcline)
    (= srcclmn next_srcclmn)

    (var state 0)
    (label lexloop)
    (tswitch state (
        (0 . (do
            (var c (lookahead))
            (while (|| (== c @CH_SPACES) (== c @CH_NL)) (do
                (consume)
                (= c (lookahead))
                ))
            (init_token_buf)
            (= state (next_state s0next))
            (goto lexloop)
            ))
        (1  . (return token_tag))
        (2  . (lex_error "invalid character"))
        (3  . (lex_error "invalid decimal integer literal"))
        (4  . (lex_error "invalid binary integer literal"))
        (5  . (lex_error "invalid octal integer literal"))
        (6  . (lex_error "invalid hexadecimal integer literal"))
        (7  . (lex_error "invalid floating point literal"))
        (8  . (lex_error "invalid escape sequenc"))
        (9  . (lex_error "unterminated character literal"))
        (10 . (lex_error "unterminated string literal"))
        (11 . (lex_error "undefined operator"))
        (12 . (do
            (= token_tag @TOK_EOF)
            (return @TOK_EOF)
            ))
        (13 . (do
            ; comment
            (consume)
            (while (!= (lookahead) @CH_NL) (consume))
            (consume)
            (= state 0)
            (goto lexloop)
            ))
        (14 . (do
            (consume)
            (accept @TOK_INT)
            (= state (next_state s14next))
            (goto lexloop)
            ))
        (15 . (do
            (consume)
            (var c (lookahead))
            (if (&& (!= c @CH_0) (!= c @CH_1)) (do
                (= state 4)
                (goto lexloop)
                ))
            ; fall through
            ))
        (16 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_value 1)
            (|= token_value (- c '0'))
            (= state (next_state s16next))
            (goto lexloop)
            ))
        (17 . (do
            (consume)
            (if (! (is_member_of grp_oct (lookahead))) (do
                (= state 5)
                (goto lexloop)
                ))
            ; fall through
            ))
        (18 . (do
            (accept @TOK_INT)
            (var c (consume))
            (<<= token_value 3)
            (|= token_value (- c '0'))
            (= state (next_state s18next))
            (goto lexloop)
            ))
        (19 . (do
            (consume)
            (if (! (is_member_of grp_hex (lookahead))) (do
                (= state 6)
                (goto lexloop)
                ))
            ; fall through
            ))
        (20 . (do
            (accept @TOK_INT)
            (<<= token_value 4)
            (var c (consume))
            (if (<= 'a' c)
                (|= token_value (+ (- c 'a') 10))
            (if (<= 'A' c)
                (|= token_value (+ (- c 'A') 10))
                (|= token_value (- c '0'))
                ))
            (= state (next_state s20next))
            (goto lexloop)
            ))
        (21 . (do
            (accept @TOK_INT)
            (= token_value (+ (* 10 token_value) (- (consume) '0')))
            (= state (next_state s21next))
            (goto lexloop)
            ))
        (22 . (do
            (consume)
            (if (! (is_member_of grp_0_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            ; fall through
            ))
        (23 . (do
            (consume)
            (accept @TOK_FLOAT)
            (= state (next_state s23next))
            (goto lexloop)
            ))
        (24 . (do
            (consume)
            (var c (lookahead))
            (if (is_member_of grp_1_9 c) (do
                (= state 26)
                (goto lexloop)
                ))
            (if (== c @CH_PLUSMINUS) (do
                (= state 25)
                (goto lexloop)
                ))
            (= state 7)
            (goto lexloop)
            ))
        (25 . (do
            (consume)
            (if (! (is_member_of grp_1_9 (lookahead))) (do
                (= state 7)
                (goto lexloop)
                ))
            (= state 26)
            (goto lexloop)
            ))
        (26 . (do
            (consume)
            (= state (next_state s26next))
            (goto lexloop)
            ))
        (27 . (do
            (consume)
            (= state (next_state s27next))
            (goto lexloop)
            ))
        (28 . (do
            (= token_value (consume))
            (accept @TOK_CHAR)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (29 . (do
            (consume)
            (= state (next_state s29next))
            (goto lexloop)
            ))
        (30 . (do
            (= token_value (esc2val (consume)))
            (accept @TOK_CHAR)
            (if (== (lookahead) @CH_SQUOTE) (do
                (consume)
                (= state 1)
                (goto lexloop)
                ))
            (= state 9)
            (goto lexloop)
            ))
        (31 . (do
            (consume)
            (= state (next_state s31next))
            (goto lexloop)
            ))
        (32 . (do
            (consume)
            (= state (next_state s32next))
            (goto lexloop)
            ))
        (33 . (do
            (consume)
            (accept @TOK_STRING)
            (= state 1)
            (goto lexloop)
            ))
        (34 . (do
            (consume)
            (var op (find_operator (get_token_text)))
            (if op
                (accept_operator op infix_p)
                (accept @TOK_SYMBOL)
                )
            (= state (next_state s34next))
            (goto lexloop)
            ))
        (35 . (do
            (consume)
            (var op (find_operator (get_token_text)))
            (if op
                (do (accept_operator op infix_p) (store_lexer_state))
                )
            (= state (next_state s35next))
            (goto lexloop)
            ))
        (36 . (do
            (if (== token_tag @TOK_NONE) (do
                (= state 11)
                (goto lexloop)
                ))
            (restore_lexer_state)
            (= state 1)
            (goto lexloop)
            ))
        (37 . (do
            (accept (consume))
            (= state 1)
            (goto lexloop)
            ))
        (default . (error "BUG: invalid state"))
        ))
    (error "BUG: not reachable")
    ))

(var save_lexbuf_end 0)
(var save_srcline 0)
(var save_srcclmn 0)
(var save_token_len 0)
(var save_token_value 0)
(fun store_lexer_state () (
    (= save_lexbuf_end lexbuf_end)
    (= save_srcline next_srcline)
    (= save_srcclmn next_srcclmn)
    (= save_token_len (get_token_len))
    (= save_token_value (get_token_value))
    ))

(fun restore_lexer_state () (
    (= lexbuf_end save_lexbuf_end)
    (= next_srcline save_srcline)
    (= next_srcclmn save_srcclmn)
    (cvector_resize token_buf save_token_len)
    (cvector_pushback token_buf '\0')
    (= token_value save_token_value)
    ))

(fun accept_operator (op infix_p) (
    (var optype (field_get op 0))
    (if (== optype @OP_PREFIX) (accept @TOK_PREFIX)
    (if (== optype @OP_POSTFIX) (accept @TOK_POSTFIX)
    (if (== optype @OP_INFIX) (accept @TOK_INFIX)
    (if (== optype @OP_CONSTR) (accept @TOK_CONSTR)
    (if (== optype @OP_PREFIX_OR_INFIX) (do
        (if infix_p
            (do (accept @TOK_INFIX) (= op (field_get op 2)))
            (do (accept @TOK_PREFIX) (= op (field_get op 1)))
            )
        )
        )))))
    (= token_value op)
    ))

(fun push_operator_table () (
    (idtable_push operator_table)
    ))

(fun pop_operator_table () (
    (idtable_pop operator_table)
    ))

(fun add_operator (name obj) (
    (idtable_add operator_table name obj)
    ))

(fun find_operator (name) (
    (return (idtable_find operator_table name))
    ))

(fun check_assoc (name assoc) (
    (if (> assoc 0) return)
    (output_string stderr "ERROR: associativity of operator '")
    (output_string stderr name)
    (output_string stderr "' must be positive\n")
    (exit 1)
    ))


(export fun add_prefix (name assoc) (
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (make_symbol name))
    (var prefix_op (variant @OP_PREFIX 1 sym assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op (field_get op 2)))
            return
            ))
        ))
    (add_operator name prefix_op)
    ))

(export fun add_postfix (name assoc) (
    (check_assoc name assoc)
    (var sym (make_symbol name))
    (add_operator name (variant @OP_POSTFIX 1 sym assoc))
    ))

(export fun add_infixl (name assoc) ((add_infix name 1 assoc)))
(export fun add_infixr (name assoc) ((add_infix name 0 assoc)))

(fun add_infix (name is_left assoc) (
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (make_symbol name))
    (var infix_op (variant @OP_INFIX 1 sym is_left assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_PREFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 op infix_op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 (field_get op 1) infix_op))
            return
            ))
        ))
    (add_operator name infix_op)
    ))

(export fun add_constr (name maxlen assoc) (
    (check_assoc name assoc)
    (var sym (make_symbol name))
    (add_operator name (variant @OP_CONSTR 1 sym maxlen assoc))
    ))

    ))
