;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rlc1-lex.rlc 2010-10-08 01:19:00 nineties $
;

(import "rowl-compile")

; Regular expressions
;
; spaces     : [\n\r\t ]
; letter     : [A-Za-z_]
; deciaml    : [0-9]+(e[0-9]+)?
; binary     : 0b[01]+
; octal      : 0o[0-7]+
; hex        : 0x[0-9a-fA-F]+
; float      : [0-9]*\.[0-9]+(e(+|-)?[0-9]+)?
; escape     : \\['"\\abfnrtv0]
; character  : \'({escape}|[^\\\'\n])\'
; string     : \"({escape}|[^\\\"\n]*\"
; opchar     : [!#$%&=-^|@+*:/?<>.,]
; identifier : {letter}({letter}|[0-9_])*

; character group

(var CH_EOF        0) ; "\0",
(var CH_SPACES     1) ; "\t\r ",
(var CH_NL         2) ; "\n",
(var CH_ZERO       3) ; "0",
(var CH_1_7        4) ; " 1 234567",
(var CH_8_9        5) ; "89",
(var CH_af         6) ; "af",
(var CH_b          7) ; "b",
(var CH_e          8) ; "e",
(var CH_o          9) ; "o",
(var CH_rtv       10) ; "rtv",
(var CH_x         11) ; "x",
(var CH_n         12) ; "n",
(var CH_HEX       13) ; "ABCDEFabcdef",
(var CH_OTHER     14) ; "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_",
(var CH_SQUOTE    15) ; "'",
(var CH_DQUOTE    16) ; "\"",
(var CH_SLASH     17) ; "/",
(var CH_BACKSLASH 18) ; "\\",
(var CH_SHARP     19) ; "+=",
(var CH_PLUSMINUS 20) ; "#",
(var CH_SYMBOL    21) ; "!$%&=^|@*:;/?<>.,~`()[]{}",
(var CH_INVALID   22)

; === state transition diagram ===
;
;    spaces
;   +---+--------------------+
;   v   |                    |
; +---+ |  EOF  +---+        |
; | 0 +-+------>|@1 | (end)  |
; +---+ |       +---+        |
;       |  #    +---+        | comment
;       +------>| 2 +-+------+
;               +---+ |
;                 ^   |[^\n]
;                 +---+
;
; error state:
;

; tokens
(var TOK_NONE     256)
(var TOK_EOF      257)
(var TOK_CHAR     258)
(var TOK_INT      259)
(var TOK_FLOAT    260)
(var TOK_STRING   261)
(var TOK_IDENT    262)
(var TOK_OPERATOR 263)

(compile `object `(

(array char chgroup (
     0 22 22 22 22 22 22 22 22  1  2 22 22  1 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
     1 21 16 20 21 21 21 15 21 21 21 19 21 22 21 17
     3  4  4  4  4  4  4  4  5  5 21 21 21 19 21 21
    21 13 13 13 13 13 13 14 14 14 14 14 14 14 14 14
    14 14 14 14 14 14 14 14 14 14 14 21 18 21 21 14
    21  6  7 13 13  8  6 14 14 14 14 14 14 14 12  9
    14 14 10 14 10 14 10 14 11 14 14 21 21 21 21 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    22 22 22 22 22 22 22 22 22 22 22 22 22 22 22 22
    ))

;                    C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C  C
;                    H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H
;                    _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
;                    E  S  N  Z  1  8  a  b  e  o  r  x  n  H  O  S  D  S  B  S  P  S  I
;                    O  P  L  E  _  _  f  :  :  :  t  :  :  E  T  Q  Q  L  A  H  L  Y  N
;                    F  A  :  R  7  9  :  :  :  :  v  :  :  X  H  U  U  A  C  A  U  M  V
;                    :  C  :  O  :  :  :  :  :  :  :  :  :  :  E  O  O  S  K  R  S  B  A
;                    :  E  :  :  :  :  :  :  :  :  :  :  :  :  R  T  T  H  S  P  M  O  L
;                    :  S  :  :  :  :  :  :  :  :  :  :  :  :  :  E  E  :  L  :  I  L  I
;                    :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  A  :  N  :  D
;                    :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  S  :  U  :  :
;                    :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  H  :  S  :  :
;                    :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :  :
(array char s0next ( 1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1 -1 -1))

(var lexichan null)
(var lexbuf null)
(var lexbuf_end 0)
(var token_tag @TOK_NONE)
(var token_value 0) ; for integer and character
(var token_buf null)
(var srcfile null)
(var srcline 1)
(var srcclmn 1)
(var unputted 0)

(fun token_text () ((return (cvector_ptr token_buf))))
(fun token_len  () ((return (- (cvector_size token_buf) 1))))

(fun init_token_buf () (
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (cvector_resize token_buf 0)
    (cvector_pushback token_buf '\0')
    return
    ))

(fun look_ahead () (
    (if (== lexbuf_end (cvector_size lexbuf))
        (cvector_pushback lexbuf (input_char lexichan))
        )
    (var c (cvector_at lexbuf lexbuf_end))
    (if (== c -1) (return @CH_EOF))
    (return (array_get char chgroup c))
    ))

(fun consume () (
    (if (== lexbuf_end (cvector_size lexbuf))
        (cvector_pushback lexbuf (input_char lexichan))
        )
    (var c (cvector_at lexbuf lexbuf_end))
    (incr lexbuf_end)
    (if (== c '\n') (do
        (incr srcline)
        (= srcclmn 1)
        )
        (incr srcclmn)
        )
    (cvector_put token_buf (- (cvector_size token_buf) 1) c)
    (cvector_pushback token_buf '\0')
    (return c)
    ))

(fun unput () (
    (if unputted (error "ERROR: try to unput two or more tokens\n"))
    (= unputted 1)
    return
    ))

(fun next_state (table) (
    (return (array_get char table (look_ahead)))
    ))

(fun accept (tag) (
    (= token_tag tag)
    return
    ))

(export fun init_lexer (fname ichan) (
    (= srcfile fname)
    (= srcline 1)
    (= srcclmn 1)
    (= token_tag @TOK_NONE)
    (= token_value 0)
    (= unputted 0)
    (= lexichan ichan)
    (= token_buf (make_cvector 0))
    (cvector_pushback token_buf '\0')
    (= lexbuf (make_cvector 0))
    (= lexbuf_end 0)
    return
    ))

(export fun lex () (
    (var state 0)

    (label lex_loop)
    (tswitch state (
        (0 . (do
            (var c (look_ahead))
            (while (|| (== c @CH_SPACES) (== c @CH_NL)) (do
                (consume)
                (= c (look_ahead))
                ))
            (init_token_buf)
            (= state (next_state s0next))
            (goto lex_loop)
            ))
        (1 . (return @TOK_EOF))
        (2 . (do
            ; comment
            (consume)
            (while (!= (look_ahead) @CH_NL) (consume))
            (consume)
            (goto lex_loop)
            ))
        (default . (error "BUG: invalid state"))
        ))
    (error "BUG: not reachable")
    ))

    ))
