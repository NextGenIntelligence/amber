;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rlc1-parse.rlc 2010-10-14 02:26:39 nineties $
;

(import "rowl-compile")
(import "rlc1-types")

(compile `object `(

(import "rlc1-util")
(import "rlc1-lex")
(import "rlc1-node")

(export fun parse (file) (
    (var ichan (open_in file))
    (init_lexer file ichan)
    (var prog (parse_list (lex)))
    (close_in ichan)
    (return prog)
    ))

(fun parse_tuple (t) (
    (var es (parse_tuple_body t))
    (var nelem (list_length es))
    (if (== nelem 1) (return (car es)))
    (var v (allocate_variant @Tuple nelem nelem))
    (var i 1)
    (while es (do
        (store object v i (car es))
        (incr i)
        (= es (cdr es))
        ))
    (return v)
    ))

(fun parse_tuple_body (t) (
    (if (== t @TOK_EOF) (return 0))
    (if (== t ')') (do
        (unput)
        (return 0)
        ))
    (var es 0)
    (label parse_tuple_body_loop)
    (= es (cons (parse_expr t) es))
    (= t (lex))
    (if (== t ',') (do
        (= t (lex))
        (goto parse_tuple_body_loop)
        ))
    (unput)
    (return (list_reverse es))
    ))

(fun parse_array (t) (
    (var es (parse_array_body t))
    (var nelem (list_length es))
    (var ary (array object nelem))
    (for i 0 nelem (do
        (array_set object ary i (car es))
        (= es (cdr es))
        ))
    (return (variant @Array 1 ary nelem))
    ))

(fun parse_array_body (t) (
    (if (== t @TOK_EOF) (return 0))
    (if (== t ']') (do
        (unput)
        (return 0)
        ))
    (var es 0)
    (label parse_array_body_loop)
    (= es (cons (parse_expr t) es))
    (= t (lex))
    (if (== t ',') (do
        (= t (lex))
        (goto parse_array_body_loop)
        ))
    (unput)
    (return (list_reverse es))
    ))

(fun parse_list (t) ((return (variant @List 1 (parse_list_body t)))))
(fun parse_list_body (t) (
    (if (== t @TOK_EOF) (return 0))
    (if (== t '}') (do
        (unput)
        (return 0)
        ))
    (var e (parse_expr t))
    (= t (lex))
    (if (== t ';') (do
        (var es (parse_list_body (lex)))
        (return (cons e es))
        ))
    (unput)
    (return (cons e 0))
    ))

(fun eatchar (c t) (
    (if (== c t) return)
    (flush stdout)
    (output_loc stderr)
    (output_string stderr "expect ")
    (output_token stderr c)
    (output_char stderr '\n')
    (exit 1)
    ))

(fun syntax_error () (
    (flush stdout)
    (output_loc stderr)
    (output_string stderr "syntax error\n")
    (exit 1)
    ))

(fun parse_expr (t) (
    (var es 0)
    (label parse_expr_loop)
    (if (== t '(') (do
        (var e (parse_tuple (lex)))
        (eatchar ')' (lex))
        (= es (cons e es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t '[') (do
        (var e (parse_array (lex)))
        (eatchar ']' (lex))
        (= es (cons e es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t '{') (do
        (var e (parse_list (lex)))
        (eatchar '}' (lex))
        (= es (cons e es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t @TOK_CHAR) (do
        (= es (cons (variant @Char 0 (get_token_value)) es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t @TOK_INT) (do
        (= es (cons (variant @Int 0 (get_token_value)) es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t @TOK_FLOAT) (do
        (= es (cons (make_float_from_string (get_token_text)) es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t @TOK_STRING) (do
        (var str (get_token_text))
        (var len (- (get_token_len) 2)) ; -2 for double quotes
        (var new (array char (+ len 1)))
        (strncpy new (+ str 1) len)
        (unescape_string new)
        (= es (cons (variant @String 1 new) es))
        (= t (lex))
        (goto parse_expr_loop)
        )
    (if (== t @TOK_IDENT) (do
        (= es (cons (make_symbol (get_token_text)) es))
        (= t (lex))
        (goto parse_expr_loop)
        )
        ))))))))

    (unput)
    (if (! es) (return (variant @Seq 1 0)))
    (if (== (cdr es) 0) (return (car es)))
    (= es (list_reverse es))
    (return (variant @Seq 1 es))
    ))

    ))
