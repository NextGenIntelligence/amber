;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: rlc1-parse.rlc 2010-10-15 16:27:49 nineties $
;

(import "rowl-compile")
(import "rlc1-types")

(compile `object `(

(import "rlc1-util")
(import "rlc1-lex")
(import "rlc1-node")

; Prog ::= Expr*
; Expr ::= Primary
;        | prefix Expr
;        | Expr postfix
;        | Expr infix Expr
;        | Expr { , Expr }
;        | constr<n> Expr{n}
; Primary ::= Literal
;           | Primary open close
;           | Primary open Expr close
;           | open close
;           | open Expr close
;           | \{ Expr* \}
;
; open  = ( [
; close = ) ]
;
; NB:
; - postfix operator must be unique


(export fun parse (file) (
    (var ichan (open_in file))
    (init_lexer file ichan)

    ; for test
    (add_postfix ";" 1)
    (add_infixl "+" 2)
    (add_infixl "-" 2)
    (add_infixl "*" 3)
    (add_infixl "/" 3)
    (add_prefix "+" 4)
    (add_prefix "-" 4)

    (var prog (parse_prog))
    (close_in ichan)
    (return prog)
    ))

(fun parse_prog () (
    (var es 0)
    (while 1 (do
        (if (== (lex) @TOK_EOF) break)
        (unput)
        (var e (parse_expr))
        (= es (cons e es))
        ))
    (return (variant @List 1 (list_reverse es)))
    ))

(fun parse_expr () (

    (var expr_stack 0)
    (var op_stack 0)
    (var next_op)
    (var tok)

    (= op_stack (cons (variant @OP_START 0) op_stack))

(label parse_expr_front)
    (= tok (lex))
    (while (== tok @TOK_PREFIX) (do
        (= op_stack (cons (get_token_value) op_stack))
        (= tok (lex))
        ))
    (var e (parse_primary tok))
    (= expr_stack (cons e expr_stack))

(label parse_expr_infix)
    (= tok (lex_infix))
    (if (|| (== tok @TOK_INFIX) (== tok @TOK_POSTFIX))
        (= next_op (get_token_value))
        (do
            (unput)
            (= next_op (variant @OP_END 0))
        )
        )

    (while 1 (do
        (var comp (compare_associativity (car op_stack) next_op))
        (if (== comp 0) (goto parse_expr_end)
        (if (> comp 0) (do
            ; reduce
            (var op (car op_stack))
            (= op_stack (cdr op_stack))
            (= expr_stack (reduce op expr_stack))
            continue
            )
            (do
                (= op_stack (cons next_op op_stack))
                break
            )
            ))
        ))

    (if (== tok @TOK_INFIX) (goto parse_expr_front)
    (if (== tok @TOK_POSTFIX) (goto parse_expr_infix)
        ))

    (flush stdout)
    (output_string stderr "parse_expr: not implemented\n")
    (exit 1)

(label parse_expr_end)

    (var len (list_length expr_stack))
    (if (== len 0) (return 0))
    (if (> len 1) (do
        (flush stdout)
        (output_loc stderr)
        (output_string stderr "syntax error: irreducible expression\n")
        (exit 1)
        ))
    (return (car expr_stack))
    ))

(fun parse_primary (t) (
    (if (== t @TOK_CHAR) (return (variant @Char 0 (get_token_value)))
    (if (== t @TOK_INT) (return (variant @Int 0 (get_token_value)))
    (if (== t @TOK_FLOAT) (return (make_float_from_string (get_token_text)))
    (if (== t @TOK_STRING) (do
        ; remove double quotes
        (var str (get_token_text))
        (var len (- (get_token_len) 2))
        (var new (array char (+ len 1)))
        (strncpy new (+ str 1) len)
        (unescape_string new)
        (return (variant @String 1 new))
        )
    (if (== t @TOK_SYMBOL) (return (make_symbol (get_token_text)))
        )))))

    (flush stdout)
    (output_loc stderr)
    (output_int stderr t)
    (output_string stderr "syntax error: primary expression required\n")
    (exit 1)
    ))

(fun associativity (op) (
    (var type (field_get op 0))
    (if (== type @OP_PREFIX) (return (field_get op 2))
    (if (== type @OP_POSTFIX) (return (field_get op 2))
    (if (== type @OP_INFIX) (return (field_get op 3))
    (if (== type @OP_CONSTR) (return (field_get op 2))
    (if (== type @OP_START) (return 0)
    (if (== type @OP_END) (return 0)
        ))))))
    ))

(fun reduce (op exprs) (
    (var type (field_get op 0))
    (if (== type @OP_PREFIX)
        (return (cons (variant @Prefix 2 (field_get op 1) (car exprs)) (cdr exprs)))
    (if (== type @OP_POSTFIX)
        (return (cons (variant @Postfix 2 (field_get op 1) (car exprs)) (cdr exprs)))
    (if (== type @OP_INFIX)
        (return (cons (variant @Infix 3 (field_get op 1) (cadr exprs) (car exprs)) (cddr exprs)))
        )))
    ))

(fun compare_associativity (lop rop) (
    (var lassoc (associativity lop))
    (var rassoc (associativity rop))
    (if (!= lassoc rassoc) (return (- lassoc rassoc)))
    (var ltype (field_get lop 0))
    (var rtype (field_get rop 0))
    (if (== ltype @OP_START) (return 0))
    (if (&& (== ltype @OP_INFIX) (== rtype @OP_INFIX)) (do
        (var is_left_l (field_get lop 2))
        (var is_left_r (field_get rop 2))
        (if (== is_left_l is_left_r) (if is_left_l (return 1) (return -1)))
        ))
    ; XXX: output locatoin
    (flush stdout)
    (output_string stderr "ERROR: undecidable associativity\n")
    (exit 1)
    ))

(fun check_assoc (name assoc) (
    (if (> assoc 0) return)
    (output_string stderr "ERROR: associativity of operator '")
    (output_string stderr name)
    (output_string stderr "' must be positive\n")
    (exit 1)
    ))

(export fun add_prefix (name assoc) (
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (make_symbol name))
    (var prefix_op (variant @OP_PREFIX 1 sym assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 prefix_op (field_get op 2)))
            return
            ))
        ))
    (add_operator name prefix_op)
    ))

(export fun add_postfix (name assoc) (
    (check_assoc name assoc)
    (var sym (make_symbol name))
    (add_operator name (variant @OP_POSTFIX 1 sym assoc))
    ))

(export fun add_infixl (name assoc) ((add_infix name 1 assoc)))
(export fun add_infixr (name assoc) ((add_infix name 0 assoc)))

(fun add_infix (name is_left assoc) (
    (check_assoc name assoc)
    (var op (find_operator name))
    (var sym (make_symbol name))
    (var infix_op (variant @OP_INFIX 1 sym is_left assoc))
    (if op (do
        (var optype (field_get op 0))
        (if (== optype @OP_PREFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 op infix_op))
            return
            ))
        (if (== optype @OP_PREFIX_OR_INFIX) (do
            (add_operator name (variant @OP_PREFIX_OR_INFIX 2 (field_get op 1) infix_op))
            return
            ))
        ))
    (add_operator name infix_op)
    ))

    ))
