;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: stdlib.rlc 2010-06-08 23:00:48 nineties $
;

(var rewrite (macro (name params body) `(var @name (macro @params @body))))
(rewrite define (name params body) `(var @name (lambda @params @body)))

;=== aliases ===
(var otherwise true)

(var + add)
(var - sub)
(var * mul)
(var & bitand)
(var | bitor)
(var ^ bitxor)
(var == eq)
(var != ne)
(var < lt)
(var > gt)
(var <= le)
(var >= ge)

;=== utility ===
(define nil? (a) (if a nil true))
(var not nil?)

(rewrite incl (x) `(set @x (+ @x 1)))
(rewrite decl (x) `(set @x (- @x 1)))

(define [] (idx container)
    (cond
        ((string? container) (string_get container idx))
        ((array? container) (array_get container idx))
        (otherwise (eprintln "invalid container for operator [] : " container))
        ))

(rewrite and (lhs rhs) `(if @lhs @rhs nil))
(rewrite or  (lhs rhs) `(if @lhs true @rhs))

(define tos (val)
    (cond
        ((string? val) val)
        ((char? val)   (char2s val))
        ((int? val)    (int2s val))
        ((symbol? val) (symbol2s val))
        (otherwise (eprintln "invalid application of `tos` for " val))
        ))

(define ++ args (do
    (set args (map tos args))
    (sappend . args)
    ))

;=== loops ===
(rewrite foreach (it list body) `(do
    (var ls @list)
    (var last? nil)
    (while ls (do
        (var @it (car ls))
        (set last? (nil? (cdr ls)))
        @body
        (set ls (cdr ls))
        )
    )
    ))

(rewrite upto (it beg end body) `(do
    (var @it @beg)
    (var end_ @end)
    (while (<= @it end_) (do
        @body
        (set @it (+ @it 1))
        )
    )))

(rewrite downto (it beg end body) `(do
    (var @it @beg)
    (var end_ @end)
    (while (>= @it end_) (do
        @body
        (set @it (- @it 1))
        )
    )))

;=== list operations ===
(define cadr   (list) (car (cdr list)))
(define caddr  (list) (car (cdr (cdr list))))
(define cadddr (list) (car (cdr (cdr (cdr list)))))
(define caar   (list) (car (car list)))
(define cddr   (list) (cdr (cdr list)))
(define cdar   (list) (cdr (car list)))
(define nth    (idx list) (if (== idx 0) (car list) (nth (- idx 1) (cdr list))))

(rewrite setcar (list v) `(set @list (cons @v (cdr @list))))
(rewrite setcdr (list v) `(set @list (cons (car @list) @v)))

(rewrite push (list v) `(set @list (cons @v @list)))

(define member? (val list)
    (cond
        ((nil? list) nil)
        ((== val (car list)) true)
        (otherwise (member? val (cdr list)))
        ))

(define assoc (key list)
    (cond
        ((nil? list) nil)
        ((== key (caar list)) (cdar list))
        (otherwise (assoc key (cdr list)))
        )
    )

(define map (lam list) (if (nil? list) nil (cons (lam (car list)) (map lam (cdr list)))))

;=== I/O functions ===

(define println params (do
    (print . params)
    (print '\n')
    ))

(define eprintln params (do
    (eprint . params)
    (eprint '\n')
    ))
