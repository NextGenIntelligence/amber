;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vm.rlc 2010-05-29 17:47:23 nineties $
;

; generate assembly code of virtual machine

(import "stdlib")

; === utilities ==
(define not_reachable args (do (eprintln "not reachable here") (exit 1)))
(define not_implemented msgs (eprintln "not implemented '" (car msgs) "' : " . (cdr msgs)))

(define dispatch (dispatcher default code) (do
    (if (cons? code)
        (do
            (var head (car code))
            (var fun (assoc head dispatcher))
            (if fun
                (fun code)
                (do (eprintln "undefined code : " code) (exit 1))
            )
        )
        (default code)
    )))

(define emit_operand (val)
    (cond
        ((int? val)     (print '$' val))
        ((char? val)    (print "$'" val))
        ((== `%top val) (print "(%esp)"))
        ((symbol? val)  (print val))
        ((== `offset (car val)) (do
            (if (!= (caddr val) 0) (print (caddr val)))
            (print '(')
            (emit_operand (cadr val))
            (print ')')
            ))
        (true (not_implemented "emit_operand" val))
        ))

(define emit_label (name) (print name ":\n"))

(define emit args (do
    (print '\t' (car args))
    (set args (cdr args))
    (if args (print ' '))
    (while args (do
        (emit_operand (car args))
        (if (cdr args) (print ", "))
        (set args (cdr args)))
        )
    (print '\n')))

(define drop (len) (emit "addl" (* 4 len) `%esp))
(define movl  (src dst) (emit "movl" src dst))
(define movb  (src dst) (emit "movb" src dst))
(define pushl (val) (emit "pushl" val))
(define pushb (val) (emit "pushb" val))
(define popl  (reg) (emit "popl" reg))
(define popb  (reg) (emit "popb" reg))

; === compilation of expressions ==

(var insn_table `((+ . "addl") (- . "subl") (* . "imul") (neg . "negl")))
(define lookup_insn (op) (assoc op insn_table))

(define emit_return (return . arg) (do
    (if arg (emit_expr (car arg)))
    (emit "leave")
    (emit "ret")
    ))

(define emit_value (val)
    (cond
        ((int? val)  (pushl val))
        ((char? val) (pushb val))
        (true (not_implemented "emit_value" val))
        ))

(define emit_unexpr (code) (do
    (var insn (lookup_insn (car code)))
    (emit_expr (cadr code))
    (emit insn `%top)
    ))

(define emit_binexpr (code) (do
    (var insn (lookup_insn (car code)))
    (emit_expr (cadr code))
    (emit_expr (caddr code))
    (popl `%eax)
    (emit insn `%eax `%top)
    ))

(define emit_syscall ((syscall . args)) (do
    (var regs `(%eax %ebx %ecx %edx %esi %edi %ebp))
    (var narg (length args))
    (for r 4 (- narg 1) (pushl (nth r regs)))
    (foreach e args (emit_expr e))
    (for r 1 narg (movl `(offset %esp @(* 4 (- narg r))) (nth (- r 1) regs)))
    (drop narg)
    (emit "int" 128)
    ))

(var expr_dispatcher `(
    (syscall . @emit_syscall)
    (return . @emit_return)
    (+ . @emit_binexpr)
    (- . @emit_binexpr)
    (* . @emit_binexpr)
    ))

(define emit_expr (expr) (dispatch expr_dispatcher emit_value expr))

; === compilation of external declarations ===

(define emit_extern ((extern . (name))) (print ".global " name '\n'))

(define emit_static_int (code) (do
    (set code (cdr code)) ; skip 'int'
    (print (car code) ": .long ")
    (if (nil? (cdr code))
        (println 0)
        (println (cadr code))
        )
    ))

(define emit_function ((fun name params body)) (do
    (emit_label name)
    (foreach e body (emit_expr e))
    ))

(var extdecl_dispatcher `(
    (extern . @emit_extern)
    (int . @emit_static_int)
    (int* . @emit_static_int)
    (fun . @emit_function)
    ))

(define compile (prog) (do
    (foreach decl prog (dispatch extdecl_dispatcher not_reachable decl))
    ))

; === program of virtual machine ===

(var vmcode `(
    (extern _start)
    (fun _start () (
        (syscall 1 0)
        ))
    ))

; === compile the VM ===
(compile vmcode)
