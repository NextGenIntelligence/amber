;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vmgen.rlc 2010-06-02 09:08:35 nineties $
;

; a compiler for compiling virtual machine code

(import "stdlib")

; === utilities ==
(define not_reachable args (do (eprintln "not reachable here") (exit 1)))
(define not_implemented args (do
    (var msgs (cdr args))
    (eprintln "not implemented '" (car args) "' : "  . msgs)
    ))

(define dispatch (dispatcher default code) (do
    (if (cons? code)
        (do
            (var head (car code))
            (var fun (assoc head dispatcher))
            (if fun
                (fun code)
                (default code)
            )
        )
        (default code)
    )))

(var label_id 0)
(define mklabel (sym) (do (incl label_id) (tosym (++ sym '.' (- label_id 1)))))
(define print_label (sym) (print sym ":\n"))

(define escape (c)
    (cond
        ((== c '\n') "\\n")
        ((== c '\0') "\\0")
        ((== c '\a') "\\a")
        ((== c '\b') "\\b")
        ((== c '\f') "\\f")
        ((== c '\r') "\\r")
        ((== c '\t') "\\t")
        ((== c '\v') "\\v")
        (otherwise   c)))

(define emit_string (str) (do
    (print '"')
    (for i 0 (- (string_len str) 1) (print (escape ([] i str))))
    (print '"')
    ))

(define address? (type)
    (assoc type `((int . false) (string . true))))

(define emit_operand (opd)
    (cond
        ((int? opd)     (print '$' opd))
        ((== opd '\0')  (print "$0"))
        ((char? opd)    (print "$'" (escape opd)))
        ((== `%top opd) (print "(%esp)"))
        ((symbol? opd)  (print opd))
        ((== `var (car opd)) (do
            (var offs (cadr opd))
            (print (* -4 (+ offs 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `global (car opd)) (do
            (var type (cadr opd))
            (var sym  (caddr opd))
            (if (address? type) (print '$' sym) (print sym))
            ))
        ((== `arg (car opd)) (do
            (print (* 4 (+ (cadr opd) 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `offset (car opd)) (do
            (if (!= (caddr opd) 0) (print (caddr opd)))
            (print '(')
            (emit_operand (cadr opd))
            (print ')')
            ))
        ((== `label (car opd)) (do
            (print (cadr opd))
            (if (cddr opd) (do (print '.') (print (caddr opd))))
            ))
        (otherwise (not_implemented "emit_operand" opd))
        ))

(define emit args (do
    (print '\t' (car args))
    (set args (cdr args))
    (if args (print ' '))
    (while args (do
        (emit_operand (car args))
        (if (cdr args) (print ", "))
        (set args (cdr args)))
        )
    (print '\n')))

(define drop (len) (emit "addl" (* 4 len) `%esp))
(define movl  (src dst) (emit "movl" src dst))
(define movb  (src dst) (emit "movb" src dst))
(define pushl (val) (emit "pushl" val))
(define pushb (val) (do (emit "movb" val `%al) (emit "movzbl" `%al `%eax) (pushl `%eax)))
(define popl  (reg) (emit "popl" reg))
(define popb  (reg) (emit "popl" reg))

; === management of variables ===
(var vtable ())
(var vindex 0)
(define vtable_push () (set vtable (cons () vtable)))
(define vtable_pop  () (set vtable (cdr vtable)))

(define lookup_var_helper (sym) (do
    (define loop (sym tab)
        (if (nil? tab) nil (do
            (var v (assoc sym (car tab)))
            (if v v (loop sym (cdr tab)))
            )))
    (loop sym vtable)
    ))

(define lookup_var (sym) (do
    (var v (lookup_var_helper sym))
    (if v v (do (eprintln "undefined variable : " sym) (exit 1)))
    ))

(define variable? (sym) (lookup_var_helper sym))

(define add_var (name opd) (setcar vtable (cons `(@name . @opd) (car vtable))))

(var string_table ())
(define reset_string_table () (set string_table ()))
(define register_string (str) (do
    (var lbl (mklabel `str))
    (set string_table (cons `(@lbl @str) string_table))
    lbl
    ))

; === compilation of expressions ===

(var insn_table `((+ . "addl") (- . "subl") (* . "imul") (& . "andl") (| . "orl") (^ . "xorl") (neg . "negl")))
(define lookup_insn (op) (assoc op insn_table))

(define emit_return ((return . arg)) (do
    (if arg (emit_expr (car arg)))
    (popl `%eax)
    (emit "leave")
    (emit "ret")
    ))

(define emit_label ((label name . id)) (do
    (print name)
    (if id (print '.' (car id)))
    (print ":\n")
    ))

(define emit_directjump (opd) (emit "jmp" opd))
(define emit_indirectjump (opd) (do
    (emit_expr opd)
    (movl `%top `%eax)
    (drop 1)
    (emit "jmp" `*%eax)
    ))

(define emit_goto ((goto opd))
    (cond
        ((and (symbol? opd) (not (variable? opd))) (emit_directjump opd))
        ((and (cons? opd) (== `label (car opd)))   (emit_directjump opd))
        (otherwise (emit_indirectjump opd))
        ))

(define emit_expr_default (val)
    (cond
        ((int? val)  (pushl val))
        ((char? val) (pushb val))
        ((symbol? val) (pushl (lookup_var val)))
        ((string? val) (do
            (var sym (register_string val))
            (pushl `(global string @sym))
            ))
        (otherwise (not_implemented "emit_expr_default" val))
        ))

(define emit_deref8 ((*8 ptr)) (do
    (emit_expr ptr)
    (popl `%eax)
    (pushb `(offset %eax 0))
    ))

(define emit_unexpr ((op arg)) (do
    (var insn (lookup_insn op))
    (emit_expr arg)
    (emit insn `%top)
    ))

(define emit_binexpr ((op lhs rhs)) (do
    (var insn (lookup_insn op))
    (emit_expr lhs)
    (emit_expr rhs)
    (popl `%eax)
    (emit insn `%eax `%top)
    ))

(define emit_comparison ((op lhs rhs)) (do
    (var insn (assoc op `((== . "sete") (!= . "setne") (< . "setl") (> . "setg") (<= . "setle") (>= . "setge"))))
    (emit_expr lhs)
    (emit_expr rhs)
    (popl `%eax)
    (popl `%ebx)
    (emit "cmpl" `%eax `%ebx)
    (emit insn `%al)
    (emit "movzbl" `%al `%eax)
    (pushl `%eax)
    ))

(define emit_syscall ((syscall . args)) (do
    (var regs `(%eax %ebx %ecx %edx %esi %edi %ebp))
    (var narg (length args))
    (for r 4 (- narg 1) (pushl (nth r regs)))
    (foreach e args (emit_expr e))
    (for r 1 narg (movl `(offset %esp @(* 4 (- narg r))) (nth (- r 1) regs)))
    (drop narg)
    (emit "int" 0x80)
    (pushl `%eax)
    ))

(define emit_call ((call func . args))
    (if (symbol? func) (emit_directcall func args) (emit_indirectcall func args)))

(define emit_directcall (func args) (do
    (var narg (length args))
    (foreach e args (emit_expr e))
    (emit "call" `(label @func))
    (if (> narg 0) (emit "addl" (* 4 narg) `%esp))
    (pushl `%eax)
    ))

(define emit_def ((type v . init))
    (if init (do (emit_expr (car init)) (popl (lookup_var v)))))

(define emit_nop ((_nop_)) ())

(define emit_void ((void expr)) (do
    (emit_expr expr)
    (drop 1)
    ))

(define emit_incl ((_incl_ v)) (emit "incl" (lookup_var v)))

(define emit_asgn ((_asgn_ v e)) (do
    (emit_expr e)
    (popl (lookup_var v))
    ))

(define comparison? (op) (member op `(== != < > <= >=)))

(define emit_if ((_if_ expr ifthen . ifelse))
    (cond
        ((and (cons? expr) (== `! (car expr)))  (emit_unless (cadr expr) ifthen . ifelse))
        ((and (cons? expr) (== `&& (car expr))) (emit_seqand_if (cadr expr) (caddr expr) ifthen . ifelse))
        ((and (cons? expr) (== `|| (car expr))) (emit_seqor_if (cadr expr) (caddr expr) ifthen . ifelse))
        ((and (cons? expr) (comparison? (car expr))) (emit_cond_if expr ifthen . ifelse))
        (otherwise
            (do
                (var ifend-lbl (mklabel `end))
                (var ifelse-lbl (if ifelse (mklabel `ifelse) nil))
                (emit_expr expr)
                (popl `%eax)
                (emit "cmpl" 0 `%eax)
                (emit "je" (if ifelse-lbl ifelse-lbl ifend-lbl))
                (emit_block ifthen)
                (if ifelse-lbl (do (emit "jmp" ifend-lbl) (print_label ifelse-lbl) (emit_block (car ifelse))))
                (print_label ifend-lbl)
            )
        )))

(define emit_unless (expr ifthen . ifelse)
    (if ifelse
        (emit_expr `(if @expr @(car ifelse) @ifthen))
        (emit_expr `(if @expr ((nop)) @ifthen))
        ))

(define emit_seqand_if (expr1 expr2 ifthen . ifelse)
    (if ifelse
        (do
            (var ifend-lbl (mklabel `end))
            (emit_expr `(if @expr1 ((if @expr2 @(append @ifthen ((goto @ifend-lbl)))))))
            (emit_expr ifelse)
            (print_label ifend-lbl)
        )
        (emit_expr `(if @expr1 ((if @expr2 @ifthen))))
        ))

(define emit_seqor_if (expr1 expr2 ifthen . ifelse)
    (if ifelse
        (emit_expr `(if (&& (! @expr1) (! @expr2)) @ifthen @(car ifelse)))
        (do
            (var ifend-lbl (mklabel `end))
            (emit_expr `(if (&& (! @expr1) (! @expr2)) ((goto @ifend-lbl)) @ifthen))
            (print_label ifend-lbl)
        )
        ))

(define emit_cond_if (expr ifthen . ifelse) (do
    (var insn (assoc (car expr) `((== . "jne") (!= . "je") (< . "jge") (> . "jle") (<= . "jg") (>= . "jl"))))
    (var ifend-lbl (mklabel `end))
    (var ifelse-lbl (if ifelse (mklabel `ifelse) nil))
    (emit_expr (cadr expr))  ; lhs
    (emit_expr (caddr expr)) ; rhs
    (popl `%ebx)
    (popl `%eax)
    (emit "cmpl" `%eax `%ebx)
    (emit insn (if ifelse-lbl ifelse-lbl ifend-lbl))
    (emit_block ifthen)
    (if ifelse-lbl (do (emit "jmp" ifend-lbl) (print_label ifelse-lbl) (emit_block (car ifelse))))
    (print_label ifend-lbl)
    ))

(define emit_while ((_while_ expr body)) (do
    (var loop-lbl (mklabel `loop))
    (print_label loop-lbl)
    (emit_if `(if @expr @(append body `((goto @loop-lbl)))))
    ))

(var expr_dispatcher `(
    (nop     . @emit_nop)
    (void    . @emit_void)
    (syscall . @emit_syscall)
    (call    . @emit_call)
    (return  . @emit_return)
    (label   . @emit_label)
    (goto    . @emit_goto)
    (if      . @emit_if)
    (while   . @emit_while)
    (int     . @emit_def)
    (char    . @emit_def)
    (void*   . @emit_def)
    (*8      . @emit_deref8)
    (+       . @emit_binexpr)
    (-       . @emit_binexpr)
    (*       . @emit_binexpr)
    (&       . @emit_binexpr)
    (|       . @emit_binexpr)
    (^       . @emit_binexpr)
    (==      . @emit_comparison)
    (!=      . @emit_comparison)
    (<       . @emit_comparison)
    (>       . @emit_comparison)
    (<=      . @emit_comparison)
    (>=      . @emit_comparison)
    (asgn    . @emit_asgn)
    (incl    . @emit_incl)
    ))

(define emit_expr (expr) (dispatch expr_dispatcher emit_expr_default expr))

(define emit_block (block) (foreach e block (emit_expr e)))

; === compilation of external declarations ===

(define emit_extern ((extern . (name))) (print ".global " name '\n'))

(define emit_static_int ((int sym . init)) (do
    (print sym ": .long ")
    (if init
        (println (car init))
        (println 0))
    (add_var sym `(global int @sym))
    ))

(define emit_static_string ((string sym str)) (do
    (print_label sym)
    (print "\t.string ")
    (emit_string str)
    (print '\n')
    (add_var sym `(global string @sym))
    ))

(define emit_static_array ((type length name)) (do
    (var elemsz `((int[] . 4) (void*[] . 4) (char[] . 1) (byte[] . 1)))
    (println ".comm " name ", " (* length (assoc type elemsz)))
    ))

(var var_pos 0)
(define scan_defvar ((type v . init)) (do
    (var sz (assoc type `((int . 1) (char . 1) (int* . 1) (void* . 1))))
    (add_var v `(var @var_pos @sz))
    (set var_pos (+ var_pos sz))
    (if init (scan_expr init))
    ))

(define ignore (code) ())
(define scan_expr (e) (dispatch scan_function_dispatcher ignore e))

(define scan_function (body) (do
    (set var_pos 0)
    (foreach e body (scan_expr e))
    ))

(var scan_function_dispatcher `(
    (int . @scan_defvar)
    (char . @scan_defvar)
    (int* . @scan_defvar)
    (void* . @scan_defvar)
    ))

(define emit_function ((fun name params body)) (do
    (vtable_push)
    (reset_string_table)

    ; register parameters
    (var idx 1)
    (foreach p params (do (add_var p `(arg @idx)) (incl idx)))
    ; register variables
    (scan_function body)

    (print_label name)
    (pushl `%ebp)
    (movl `%esp `%ebp)

    ; allocate stack frame
    (if (> var_pos 0) (emit "subl" (* 4 var_pos) `%esp))

    (emit_block body)
    (emit_return `(return))

    (vtable_pop)

    (foreach ent string_table (emit_static_string `(string @(car ent) @(cadr ent))))
    ))

(var extdecl_dispatcher `(
    (extern  . @emit_extern)
    (int     . @emit_static_int)
    (string  . @emit_static_string)
    (int[]   . @emit_static_array)
    (char[]  . @emit_static_array)
    (void*[] . @emit_static_array)
    (fun     . @emit_function)
    ))

(define compile (prog) (foreach decl prog (dispatch extdecl_dispatcher not_reachable decl)))

; === compile the VM ===

(import "vm")

(vtable_push) ; global namespace
(compile vmcode)
(vtable_pop)
