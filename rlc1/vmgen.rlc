;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vmgen.rlc 2010-05-31 01:28:34 nineties $
;

; a compiler for compiling virtual machine code

(import "stdlib")

; === utilities ==
(define not_reachable args (do (eprintln "not reachable here") (exit 1)))
(define not_implemented args (do
    (var msgs (cdr args))
    (eprintln "not implemented '" (car args) "' : "  . msgs)
    ))

(define dispatch (dispatcher default code) (do
    (if (cons? code)
        (do
            (var head (car code))
            (var fun (assoc head dispatcher))
            (if fun
                (fun code)
                (default code)
            )
        )
        (default code)
    )))

(define emit_string (str) (do
    (print '"')
    (for i 0 (- (string_len str) 1) (do
        (var c ([] i str))
        (cond
            ((== c '\n') (print "\\n"))
            ((== c '\0') (print "\\0"))
            ((== c '\a') (print "\\a"))
            ((== c '\b') (print "\\b"))
            ((== c '\f') (print "\\f"))
            ((== c '\r') (print "\\r"))
            ((== c '\t') (print "\\t"))
            ((== c '\v') (print "\\v"))
            (true        (print c))
            )
        ))
    (print '"')
    ))

(define address? (type)
    (assoc type `((int . false) (string . true))))

(define emit_operand (opd)
    (cond
        ((int? opd)     (print '$' opd))
        ((char? opd)    (print "$'" opd))
        ((== `%top opd) (print "(%esp)"))
        ((symbol? opd)  (print opd))
        ((== `var (car opd)) (do
            (var offs (cadr opd))
            (print (* -4 (+ offs 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `global (car opd)) (do
            (var type (cadr opd))
            (var sym  (caddr opd))
            (if (address? type) (print '$' sym) (print sym))
            ))
        ((== `arg (car opd)) (do
            (print (* 4 (+ (cadr opd) 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `offset (car opd)) (do
            (if (!= (caddr opd) 0) (print (caddr opd)))
            (print '(')
            (emit_operand (cadr opd))
            (print ')')
            ))
        ((== `label (car opd)) (print (cadr opd)))
        (true (not_implemented "emit_operand" opd))
        ))

(define print_label (name) (print name ":\n"))

(define emit args (do
    (print '\t' (car args))
    (set args (cdr args))
    (if args (print ' '))
    (while args (do
        (emit_operand (car args))
        (if (cdr args) (print ", "))
        (set args (cdr args)))
        )
    (print '\n')))

(define drop (len) (emit "addl" (* 4 len) `%esp))
(define movl  (src dst) (emit "movl" src dst))
(define movb  (src dst) (emit "movb" src dst))
(define pushl (val) (emit "pushl" val))
(define pushb (val) (emit "pushb" val))
(define popl  (reg) (emit "popl" reg))
(define popb  (reg) (emit "popb" reg))

; === management of variables ===
(var vtable ())
(var vindex 0)
(define vtable_push () (set vtable (cons () vtable)))
(define vtable_pop  () (set vtable (cdr vtable)))

(define lookup_var_helper (sym) (do
    (define loop (sym tab)
        (if (nil? tab) nil (do
            (var v (assoc sym (car tab)))
            (if v v (loop sym (cdr tab)))
            )))
    (loop sym vtable)
    ))

(define lookup_var (sym) (do
    (var v (lookup_var_helper sym))
    (if v v (do (eprintln "undefined variable : " sym) (exit 1)))
    ))

(define variable? (sym) (lookup_var_helper sym))

(define add_var (name opd) (setcar vtable (cons `(@name . @opd) (car vtable))))

; === compilation of expressions ===

(var insn_table `((+ . "addl") (- . "subl") (* . "imul") (neg . "negl")))
(define lookup_insn (op) (assoc op insn_table))

(define emit_return ((return . arg)) (do
    (if arg (emit_expr (car arg)))
    (popl `%eax)
    (emit "leave")
    (emit "ret")
    ))

(define emit_label ((label name)) (print_label name))

(define emit_directjump (opd) (emit "jmp" opd))
(define emit_indirectjump (opd) (do
    (emit_expr opd)
    (movl `%top `%eax)
    (drop 1)
    (emit "jmp" `*%eax)
    ))

(define emit_goto ((goto opd))
    (if (symbol? opd)
        (if (variable? opd) (emit_indirectjump opd) (emit_directjump opd))
        (emit_indirectjump opd)
        ))


(define emit_value (val)
    (cond
        ((int? val)  (pushl val))
        ((char? val) (pushb val))
        ((symbol? val) (pushl (lookup_var val)))
        (true (not_implemented "emit_value" val))
        ))

(define emit_unexpr (code) (do
    (var insn (lookup_insn (car code)))
    (emit_expr (cadr code))
    (emit insn `%top)
    ))

(define emit_binexpr (code) (do
    (var insn (lookup_insn (car code)))
    (emit_expr (cadr code))
    (emit_expr (caddr code))
    (popl `%eax)
    (emit insn `%eax `%top)
    ))

(define emit_syscall ((syscall . args)) (do
    (var regs `(%eax %ebx %ecx %edx %esi %edi %ebp))
    (var narg (length args))
    (for r 4 (- narg 1) (pushl (nth r regs)))
    (foreach e args (emit_expr e))
    (for r 1 narg (movl `(offset %esp @(* 4 (- narg r))) (nth (- r 1) regs)))
    (drop narg)
    (emit "int" 0x80)
    (pushl `%eax)
    ))

(define emit_call ((call func args))
    (if (symbol? func) (emit_directcall func args) (emit_indirectcall func args)))

(define emit_directcall (func args) (do
    (var narg (length args))
    (foreach e args (emit_expr e))
    (emit "call" `(label @func))
    (if (> narg 0) (emit "addl" (* 4 narg) `%esp))
    (pushl `%eax)
    ))

(define emit_def ((type v . init))
    (if init
        (do
            (emit_expr (car init))
            (movl `%top `%eax)
            (movl `%eax (lookup_var v)))
        (pushl 0)
    ))

(var expr_dispatcher `(
    (syscall . @emit_syscall)
    (call    . @emit_call)
    (return  . @emit_return)
    (label   . @emit_label)
    (goto    . @emit_goto)
    (int     . @emit_def)
    (char    . @emit_def)
    (void*   . @emit_def)
    (+       . @emit_binexpr)
    (-       . @emit_binexpr)
    (*       . @emit_binexpr)
    ))

(define emit_expr (expr) (dispatch expr_dispatcher emit_value expr))

; === compilation of external declarations ===

(define emit_extern ((extern . (name))) (print ".global " name '\n'))

(define emit_static_int ((int sym . init)) (do
    (print sym ": .long ")
    (if init
        (println (car init))
        (println 0))
    (add_var sym `(global int @sym))
    ))

(define emit_static_string ((string sym str)) (do
    (print sym ": .string ")
    (emit_string str)
    (print '\n')
    (add_var sym `(global string @sym))
    ))

(define emit_static_array ((type length name)) (do
    (var elemsz `((int[] . 4) (void*[] . 4) (char[] . 1) (byte[] . 1)))
    (println ".comm " name ", " (* length (assoc type elemsz)))
    ))

(var var_pos 0)
(define scan_defvar ((type v . init)) (do
    (var sz (assoc type `((int . 1) (char . 1) (int* . 1) (void* . 1))))
    (add_var v `(var @var_pos @sz))
    (set var_pos (+ var_pos sz))
    (if init (scan_expr init))
    ))

(define ignore (code) ())
(define scan_expr (e) (dispatch scan_function_dispatcher ignore e))

(define scan_function (body) (do
    (set var_pos 0)
    (foreach e body (scan_expr e))
    ))

(var scan_function_dispatcher `(
    (int . @scan_defvar)
    (char . @scan_defvar)
    (int* . @scan_defvar)
    (void* . @scan_defvar)
    ))

(define emit_function ((fun name params body)) (do
    (vtable_push)

    ; register parameters
    (var idx 1)
    (foreach p params (do (add_var p `(arg @idx)) (incl idx)))
    ; register variables
    (scan_function body)

    (print_label name)
    (pushl `%ebp)
    (movl `%esp `%ebp)

    ; allocate stack frame
    (if (> var_pos 0) (emit "subl" (* 4 var_pos) `%esp))

    (foreach e body (do (emit_expr e) (drop 1)))
    (vtable_pop)
    ))

(var extdecl_dispatcher `(
    (extern  . @emit_extern)
    (int     . @emit_static_int)
    (string  . @emit_static_string)
    (int[]   . @emit_static_array)
    (char[]  . @emit_static_array)
    (void*[] . @emit_static_array)
    (fun     . @emit_function)
    ))

(define compile (prog) (foreach decl prog (dispatch extdecl_dispatcher not_reachable decl)))

; === compile the VM ===

(import "vm")

(vtable_push) ; global namespace
(compile vmcode)
(vtable_pop)
