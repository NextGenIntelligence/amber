;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vmgen.rlc 2010-06-04 01:12:24 nineties $
;

; a compiler for compiling virtual machine code

(import "stdlib")

; === utilities ===
(define not_reachable args (do (eprintln "not reachable here") (exit 1)))
(define not_implemented args (do
    (var msgs (cdr args))
    (eprintln "not implemented '" (car args) "' : "  . msgs)
    ))

(define dispatch (dispatcher default args) (do
    (if (cons? (car args))
        (do
            (var head (caar args))
            (var fun (assoc head dispatcher))
            (if fun
                (fun . args)
                (default . args)
            )
        )
        (default . args)
    )))

(var label_id 0)
(define mklabel (sym) (do (incl label_id) (tosym (++ sym '.' (- label_id 1)))))
(define print_label (sym) (print sym ":\n"))

(define escape (c)
    (cond
        ((== c '\n') "\\n")
        ((== c '\0') "\\0")
        ((== c '\a') "\\a")
        ((== c '\b') "\\b")
        ((== c '\f') "\\f")
        ((== c '\r') "\\r")
        ((== c '\t') "\\t")
        ((== c '\v') "\\v")
        (otherwise   c)))

(define emit_string (str) (do
    (print '"')
    (upto i 0 (- (string_len str) 1) (print (escape ([] i str))))
    (print '"')
    ))

(define address? (type) (assoc type `((int . @nil) (void* . @nil) (string . @true))))

(define emit_operand (opd)
    (cond
        ((int? opd)     (print '$' opd))
        ((== opd '\0')  (print "$0"))
        ((char? opd)    (print "$'" (escape opd)))
        ((== `%top opd) (print "(%esp)"))
        ((symbol? opd)  (print opd))
        ((== `var (car opd)) (do
            (var offs (cadr opd))
            (print (* -4 (+ offs 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `global (car opd)) (do
            (var type (cadr opd))
            (var sym  (caddr opd))
            (if (address? type) (print '$' sym) (print sym))
            ))
        ((== `arg (car opd)) (do
            (print (* 4 (+ (cadr opd) 1)))
            (print '(')
            (emit_operand `%ebp)
            (print ')')
            ))
        ((== `offset (car opd)) (do
            (if (!= (caddr opd) 0) (print (caddr opd)))
            (print '(')
            (emit_operand (cadr opd))
            (print ')')
            ))
        ((== `label (car opd)) (do
            (print (cadr opd))
            (if (cddr opd) (do (print '.') (print (caddr opd))))
            ))
        (otherwise (not_implemented "emit_operand" opd))
        ))

(define emit args (do
    (print '\t' (car args))
    (set args (cdr args))
    (if args (print ' '))
    (while args (do
        (emit_operand (car args))
        (if (cdr args) (print ", "))
        (set args (cdr args)))
        )
    (print '\n')))

(define lookup_8breg (reg) (assoc reg `((%eax . %al) (%ebx . %bl) (%ecx . %cl) (%edx . %dl))))
(define drop (len) (emit "addl" (* 4 len) `%esp))
(define movl  (src dst) (if (!= src dst) (emit "movl" src dst)))
(define movb (src dst)
    (cond
        ((int? src)     (emit "movb" src (lookup_8breg dst)))
        ((char? src)    (emit "movb" src (lookup_8breg dst)))
        (otherwise      (emit "movzbl" src dst))
        ))

(define pushl (val) (emit "pushl" val))
(define pushb (val) (do (emit "movb" val `%al) (emit "movzbl" `%al `%eax) (pushl `%eax)))
(define popl  (reg) (emit "popl" reg))
(define popb  (reg) (emit "popl" reg))

; === management of variables ===
(var vtable ())
(var vindex 0)
(define vtable_push () (set vtable (cons () vtable)))
(define vtable_pop  () (set vtable (cdr vtable)))

(define lookup_var_helper (sym) (do
    (define loop (sym tab)
        (if (nil? tab) nil (do
            (var v (assoc sym (car tab)))
            (if v v (loop sym (cdr tab)))
            )))
    (loop sym vtable)
    ))

(define lookup_var (sym) (do
    (var v (lookup_var_helper sym))
    (if v v (do (eprintln "undefined variable : " sym) (exit 1)))
    ))

(define variable? (sym) (lookup_var_helper sym))

(define add_var (name opd) (setcar vtable (cons `(@name . @opd) (car vtable))))

(var string_table ())
(define reset_string_table () (set string_table ()))
(define register_string (str) (do
    (var lbl (mklabel `str))
    (set string_table (cons `(@lbl @str) string_table))
    lbl
    ))

; === compilation of expressions ===

(var insn_table `((+ . "addl") (- . "subl") (* . "imul") (& . "andl") (| . "orl") (^ . "xorl") (neg . "negl")))
(define lookup_insn (op) (assoc op insn_table))

(define emit_return ((_ . arg) _ _) (do
    (if arg (emit_expr (car arg) `%eax nil))
    (emit "leave")
    (emit "ret")
    ))

(define emit_label ((label name . id)) (do
    (print name)
    (if id (print '.' (car id)))
    (print ":\n")
    ))

(define emit_directjump (opd) (emit "jmp" opd))
(define emit_indirectjump (opd) (do
    (emit_expr opd)
    (movl `%top `%eax)
    (emit "jmp" `*%eax)
    ))

(define emit_goto ((_ opd) _ _)
    (cond
        ((and (symbol? opd) (not (variable? opd))) (emit_directjump opd))
        ((and (cons? opd) (== `label (car opd)))   (emit_directjump opd))
        (otherwise (emit_indirectjump opd))
        ))

(var break_points ())
(define push_break_point () (set break_points (cons (mklabel `break) break_points)))
(define pop_break_point  () (set break_points (cdr break_points)))
(define break_point      () (car break_points))
(define emit_break_point () (print_label (break_point)))

(define emit_break ((_) _ _) (emit "jmp" (break_point)))

(define emit_expr_default (expr dst ret) (do
    (if (or dst (cons? expr))
        (cond
            ((int? expr)  (movl expr dst))
            ((char? expr) (movb expr dst))
            ((symbol? expr) (movl (lookup_var expr) dst))
            ((string? expr) (do
                (var sym (register_string expr))
                (movl `(global string @sym) dst)
                ))
            ((cons? expr) (emit_call `(call . @expr) dst nil))
            (otherwise (not_implemented "emit_expr_default" expr))
        ))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_deref8 ((*8 ptr) dst ret) (do
    (if dst (do
        (emit_expr ptr `%eax nil)
        (movb `(offset %eax 0) dst)
        ))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_unexpr ((op arg) dst ret) (do
    (var insn (lookup_insn op))
    (if dst
        (do
            (emit_expr arg dst nil)
            (emit insn dst)
        )
        (emit_expr arg nil nil)
        )
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_binexpr ((op lhs rhs) dst ret) (do
    (var insn (lookup_insn op))
    (if dst
        (do
            (emit_expr lhs `%eax nil)
            (pushl `%eax)
            (emit_expr rhs `%ebx nil)
            (popl dst)
            (emit insn `%ebx dst)
        )
        (do
            (emit_expr lhs nil nil)
            (emit_expr rhs nil nil)
        ))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_div ((_ lhs rhs) dst ret) (do
    (if dst
        (do
            (emit_expr lhs `%eax nil)
            (pushl `%eax)
            (emit_expr rhs `%ebx nil)
            (popl `%eax)
            (emit "xorl" `%edx `%edx)
            (emit "idiv" `%ebx)
            (movl `%eax dst)
        )
        (do
            (emit_expr lhs nil nil)
            (emit_expr rhs nil nil)
        ))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_mod ((_ lhs rhs) dst ret) (do
    (if dst
        (do
            (emit_expr lhs `%eax nil)
            (pushl `%eax)
            (emit_expr rhs `%ebx nil)
            (popl `%eax)
            (emit "xorl" `%edx `%edx)
            (emit "idiv" `%ebx)
            (movl `%edx dst)
        )
        (do
            (emit_expr lhs nil nil)
            (emit_expr rhs nil nil)
        ))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_comparison ((op lhs rhs)) (do
    (var insn (assoc op `((== . "sete") (!= . "setne") (< . "setl") (> . "setg") (<= . "setle") (>= . "setge"))))
    (emit_expr lhs)
    (emit_expr rhs)
    (popl `%eax)
    (popl `%ebx)
    (emit "cmpl" `%eax `%ebx)
    (emit insn `%al)
    (emit "movzbl" `%al `%eax)
    (pushl `%eax)
    ))

(define emit_syscall ((syscall . args) dst ret) (do
    (var regs `(%eax %ebx %ecx %edx %esi %edi %ebp))
    (var narg (length args))
    ; evaculate special purpose registers
    (upto r 4 (- narg 1) (pushl (nth r regs)))
    (foreach e args (do
        (emit_expr e `%eax nil)
        (pushl `%eax)
        ))
    (upto r 1 narg (movl `(offset %esp @(* 4 (- narg r))) (nth (- r 1) regs)))
    (drop narg)
    (emit "int" 0x80)
    (if dst (movl `%eax dst))
    ; restore special purpose registers
    (downto r (- narg 1) 4 (popl (nth r regs)))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_call ((call func . args) dst ret) (do
    (if (symbol? func) (emit_directcall func args dst) (emit_indirectcall func args dst))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_directcall (func args dst) (do
    (var narg (length args))
    (foreach e (reverse args) (do
        (emit_expr e `%eax nil)
        (pushl `%eax)
        ))
    (emit "call" `(label @func))
    (if (> narg 0) (emit "addl" (* 4 narg) `%esp))
    (if dst (movl `%eax dst))
    ))

(define emit_indirectcall (func args dst) (do
    (var narg (length args))
    (foreach e (reverse args) (do
        (emit_expr e `%eax nil)
        (pushl `%eax)
        ))
    (emit "call" `(label @func))
    (if (> narg 0) (emit "addl" (* 4 narg) `%esp))
    (if dst (movl `%eax dst))
    ))

(define emit_def ((type sym . init) dst ret) (do
    (var v (lookup_var sym))
    (if init (do (emit_expr (car init) `%eax nil) (movl `%eax v)))
    (if dst (movl v dst))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_nop ((_nop_) _ ret) (if ret (emit_return `(return) nil nil)))

(define emit_incldecl ((inst v) dst ret) (do
    (emit (if (== inst `incl) "incl" "decl") (lookup_var v))
    (if dst (movl (lookup_var v) dst))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_asgn ((_ v e) dst ret) (do
    (emit_expr e `%eax nil)
    (movl `%eax (lookup_var v))
    (if dst (movl `%eax dst))
    (if ret (emit_return `(return) nil nil))
    ))

(define emit_opasgn ((op v e) dst ret) (do
    (var bop (assoc op `((+= . +) (-= . -) (*= . *) (/= . /) (%= . %) (&= . &) (|= . |) (^= . ^))))
    (emit_expr `(= @v (@bop @v @e)) dst ret)
    ))

(define emit_arrasgn ((_ arr idx e) dst ret) (do
    (emit_expr arr `%eax nil)
    (pushl `%eax)
    (emit_expr idx `%eax nil)
    (emit "sall" 2 `%eax)
    (emit "addl" `%eax `%top)
    (emit_expr e `%eax nil)
    (popl `%ebx)
    (movl `%eax `(offset %ebx 0))
    (if dst (movl `%eax dst))
    (if ret (emit_return `(return) nil nil))
    ))

(define comparison? (op) (member op `(== != < > <= >=)))

(define emit_if ((_ expr ifthen . ifelse) dst ret) (do
    (set ifelse (if ifelse (car ifelse) nil))
    (cond
        ((and (cons? expr) (== `! (car expr)))  (emit_unless (cadr expr) ifthen ifelse dst ret))
        ((and (cons? expr) (== `&& (car expr))) (emit_seqand_if (cadr expr) (caddr expr) ifthen ifelse dst ret))
        ((and (cons? expr) (== `|| (car expr))) (emit_seqor_if (cadr expr) (caddr expr) ifthen ifelse dst ret))
        ((and (cons? expr) (comparison? (car expr))) (emit_cond_if expr ifthen ifelse dst ret))
        (otherwise
            (do
                (var ifend-lbl (mklabel `end))
                (var ifelse-lbl (if ifelse (mklabel `ifelse) nil))
                (emit_expr expr `%eax nil)
                (emit "cmpl" 0 `%eax)
                (emit "je" (if ifelse-lbl ifelse-lbl ifend-lbl))
                (emit_block ifthen ret)
                (if ifelse-lbl (do (emit "jmp" ifend-lbl) (print_label ifelse-lbl) (emit_block ifelse ret)))
                (print_label ifend-lbl)
            )
        ))
    ))

(define emit_unless (expr ifthen ifelse _ ret)
    (if ifelse
        (emit_expr `(if @expr @ifelse @ifthen) nil ret)
        (emit_expr `(if @expr ((nop)) @ifthen) nil ret)
        ))

(define emit_seqand_if (expr1 expr2 ifthen ifelse _ ret)
    (if ifelse
        (do
            (var ifend-lbl (mklabel `end))
            (emit_expr `(if @expr1 ((if @expr2 @(append @ifthen ((goto @ifend-lbl)))))) nil nil)
            (emit_expr ifelse)
            (print_label ifend-lbl)
            (if ret (emit_return `(return) nil nil))
        )
        (emit_expr `(if @expr1 ((if @expr2 @ifthen))) nil ret)
        ))

(define emit_seqor_if (expr1 expr2 ifthen ifelse _ ret)
    (if ifelse
        (emit_expr `(if (&& (! @expr1) (! @expr2)) @ifthen @ifelse) nil ret)
        (do
            (var ifend-lbl (mklabel `end))
            (emit_expr `(if (&& (! @expr1) (! @expr2)) ((goto @ifend-lbl)) @ifthen) nil nil)
            (print_label ifend-lbl)
            (if ret (emit_return `(return) nil nil))
        )
        ))

(define emit_cond_if (expr ifthen ifelse dst ret) (do
    (var insn (assoc (car expr) `((== . "jne") (!= . "je") (< . "jge") (> . "jle") (<= . "jg") (>= . "jl"))))
    (var ifend-lbl (mklabel `end))
    (var ifelse-lbl (if ifelse (mklabel `ifelse) nil))
    (emit_expr (cadr expr) `%eax nil)  ; lhs
    (pushl `%eax)
    (emit_expr (caddr expr) `%ebx nil) ; rhs
    (popl `%eax)
    (emit "cmpl" `%eax `%ebx)
    (emit insn (if ifelse-lbl ifelse-lbl ifend-lbl))
    (emit_block ifthen ret)
    (if ifelse-lbl (do (emit "jmp" ifend-lbl) (print_label ifelse-lbl) (emit_block ifelse ret)))
    (print_label ifend-lbl)
    ))

(define emit_while ((_ expr body) _ ret) (do
    (var loop-lbl (mklabel `loop))
    (print_label loop-lbl)
    (push_break_point)
    (emit_if `(if @expr @(append body `((goto @loop-lbl)))) nil nil)
    (emit_break_point)
    (pop_break_point)
    (if ret (emit_return `(return) nil nil))
    ))

; switch implementation using table jump
(define emit_tswitch ((_ expr body) _ ret) (do
    (var size (length body))
    (var table-lbl (mklabel `tbl))
    (var labels ())
    (upto i 1 size (set labels (cons (mklabel `case) labels)))
    (set labels (reverse labels))

    (emit_expr expr `%eax nil)
    (emit "sall" 2 `%eax)
    (movl `(offset %eax @table-lbl) `%eax)
    (emit "jmp" `*%eax)

    ; table area
    (change_area `rodata)
    (emit ".align 4")
    (emit ".align 4")
    (print_label table-lbl)
    (foreach l labels (emit ".long" l))

    ; code area
    (push_break_point)
    (var n 0)
    (change_area `text)
    (foreach case body (do
        (var idx (car case))
        (if (!= n idx) (do (eprintln "missing case label : " n) (exit 1)))
        (incl n)
        (print_label (car labels))
        (set labels (cdr labels))
        (emit_block (cadr case) nil)
        ))
    (emit_break_point)
    (pop_break_point)

    (if ret (emit_return `(return) nil nil))
    ))

(var expr_dispatcher `(
    (nop     . @emit_nop)
    (syscall . @emit_syscall)
    (call    . @emit_call)
    (return  . @emit_return)
    (label   . @emit_label)
    (goto    . @emit_goto)
    (break   . @emit_break)
    (if      . @emit_if)
    (while   . @emit_while)
    (tswitch . @emit_tswitch)
    (int     . @emit_def)
    (char    . @emit_def)
    (byte    . @emit_def)
    (void*   . @emit_def)
    (*8      . @emit_deref8)
    (fetch   . @emit_deref8)
    (+       . @emit_binexpr)
    (-       . @emit_binexpr)
    (*       . @emit_binexpr)
    (/       . @emit_div)
    (%       . @emit_mod)
    (&       . @emit_binexpr)
    (|       . @emit_binexpr)
    (^       . @emit_binexpr)
    (==      . @emit_comparison)
    (!=      . @emit_comparison)
    (<       . @emit_comparison)
    (>       . @emit_comparison)
    (<=      . @emit_comparison)
    (>=      . @emit_comparison)
    (=       . @emit_asgn)
    (+=      . @emit_opasgn)
    (-=      . @emit_opasgn)
    (*=      . @emit_opasgn)
    (/=      . @emit_opasgn)
    (%=      . @emit_opasgn)
    (&=      . @emit_opasgn)
    (|=      . @emit_opasgn)
    (^=      . @emit_opasgn)
    ([]=     . @emit_arrasgn)
    (incl    . @emit_incldecl)
    (decl    . @emit_incldecl)
    ))

(define emit_expr args (dispatch expr_dispatcher emit_expr_default args))

(define emit_block (block ret)
    (if (nil? block)
        (if ret (emit_return `(return) nil nil))
        (foreach e block (emit_expr e nil (and ret last?)))
        ))

; === compilation of external declarations ===

(var current_area `text)
(define emit_area (sym)
    (println (assoc sym `((text . ".section .text") (data . ".section .data") (rodata . ".section .rodata")))))
(define change_area (sym) (if (!= sym current_area) (do (emit_area sym) (set current_area sym))))

(define emit_extern ((extern . (name))) (print ".global " name '\n'))

(define emit_static_scalar ((type sym . init)) (do
    (change_area `data)
    (print_label sym)
    (print "\t.long ")
    (if init
        (println (car init))
        (println 0))
    (add_var sym `(global @type @sym))
    ))

(define emit_static_string ((_ sym str)) (do
    (change_area `rodata)
    (print_label sym)
    (print "\t.string ")
    (emit_string str)
    (print '\n')
    (add_var sym `(global string @sym))
    ))

(define emit_static_array ((type length sym)) (do
    (change_area `data)
    (var elemsz `((int[] . 4) (void*[] . 4) (char[] . 1) (byte[] . 1)))
    (println ".comm " sym ", " (* length (assoc type elemsz)))
    (add_var sym `(global @type @sym))
    ))

(var var_pos 0)
(define scan_defvar ((type v . init)) (do
    (var sz (assoc type `((int . 1) (char . 1) (byte . 1) (int* . 1) (void* . 1))))
    (add_var v `(var @var_pos @sz))
    (set var_pos (+ var_pos sz))
    (if init (scan_expr init))
    ))

(define ignore (code) ())
(define scan_expr (e) (dispatch scan_function_dispatcher ignore e))

(define scan_function (body) (do
    (set var_pos 0)
    (foreach e body (scan_expr `(@e)))
    ))

(var scan_function_dispatcher `(
    (int . @scan_defvar)
    (char . @scan_defvar)
    (byte . @scan_defvar)
    (int* . @scan_defvar)
    (void* . @scan_defvar)
    ))

(define emit_function ((_ name params body)) (do
    (vtable_push)
    (reset_string_table)

    ; register parameters
    (var idx 1)
    (foreach p params (do (add_var p `(arg @idx)) (incl idx)))
    ; register variables
    (scan_function body)

    (change_area `text)
    (print_label name)
    (pushl `%ebp)
    (movl `%esp `%ebp)

    ; allocate stack frame
    (if (> var_pos 0) (emit "subl" (* 4 var_pos) `%esp))

    (emit_block body true)

    (vtable_pop)

    (foreach ent string_table (emit_static_string `(string @(car ent) @(cadr ent))))
    ))

(var extdecl_dispatcher `(
    (extern  . @emit_extern)
    (int     . @emit_static_scalar)
    (void*   . @emit_static_scalar)
    (int*    . @emit_static_scalar)
    (string  . @emit_static_string)
    (int[]   . @emit_static_array)
    (char[]  . @emit_static_array)
    (void*[] . @emit_static_array)
    (fun     . @emit_function)
    ))

(define compile (prog) (foreach decl prog (dispatch extdecl_dispatcher not_reachable `(@decl))))

; === compile the VM ===


(vtable_push) ; global namespace
(import "vm-main")
(compile vm-main-code)
(import "vm-alloc")
(compile vm-alloc-code)
(import "vm-eval")
(compile vm-eval-code)
(vtable_pop)
