;
; rowl - generation 1
; Copyright (C) 2010 nineties
;
; $Id: vm-insn.rlc 2010-06-26 22:34:48 nineties $
;

(define gen_comparison1 (cmovname) `(
    (vmpop %eax)
    (asm "cmpl %edx, %eax")
    (asm "movl $3, %eax")
    (vmsword 1 %ebx)
    (asm @cmovname " %ebx, %eax")
    (vmsucc %eax)
    (vmfetch)))

(define gen_comparison2 (cmovname) `(
    (vmpop %eax)
    (vmpop %ebx)
    (asm "cmpl %eax, %ebx")
    (asm "movl $3, %eax")
    (vmsword 1 %ebx)
    (asm @cmovname " %ebx, %eax")
    (vmsucc %eax)
    (vmfetch)))

(define gen_get (idx) `(
    (asm "movl (%esi), %eax")
    (asm "movl " @(* 4 idx) "(%eax), %eax")
    (asm "movl %eax, (%esi)")
    ))

(define gen_set (idx) `(
    (vmubyte 1 %eax) ; index
    (asm "sall $2, %eax")
    (vmpop %ebx) ; obj
    (asm "addl %eax, %ebx")
    (asm "movl (%esi), %eax") ; value
    (asm "movl %eax, (%ebx)")
    ))

(var vm_instructions `(
    (nop        1 @true ())
    (exit       1 @true ((vmpop %eax) (break)))
    (imm_i0     1 @true ((vmpush %edx))) ; also used for 'nil'
    (imm_i1     1 @true ((vmpush $1)))
    (imm_i2     1 @true ((vmpush $2)))
    (imm_i3     1 @true ((vmpush $3)))
    (imm_i4     1 @true ((vmpush $4)))
    (imm_i5     1 @true ((vmpush $5)))
    (imm_im1    1 @true ((vmpush $-1)))
    (imm_int    3 @true ((vmsword 1 %eax) (vmpush %eax)))
    (iadd       1 @true ((vmbin "addl")))
    (isub       1 @true ((vmbin "subl")))
    (imul       1 @true ((vmpop %eax) (asm "imul (%esi), %eax") (asm "movl %eax, (%esi)")))
    (idiv       1 @true (
        (vmpop %ebx)
        (vmpop %eax)
        (asm "idiv %ebx")
        (vmpush %eax)
        (asm "xorl %edx, %edx") ; re-clear zero register
        ))
    (imod       1 @true (
        (vmpop %ebx)
        (vmpop %eax)
        (asm "idiv %ebx")
        (vmpush %edx)
        (asm "xorl %edx, %edx") ; re-clear zero register
        ))
    (goto       3 @nil  ((vmsword 1 %eax) (asm "addl %eax, %ecx") (vmfetch)))
    (if_zero    3 @nil  @(gen_comparison1 "cmovz"))
    (if_nonzero 3 @nil  @(gen_comparison1 "cmovnz"))
    (if_eq      3 @nil  @(gen_comparison2 "cmove"))
    (if_ne      3 @nil  @(gen_comparison2 "cmovne"))
    (if_gt      3 @nil  @(gen_comparison2 "cmovg"))
    (if_ge      3 @nil  @(gen_comparison2 "cmovge"))
    (if_lt      3 @nil  @(gen_comparison2 "cmovl"))
    (if_le      3 @nil  @(gen_comparison2 "cmovle"))
    (drop       1 @true ((asm "addl $4, %esi")))
    (drop2      1 @true ((asm "addl $8, %esi")))
    (dup        1 @true ((asm "movl (%esi), %eax") (vmpush %eax)))
    (call       4 @nil  (
        (asm "movl %ecx, %eax")
        (asm "addl $4, %eax")
        (vmpush %eax) ; store return point
        (vmpush %edi) ; store base pointer
        (vmsword 1 %eax) ; offset of address of the function
        (asm "movl %esi, %edi") ; set base pointer
        (asm "addl %eax, %ecx")
        (vmfetch)
        ))
    (extcall    4 @true ( ; 'extcall:1' 'index of the external function:2' 'size of arguments:1'
        (vmsave)
        (vmushort 1 %eax)
        (vmubyte 3 %ebx)
        (asm "pushl %esi") ; push argv
        (asm "pushl %ebx") ; push argc
        (asm "pushl %eax") ; push index
        (call vm_extcall)
        (asm "addl $12, %esp")
        (vmrestore)
        (vmubyte 3 %ebx) ; total size of arguments
        (asm "addl %ebx, %esi") ; remove arguments from stack
        (vmpush %eax) ; push return value
        ))
    (ireturn    1 @nil  (
        (asm "movl (%esi), %ebx") ; return value
        (asm "movl %edi, %esi")
        (vmpop %edi) ; base pointer
        (vmpop %ecx) ; return address
        (asm "movzbl -1(%ecx), %eax") ; total size of arguments
        (asm "addl %eax, %esi")
        (vmpush %ebx) ; push return value
        (vmfetch)
        ))
    (arg0 1 @true ((vmarg 0 %eax) (vmpush %eax)))
    (arg1 1 @true ((vmarg 1 %eax) (vmpush %eax)))
    (arg2 1 @true ((vmarg 2 %eax) (vmpush %eax)))
    (arg3 1 @true ((vmarg 3 %eax) (vmpush %eax)))
    (arg4 1 @true ((vmarg 4 %eax) (vmpush %eax)))
    (arg  2 @true (
        (vmubyte 1 %eax)
        (asm "addl $2, %eax")
        (asm "sall $2, %eax")
        (asm "addl %edi, %eax")
        (asm "movl (%eax), %eax")
        (vmpush %eax)
        ))
    (cons 1 @true (
        (vmsave)
        (call allocate_cons)
        (vmrestore)
        (vmpop %ebx)
        (asm "movl %ebx, 4(%eax)")
        (asm "movl (%esi), %ebx")
        (asm "movl %ebx, (%eax)")
        (asm "movl %eax, (%esi)")
        ))
    ; allocate plain object
    ; arg0 = size (in words)
    ; NB: allocated memory is not be zero-cleared
    (plain 1 @true (
        (asm "movl (%esi), %eax")
        (vmsave)
        (asm "pushl %eax")
        (call allocate_plain)
        (vmrestore)
        (asm "addl $4, %esp")
        (asm "movl %eax, (%esi)")
        ))
    (get0 1 @true @(gen_get 0)) ; also used for 'car'
    (get1 1 @true @(gen_get 1)) ; also used for 'cdr'
    (get2 1 @true @(gen_get 2))
    (get3 1 @true @(gen_get 3))
    (get4 1 @true @(gen_get 4))
    (get5 1 @true @(gen_get 5))
    (get  2 @true (
        (vmubyte 1 %eax)
        (asm "sall $2, %eax")
        (asm "movl (%esi), %ebx")
        (asm "addl %ebx, %eax")
        (asm "movl (%eax), %eax")
        (asm "movl %eax, (%esi)")
        ))
    ; set val obj
    (set0 1 @true @(gen_set 0))
    (set1 1 @true @(gen_set 1))
    (set2 1 @true @(gen_set 2))
    (set3 1 @true @(gen_set 3))
    (set4 1 @true @(gen_set 4))
    (set5 1 @true @(gen_set 5))
    (set  2 @true (
        (vmubyte 1 %eax) ; index
        (asm "sall $2, %eax")
        (vmpop %ebx) ; obj
        (asm "addl %eax, %ebx")
        (asm "movl (%esi), %eax")
        (asm "movl %eax, (%ebx)")
        ))
    (getbyte 3 @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movzbl (%eax), %eax")
        (vmpush %eax)
        ))
    (getword 3 @true (
        (vmushort 1 %eax)
        (asm "addl value_area_base, %eax")
        (asm "movl (%eax), %eax")
        (vmpush %eax)
        ))
    ))
