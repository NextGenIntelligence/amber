# Copyright (C) 2014 nineties
# $Id: Trait.ab 2014-02-26 11:05:26 nineties $

#= Trait system =
# In Amber, a 'Trait' is just a collection of methods for sharing their
# implementation among objects. You can define a trait named `A` with a
# method `f` by the following code.
# ----
# trait A {
#     .f(...): ...
# }
# ----
# The trait `A` is stored to the module `Trait`. So, an object `o` can
# implements `A.f` by `o.parent = Trait.A`.
#
# Traits can be defined by extending others. For example, to define
# tarit `A` by extending trait `B` and `C`, you can write as follows.
# ----
# trait A {
#     extend 'B, 'C
#     .f(...): ...
# }
# ----
# When `B` and `C` have functions with same name, they are fusioned and
# copied to `A`.
# Example:
# ----
# trait B {
#     .f(x @ Int): "integer"
# }
# trait C {
#     .f(x @ String): "string"
# }
# trait A {
#     extend 'B, 'C
# }
#
# Trait.A.f(0)          # => "integer"
# Trait.A.f("Hello")    # => "string"
# ----

TraitOfTraits: `Trait{Trait} with {
    .Trait?: true

    .extend_trait(...):
         throw `LogicError{"Traits can extend Trait{...} objects"}
    .extend_trait(from @ Trait{name}): {
        to: self

        if (from.has_slot?('before_extend))
            from.before_extend(to)
        from.each_slots((_, x, v) -> to.set_slot(x, v, fusion=true))
        if (from.has_slot?('after_extend))
            from.after_extend(to)
        self
    }

    .add_required_slot(attr): {
        if (attr.head == 'Apply)
            self.eval(
                `Define{!attr, {throw `MissingRequiredSlot{!self, !!attr}}}
                )
        else
            self.eval(
                `Define{!attr, alias(() ->
                    { throw `MissingRequiredSlot{!self, !!attr} })}
                )
        self
    }
}

nil.Trait?: false

extend(symbols...): {
    to: self
    Prim.list_foreach((s) -> to.extend_trait(
            Prim.get_slot(Trait, s, true, true, true)), symbols)
    self
}

require(attrs...): {
    to: self
    Prim.list_foreach((s) -> to.add_required_slot(s), attrs)
    self
}

# Create new trait named `name`.
new(name @ Symbol): {
    # When create trait `A`, an attribute `A?` is defined.
    name?: Prim.string_to_symbol(
            Prim.string_add(Prim.symbol_to_string(name), "?"))

    nil.set_slot(name?, false)
    `Trait{!name} with {
        .parent: TraitOfTraits
        .set_slot(name?, true)
    }
}

Syntax.add_reserved_symbols('trait)

stmt ::= trait symbol slot_assign
        {
            `{
                if (not Prim.has_slot?(Trait, '!$1, false))
                    Define{Slot{Trait, !$1}, Trait.new('!$1)}
                WithSlots{Slot{Trait, !$1}, !$2}
            }
         }
