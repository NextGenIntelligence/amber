# Copyright (C) 2014 nineties
# $Id: CAST/AST.ab 2014-03-19 19:33:38 nineties $

import PrettyPrint as PP
import Numeric.Bit as Bit

#= Abstract syntax tree for CAST =
#== Types ==
# A primitive type is just a symbol. We consulted primitive types of
# D language (http://dlang.org/type).

PRIM_TYPES: [
    'void,      # no type

    'char,      # unsigned 8-bit character
    'wchar,     # unsigned 16-bit character
    'dchar,     # unsigned 32-bit character

    'bool,      # boolean type
    'byte,      # signed 8-bit integer
    'ubyte,     # unsigned 8-bit integer
    'short,     # signed 16-bit integer
    'ushort,    # unsigned 16-bit integer
    'int,       # signed 32-bit integer
    'uint,      # unsigned 32-bit integer
    'long,      # signed 64-bit integer
    'ulong,     # unsigned 64-bit integer
    'float,     # 32-bit floating point number
    'double,    # 64-bit floating point number
    'real       # largest floating point number implemented in hardware
]

DERIVED_TYPES: [
    `PointerT{base_type},

    # `length` is a constant natural number represents the number of
    # elements. We restrict the length of an array to a constant number.
    `ArrayT{element_type, length},

    # `fields` is a list of `(name, value)`. The `value` must
    # be a constant literal.
    `EnumT{name, fields},

    # `params` is a list of `type`. `spec` contains
    # bit-flags `FUNC_SPEC.inline` and `FUNC_SPEC.const`.
    `FunctionT{return_type, params, spec},

    # `qual` contains bit-flags `QUALIFIER.const` and `QUALIFIER.volatile`.
    `QualifiedT{base_type, qual}
]

FUNC_SPEC: Bit.flags('inline, 'const)
QUALIFIER: Bit.flags('const, 'volatile)

set_type_qual(t, q): `QualifiedT{!t, !q}
set_type_qual(QualifiedT{t, q1}, q2): `QualifiedT{!t, !Bit.lor(q1, q2)}

# We do not support anonymous struct and union.
AGGREGATE_TYPES: [
    `StructT{name},
    `UnionT{name}
]

TYPES: PRIM_TYPES + DERIVED_TYPES + AGGREGATE_TYPES

#== Expressions ==

EXPRESSIONS: [
    # Constant literals.
    `Bool{t},           # `t` is one of symbols `true` or `false`.
    `CharL{c},          # `c` is an string.
    `IntL{num},         # `num` is an integer or a big integer.
    `FloatL{value},     # `value` is a **STRING** representation of floatingp oint number like "1.0".
    `StringL{string},

    # Variable.
    `Var{name},

    # Function call. `func` is an expression. `params` is a list of
    # expressions.
    `Call{func, params},

    # Array subscription
    `Subscript{ary, idx},

    # Member selection. `var` is an expression. `member` is a name of the
    # field.
    `Select{var, member},

    # Unary operations.
    `Uplus{expr},  # Unary plus
    `Uminus{expr}, # Unary minus
    `Deref{expr},
    `Addr{expr},
    `LNot{expr},
    `BNot{expr},
    `PreInc{expr},
    `PreDec{expr},
    `PostInc{expr},
    `PostDec{expr},

    # Binary operations.
    `Mul{lhs, rhs},
    `Div{lhs, rhs},
    `Mod{lhs, rhs},
    `Add{lhs, rhs},
    `Sub{lhs, rhs},
    `Shl{lhs, rhs},
    `Shr{lhs, rhs},
    `Lt{lhs, rhs},
    `Gt{lhs, rhs},
    `Le{lhs, rhs},
    `Ge{lhs, rhs},
    `Eq{lhs, rhs},
    `Ne{lhs, rhs},
    `BAnd{lhs, rhs},
    `BXor{lhs, rhs},
    `BOr{lhs, rhs},
    `LAnd{lhs, rhs},
    `LOr{lhs, rhs},
    `Assign{lhs, rhs},
    `Comma{lhs, rhs},

    # Type casting.
    `Cast{type, expr},

    # Ternary conditional expression.
    `Cond{test, ifthen, ifelse},

    `Sizeof{expr}
]

#== Statements ==

STATEMENTS: [
    `Block{stmts},

    `If{test, ifthen, ifelse},
    `While{test, body},
    `DoWhile{test, body},

    # We deprecate classical for-loops of C. Instead, we provide
    # upto-loop and downto-loop that iterate `body` with
    # incrementing/decrementing an index variable `idx` of type int in
    # range [begin, end).
    `Upto{idx, begin, end, body},
    `Downto{idx, begin, end, body},

    `Switch{test, body},
    `Case{label, stmt},
    `Label{label, stmt},

    `Goto{label},
    `Break{},
    `Continue{},

    # `value == nil` when the return-value is ommitted.
    `Return{value}
]

#== Declarations ==

DECLARATIONS: [
    # `storage` is a one of following symbols:
    # 'none, 'auto, 'static, 'exten and 'register.
    `DefFunc{storage, type, name, params, body},
    `DefVar{storage, type, name, value},

    # `fields` is a list of `(type, identifier)` which represents a field
    # for struct and union.
    `DefAggregates{storage, type, name, fields},

    # `fields` is a list of `(identifier, number)` which represents an
    # entry of the enum type. Assign `nil` for the number when it is not
    # specified.
    `DefEnum{type, fields},

    `DefType{type, name}
]

#== Directives ==

DIRECVIRES: [
    `Include{filename},
    `Define{name, value},
    `DirectCode{code}       # Insert any code into the current scope.
]

#= Parsing =

CAST.Syntax: Syntax.new() with {
    .add_reserved_word "true", "false"
    .add_reserved_word "void", "char", "wchar", "dchar", "bool", "byte",
                       "ubyte", "short", "ushort", "int", "uint", "long",
                       "ulong", "float", "double", "real", "function",
                       "string", "auto"
    .add_reserved_word "struct", "union", "enum"
    .add_reserved_word "return", "if", "else", "while", "do", "upto",
                       "downto", "switch", "case", "default", "goto",
                       "break", "continue"
    .add_reserved_word "typedef", "static", "extern", "const", "volatile"

    # Expressions

    .identifier ::= symbol_without_mark

    .constant
        ::= 'true               { throw parser.syntax.reserved_words; `BoolL{true} }
          | 'false              { `BoolL{false} }
          | integer             { `IntL{!$0} }
          | float               { `FloatL{!$0} }
          | "'" nospace(.) "'"  { `CharL{!$input} }

    .primary_expr
        ::= identifier          { `Var{!$0} }
          | constant
          | string              { `StringL{!$0} }
          | "(" expr ")"        { $1 }


    .postfix_expr
        ::= postfix_expr "[" expr "]"
            { `Subscript{!$0, !$2} }
          | postfix_expr "(" delimited(assign_expr, ",") ")"
            { `Call{!$0, !$2} }
          | postfix_expr "." identifier
            { `Select{!$0, !$2} }
          | postfix_expr "->" identifier
            { `Select{Deref{!$0}, !$2} }
          | postfix_expr "++"
            { `PostInc{!$0} }
          | postfix_expr "--"
            { `PostDec{!$0} }
          | primary_expr

    .unary_expr
        ::= "++" unary_expr         { `PreInc{!$1} }
          | "--" unary_expr         { `PreDec{!$1} }
          | "&"  cast_expr          { `Addr{!$1} }
          | "*"  cast_expr          { `Deref{!$1} }
          | "+"  cast_expr          { `Uplus{!$1} }
          | "-"  cast_expr          { `Uminus{!$1} }
          | 'sizeof unary_expr      { `Sizeof{!$1} }
          | 'sizeof "(" type ")"    { `Sizeof{!$2} }
          | postfix_expr

    .cast_expr
        ::= "(" type ")" cast_expr  { `Cast{!$1, !$3} }
          | unary_expr

    .multiplicative_expr
        ::= multiplicative_expr "*" cast_expr   { `Mul{!$0, !$2} }
          | multiplicative_expr "/" cast_expr   { `Div{!$0, !$2} }
          | multiplicative_expr "%" cast_expr   { `Mod{!$0, !$2} }
          | cast_expr

    .additive_expr
        ::= additive_expr "+" multiplicative_expr   { `Add{!$0, !$2} }
          | additive_expr "-" multiplicative_expr   { `Sub{!$0, !$2} }
          | multiplicative_expr

    .shift_expr
        ::= shift_expr "<<" additive_expr   { `Shl{!$0, !$2} }
          | shift_expr ">>" additive_expr   { `Shr{!$0, !$2} }
          | additive_expr

    .relational_expr
        ::= relational_expr "<" shift_expr  { `Lt{!$0, !$2} }
          | relational_expr ">" shift_expr  { `Gt{!$0, !$2} }
          | relational_expr "<=" shift_expr { `Le{!$0, !$2} }
          | relational_expr ">=" shift_expr { `Ge{!$0, !$2} }
          | shift_expr

    .equality_expr
        ::= equality_expr "==" relational_expr  { `Eq{!$0, !$2} }
          | equality_expr "!=" relational_expr  { `Ne{!$0, !$2} }
          | relational_expr

    .and_expr
        ::= and_expr "&" equality_expr  { `BAnd{!$0, !$2} }
          | equality_expr

    .xor_expr
        ::= xor_expr "^" and_expr   { `BXor{!$0, !$2} }
          | and_expr

    .or_expr
        ::= or_expr "|" xor_expr    { `BOr{!$0, !$2} }
          | xor_expr

    .logical_and_expr
        ::= logical_and_expr "&&" or_expr   { `LAnd{!$0, !$2} }
          | or_expr

    .logical_or_expr
        ::= logical_or_expr "||" logical_and_expr   {`LOr{!$0, !$2} }
          | logical_and_expr

    .conditional_expr
        ::= logical_or_expr "?" expr ":" conditional_expr
            { `Cond{!$0, !$2, !$4} }
          | logical_or_expr

    .assign_expr
        ::= unary_expr "="  assign_expr  { `Assign{!$0, !$2} }
          | unary_expr "+=" assign_expr  { `OpAssign{!$0, !$2, Add} }
          | unary_expr "-=" assign_expr  { `OpAssign{!$0, !$2, Sub} }
          | unary_expr "*=" assign_expr  { `OpAssign{!$0, !$2, Mul} }
          | unary_expr "/=" assign_expr  { `OpAssign{!$0, !$2, Div} }
          | unary_expr "%=" assign_expr  { `OpAssign{!$0, !$2, Mod} }
          | unary_expr "<<=" assign_expr { `OpAssign{!$0, !$2, Shl} }
          | unary_expr ">>=" assign_expr { `OpAssign{!$0, !$2, Shr} }
          | unary_expr "&=" assign_expr  { `OpAssign{!$0, !$2, BAnd} }
          | unary_expr "^=" assign_expr  { `OpAssign{!$0, !$2, BXor} }
          | unary_expr "|=" assign_expr  { `OpAssign{!$0, !$2, BOr} }
          | conditional_expr

    .expr
        ::= expr "," assign_expr    { `Comma{!$0, !$2} }
          | assign_expr

    .constant_expr ::= conditional_expr

    # Types
    .base_type ::= 'void | 'char | 'wchar | 'dchar | 'bool | 'byte |
                   'ubyte | 'short | 'ushort | 'int | 'uint | 'long |
                   'ulong | 'float | 'double | 'real
                 | 'auto
                 | 'struct identifier   { `StructT{!$1} }
                 | 'union identifier    { `UnionT{!$1} }
                 | 'enum identifier     { `EnumT{!$1} }

    .primary_type ::= "(" type ")"    { $1 }
                    | base_type

    .postfix_type ::= postfix_type  "[" constant_expr "]"
                      { `ArrayT{!$0, !$2} }
                    | postfix_type "*"
                      { `PointerT{!$0} }
                    | postfix_type "(" delimited(type, ",") ")"
                      { `FunctionT{!$0, !$2, 0} }
                    | primary_type

    .type ::= 'const type       { set_type_qual($1, QUALIFIER.const) }
            | 'volatile type    { set_type_qual($1, QUALIFIER.volatile) }
            | postfix_type

     # Statements
    .storage ::= 'auto
               | 'static
               | 'extern
               | 'register
               |            { `none }

    .initializer
            ::= "{" delimited(initializer, ",") "}"
                { `InitializerList{!$1} }
              | assign_expr

    .struct_union_field ::= type identifier ";" { ($0, $1) }
    .enum_field ::= identifier "=" constant_expr { ($0, $2) }
                  | identifier                   { ($0, nil) }

    .decl ::= storage type identifier "=" initializer
              { `DefVar{!$0, !$1, !$2, !$4} }
            | 'typedef type identifier
              { `DefType{!$1, !$2} }
            | storage 'struct identifier "{" struct_union_field* "}"
              { `DefAggregates{!$0, StructT{!$2}, !$2, !$4} }
            | storage 'union identifier "{" struct_union_field* "}"
              { `DefAggregates{!$0, Union{!$2}, !$2, !$4} }
            | 'enum identifier "{" delimited(enum_field, ",") "}"
              { `DefEnum{!$1, !$3} }

    .stmt ::= identifier ":" stmt           { `Label{!$0, !$2} }
            | 'case constant_expr ":" stmt  { `Case{!$1, !$3} }
            | 'default ":" stmt             { `Case{default, !$2} }
            | "{" block_item* "}"           { `Block{!$1} }
            | expr ";"                      { $0 }
            | 'if "(" expr ")" stmt 'else stmt
              { `If{!$2, !$4, !$6} }
            | 'if "(" expr ")" stmt
              { `If{!$2, !$4, nil} }
            | 'switch "(" expr ")" stmt
              { `Switch{!$2, !$4} }
            | 'while "(" expr ")" stmt
              { `While{!$2, !$4} }
            | 'do stmt 'while "(" expr ")" ";"
              { `DoWhile{!$4, !$1} }
            | 'upto "(" identifier "," expr "," expr ")" stmt
              { `Upto{!$2, !$4, !$6, !$8} }
            | 'downto "(" identifier "," expr "," expr ")" stmt
              { `Downto{!$2, !$4, !$6, !$8} }
            | 'goto identifier ";"
              { `Goto{!$1} }
            | 'continue ";"
              { `Continue{} }
            | 'break ";"
              { `Break{} }
            | 'return expr? ";"
              { `Return{!$1} }

    .function_decl
        ::= storage type identifier "(" delimited(parameter, ",") ")"
            "{" block_item* "}"
            { `DefFunc{!$0, !$1, !$2, !$4, !$7} }

    .program ::= (function_decl/decl)*  { `CASTProgram{!$0} }
}
