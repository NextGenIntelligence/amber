# Copyright (C) 2014 nineties
# $Id: CAST/AST.ab 2014-03-18 00:14:36 nineties $

import PrettyPrint as PP
import Numeric.Bit as Bit

#= Abstract syntax tree for CAST =
#== Types ==
# A primitive type is just a symbol. We consulted primitive types of
# D language (http://dlang.org/type).

PRIM_TYPES: [
    'void,      # no type

    'char,      # unsigned 8-bit character
    'wchar,     # unsigned 16-bit character
    'dchar,     # unsigned 32-bit character

    'bool,      # boolean type
    'byte,      # signed 8-bit integer
    'ubyte,     # unsigned 8-bit integer
    'short,     # signed 16-bit integer
    'ushort,    # unsigned 16-bit integer
    'int,       # signed 32-bit integer
    'uint,      # unsigned 32-bit integer
    'long,      # signed 64-bit integer
    'ulong,     # unsigned 64-bit integer
    'float,     # 32-bit floating point number
    'double,    # 64-bit floating point number
    'real       # largest floating point number implemented in hardware
]

DERIVED_TYPES: [
    `PointerT{base_type},

    # `length` is a constant natural number represents the number of
    # elements. We restrict the length of an array to a constant number.
    `ArrayT{element_type, length},

    # `fields` is a list of `(name, value)`. The `value` must
    # be a constant literal.
    `EnumT{name, fields},

    # `params` is a list of `(type, name)`. `spec` contains
    # bit-flags `FUNC_SPEC.inline` and `FUNC_SPEC.const`.
    `FunctionT{return_type, params, spec},

    # `qual` contains bit-flags `QUALIFIER.const` and `QUALIFIER.volatile`.
    `QualifiedT{base_type, qual}
]

FUNC_SPEC: Bit.flags('inline, 'const)
QUALIFIER: Bit.flags('const, 'volatile)

# We do not support anonymous struct and union.
AGGREGATE_TYPES: [
    `StructT{name},
    `UnionT{name}
]

TYPES: PRIM_TYPES + DERIVED_TYPES + AGGREGATE_TYPES

#== Expressions ==

EXPRESSIONS: [
    # Constant literals.
    `Bool{t},           # `t` is one of symbols `true` or `false`.
    `CharL{c},          # `c` is an string.
    `IntL{num},         # `num` is an integer or a big integer.
    `FloatL{value},     # `value` is a **STRING** representation of floatingp oint number like "1.0".
    `StringL{string},

    # Variable.
    `Var{name},

    # Function call. `func` is an expression. `params` is a list of
    # expressions.
    `Call{func, params},

    # Array subscription
    `Subscript{ary, idx},

    # Member selection. `var` is an expression. `member` is a name of the
    # field.
    `Select{var, member},

    # Unary operations.
    `Uplus{expr},  # Unary plus
    `Uminus{expr}, # Unary minus
    `Deref{expr},
    `Addr{expr},
    `LNot{expr},
    `BNot{expr},
    `PreInc{expr},
    `PreDec{expr},
    `PostInc{expr},
    `PostDec{expr},

    # Binary operations.
    `Mul{lhs, rhs},
    `Div{lhs, rhs},
    `Mod{lhs, rhs},
    `Add{lhs, rhs},
    `Sub{lhs, rhs},
    `Shl{lhs, rhs},
    `Shr{lhs, rhs},
    `Lt{lhs, rhs},
    `Gt{lhs, rhs},
    `Le{lhs, rhs},
    `Ge{lhs, rhs},
    `Eq{lhs, rhs},
    `Ne{lhs, rhs},
    `BAnd{lhs, rhs},
    `BXor{lhs, rhs},
    `BOr{lhs, rhs},
    `LAnd{lhs, rhs},
    `LOr{lhs, rhs},
    `Assign{lhs, rhs},
    `Comma{lhs, rhs},

    # Type casting.
    `Cast{type, expr},

    # Ternary conditional expression.
    `Cond{test, ifthen, ifelse},

    `Sizeof{expr}
]

#== Statements ==

STATEMENTS: [
    # `decls` is a list of declarations and `stmts` is a list of statements.
    `Block{decls, stmts},

    `If{test, ifthen, ifelse},
    `While{test, body},
    `DoWhile{test, body},

    # We deprecate classical for-loops of C. Instead, we provide
    # upto-loop and downto-loop that iterate `body` with
    # incrementing/decrementing an index variable `idx` of type int in
    # range [begin, end).
    `Upto{idx, begin, end, body},
    `Downto{idx, begin, end, body},

    `Switch{test, body},
    `Case{label, stmt},
    `Label{label, stmt},

    `Null{},
    `Break{},
    `Continue{}
]

#== Declarations ==

DECLARATIONS: [
    # `storage` is a one of following symbols:
    # 'none, 'auto, 'static, 'exten and 'register.
    `DefFunc{storage, type, body},
    `DefVar{storage, type, name, value},
    `DefAggregates{storage, type, name, subs},
    `Typedef{name, type}
]

#== Directives ==

DIRECVIRES: [
    `Include{filename},
    `Define{name, value},
    `DirectCode{code}       # Insert any code into the current scope.
]

#= Parsing =

CAST.Syntax: Syntax.new() with {
    .add_reserved_word(true, false)

    .identifier ::= symbol_without_mark

    .constant
        ::= 'true               { throw parser.syntax.reserved_words; `BoolL{true} }
          | 'false              { `BoolL{false} }
          | integer             { `IntL{!$0} }
          | float               { `FloatL{!$0} }
          | "'" nospace(.) "'"  { `CharL{!$input} }

    .primary_expr
        ::= identifier          { `Var{!$0} }
          | constant
          | string              { `StringL{!$0} }
          | "(" expr ")"        { $1 }


    .postfix_expr
        ::= postfix_expr "[" expr "]"
            { `Subscript{!$0, !$2} }
          | postfix_expr "(" delimited(assign_expr, ",") ")"
            { `Call{!$0, !$2} }
          | postfix_expr "." identifier
            { `Select{!$0, !$2} }
          | postfix_expr "->" identifier
            { `Select{Deref{!$0}, !$2} }
          | postfix_expr "++"
            { `PostInc{!$0} }
          | postfix_expr "--"
            { `PostDec{!$0} }
          | primary_expr

    .unary_expr
        ::= "++" unary_expr         { `PreInc{!$1} }
          | "--" unary_expr         { `PreDec{!$1} }
          | "&"  cast_expr          { `Addr{!$1} }
          | "*"  cast_expr          { `Deref{!$1} }
          | "+"  cast_expr          { `Uplus{!$1} }
          | "-"  cast_expr          { `Uminus{!$1} }
          | 'sizeof unary_expr      { `Sizeof{!$1} }
          | 'sizeof "(" type ")"    { `Sizeof{!$2} }
          | postfix_expr

    .cast_expr
        ::= "(" type ")" cast_expr  { `Cast{!$1, !$3} }
          | unary_expr

    .multiplicative_expr
        ::= multiplicative_expr "*" cast_expr   { `Mul{!$0, !$2} }
          | multiplicative_expr "/" cast_expr   { `Div{!$0, !$2} }
          | multiplicative_expr "%" cast_expr   { `Mod{!$0, !$2} }
          | cast_expr

    .additive_expr
        ::= additive_expr "+" multiplicative_expr   { `Add{!$0, !$2} }
          | additive_expr "-" multiplicative_expr   { `Sub{!$0, !$2} }
          | multiplicative_expr

    .shift_expr
        ::= shift_expr "<<" additive_expr   { `Shl{!$0, !$2} }
          | shift_expr ">>" additive_expr   { `Shr{!$0, !$2} }
          | additive_expr

    .relational_expr
        ::= relational_expr "<" shift_expr  { `Lt{!$0, !$2} }
          | relational_expr ">" shift_expr  { `Gt{!$0, !$2} }
          | relational_expr "<=" shift_expr { `Le{!$0, !$2} }
          | relational_expr ">=" shift_expr { `Ge{!$0, !$2} }
          | shift_expr

    .equality_expr
        ::= equality_expr "==" relational_expr  { `Eq{!$0, !$2} }
          | equality_expr "!=" relational_expr  { `Ne{!$0, !$2} }
          | relational_expr

    .and_expr
        ::= and_expr "&" equality_expr  { `BAnd{!$0, !$2} }
          | equality_expr

    .xor_expr
        ::= xor_expr "^" and_expr   { `BXor{!$0, !$2} }
          | and_expr

    .or_expr
        ::= or_expr "|" xor_expr    { `BOr{!$0, !$2} }
          | xor_expr

    .logical_and_expr
        ::= logical_and_expr "&&" or_expr   { `LAnd{!$0, !$2} }
          | or_expr

    .logical_or_expr
        ::= logical_or_expr "||" logical_and_expr   {`LOr{!$0, !$2} }
          | logical_and_expr

    .conditional_expr
        ::= logical_or_expr "?" expr ":" conditional_expr
            { `Cond{!$0, !$2, !$4} }
          | logical_or_expr

    .assign_expr
        ::= unary_expr "="  assign_expr { `Assign{!$0, !$2} }
          | unary_expr "+=" assign_expr { `OpAssign{!$0, !$2, Add} }
          | unary_expr "-=" assign_expr { `OpAssign{!$0, !$2, Sub} }
          | unary_expr "*=" assign_expr { `OpAssign{!$0, !$2, Mul} }
          | unary_expr "/=" assign_expr { `OpAssign{!$0, !$2, Div} }
          | unary_expr "%=" assign_expr { `OpAssign{!$0, !$2, Mod} }
          | unary_expr "<=" assign_expr { `OpAssign{!$0, !$2,< Shl} }
          | unary_expr ">=" assign_expr { `OpAssign{!$0, !$2,> Shr} }
          | unary_expr "&=" assign_expr { `OpAssign{!$0, !$2, BAnd} }
          | unary_expr "^=" assign_expr { `OpAssign{!$0, !$2, BXor} }
          | unary_expr "|=" assign_expr { `OpAssign{!$0, !$2, BOr} }
          | conditional_expr

    .expr
        ::= expr "," assign_expr    { `Comma{!$0, !$2} }
          | assign_expr

    .constant_expr ::= conditional_expr
}

#= Pretty printing =
