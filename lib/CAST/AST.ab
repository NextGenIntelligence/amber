# Copyright (C) 2014 nineties
# $Id: CAST/AST.ab 2014-03-17 16:29:22 nineties $

import PrettyPrint as PP
import Numeric.Bit as Bit

#= Abstract syntax tree for CAST =
#== Types ==
# A primitive type is just a symbol. We consulted primitive types of
# D language (http://dlang.org/type).

PRIM_TYPES: [
    'void,      # no type

    'char,      # unsigned 8-bit character
    'wchar,     # unsigned 16-bit character
    'dchar,     # unsigned 32-bit character

    'bool,      # boolean type
    'byte,      # signed 8-bit integer
    'ubyte,     # unsigned 8-bit integer
    'short,     # signed 16-bit integer
    'ushort,    # unsigned 16-bit integer
    'int,       # signed 32-bit integer
    'uint,      # unsigned 32-bit integer
    'long,      # signed 64-bit integer
    'ulong,     # unsigned 64-bit integer
    'float,     # 32-bit floating point number
    'double,    # 64-bit floating point number
    'real       # largest floating point number implemented in hardware
]

DERIVED_TYPES: [
    `PointerT{base_type},

    # `length` is a constant natural number represents the number of
    # elements. We restrict the length of an array to a constant number.
    `ArrayT{element_type, length},

    # `fields` is a list of `(name, value)`. The `value` must
    # be a constant literal.
    `EnumT{name, fields},

    # `params` is a list of `(type, name)`. `spec` contains
    # bit-flags `FUNC_SPEC.inline` and `FUNC_SPEC.const`.
    `FunctionT{return_type, params, spec},

    # `qual` contains bit-flags `QUALIFIER.const` and `QUALIFIER.volatile`.
    `QualifiedT{base_type, qual}
]

FUNC_SPEC: Bit.flags('inline, 'const)
QUALIFIER: Bit.flags('const, 'volatile)

# We do not support anonymous struct and union.
AGGREGATE_TYPES: [
    `StructT{name},
    `UnionT{name}
]

TYPES: PRIM_TYPES + DERIVED_TYPES + AGGREGATE_TYPES

#== Expressions ==

EXPRESSIONS: [
    # Constant literals.
    `Bool{t},           # `t` is one of symbols `true` or `false`.
    `CharL{c},          # `c` is an string.
    `IntL{num},         # `num` is an integer or a big integer.
    `FloatL{value},     # `value` is a **STRING** representation of floatingp oint number like "1.0".
    `StringL{string},

    # Variable.
    `Var{name},

    # Function call. `func` is an expression. `params` is a list of
    # expressions.
    `Call{func, params},

    # Member selection. `var` is an expression. `member` is a name of the
    # field.
    `Select{var, member},

    # Unary operations.
    `Deref{expr},
    `Addr{expr},
    `LNot{expr},
    `BNot{expr},
    `PreInc{expr},
    `PreDec{expr},
    `PostInc{expr},
    `PostDec{expr},

    # Binary operations.
    `Mul{lhs, rhs},
    `Div{lhs, rhs},
    `Mod{lhs, rhs},
    `Add{lhs, rhs},
    `Sub{lhs, rhs},
    `Shl{lhs, rhs},
    `Shr{lhs, rhs},
    `Lt{lhs, rhs},
    `Gt{lhs, rhs},
    `Le{lhs, rhs},
    `Ge{lhs, rhs},
    `Eq{lhs, rhs},
    `Ne{lhs, rhs},
    `BAnd{lhs, rhs},
    `BXor{lhs, rhs},
    `BOr{lhs, rhs},
    `LAnd{lhs, rhs},
    `LOr{lhs, rhs},
    `Assign{lhs, rhs},
    `Comma{lhs, rhs},

    # Type casting.
    `Cast{type, expr},

    # Ternary conditional expression.
    `Cond{test, ifthen, ifelse},

    `Sizeof{expr}
]

#== Statements ==

STATEMENTS: [
    # `decls` is a list of declarations and `stmts` is a list of statements.
    `Block{decls, stmts},

    `If{test, ifthen, ifelse},
    `While{test, body},
    `DoWhile{test, body},

    # We deprecate classical for-loops of C. Instead, we provide
    # upto-loop and downto-loop that iterate `body` with
    # incrementing/decrementing an index variable `idx` of type int in
    # range [begin, end).
    `Upto{idx, begin, end, body},
    `Downto{idx, begin, end, body},

    `Switch{test, body},
    `Case{label, stmt},
    `Label{label, stmt},

    `Null{},
    `Break{},
    `Continue{}
]

#== Declarations ==

DECLARATIONS: [
    # `storage` is a one of following symbols:
    # 'none, 'auto, 'static, 'exten and 'register.
    `DefFunc{storage, type, body},
    `DefVar{storage, type, name, value},
    `DefAggregates{storage, type, name, subs},
    `Typedef{name, type}
]

#== Directives ==

DIRECVIRES: [
    `Include{filename},
    `Define{name, value},
    `DirectCode{code}       # Insert any code into the current scope.
]

#= Parsing =

CAST.Syntax: Syntax.new() with {
    .add_reserved_word(true, false)

    .literal
        ::= true                { `BoolL{true} }
          | false               { `BoolL{false} }
          | integer             { `IntL{!$0} }
          | float               { `FloatL{!$0} }
          | string              { `StringL{!$0} }
          | "'" nospace(.) "'"  { `CharL{!$input} }
}

#= Pretty printing =
