# Copyright (C) 2014 nineties
# $Id: Container.ab 2014-02-06 14:59:21 nineties $

import Numeric

ContainerTrait: `Trait{Container} with {

    empty?() = self.size == 0

    each() = {
        seq: self
        i: 0
        () -> {
            if (i < seq.size) {
                i += 1
                return seq[i-1]
            }
            return undef
        }
    }

    each(callback @ Function) = {
        iter: self.each()
        v: iter()
        while (v != undef) {
            callback(v)
            v = iter()
        }
    }
    
    to_array() = {
        a: Array.new()
        for (v in self)
            a.push(v)
        a
    }
    
    to_list() = {
        l: []
        for (v in self)
            l = cons(v, l)
        l.reverse()
    }
    
    all?(pred) = {
        for (v in self)
            if (not pred(v))
                return false
        return true
    }
    
    all?() = self.all?(id)
    
    any?(pred) = {
        for (v in self)
            if (pred(v))
                return true
        return false
    }
    
    any?() = self.any?(id)
    
    count(value) = {
        c: 0
        for (v in self)
            if (v == value) c += 1
        c
    }
    
    count(pred @ Function) = {
        c: 0
        for (v in self)
            if (pred(v)) c += 1
        c
    }
    
    find(pred) = {
        for (v in self)
            if (pred(v)) return v
        return undef
    }
    
    findall(pred) = {
        ret: Array.new()
        for (v in self)
            if (pred(v)) ret.push(v)
        return ret
    }
    
    partition(pred) = {
        a: Array.new()
        b: Array.new()
        for (v in self)
            if (pred(v)) a.push(v)
            else b.push(v)
        (a, b)
    }
    
    min() = self.foldl1(min)
    max() = self.foldl1(max)
    min(cmp) = self.foldl1((a, b) -> cmp(a,b) < 0 ? a : b)
    max(cmp) = self.foldl1((a, b) -> cmp(a,b) > 0 ? a : b)
    
    minmax(cmp) = {
        if (self.empty?())
            throw `InvalidArgument{!LOCATION,
                "`minmax' requires non empty sequence"
            }
    
        m: infinity
        M: -infinity
        for (v in self) {
            m = cmp(m, v) < 0 ? m : v
            M = cmp(M, v) > 0 ? M : v
        }
        (m, M)
    }

    minmax() = self.minmax(compare)
    
    sum() = self.foldl(add, 0)
    product() = self.foldl(mul, 1)
}


export ContainerTrait
