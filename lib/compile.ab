# Copyright (C) 2014 nineties
# $Id: compile.ab 2014-04-22 15:05:20 nineties $

#= Ahead-of-time compilation =

import interactive (ask)

# Now, we a in the directory where this file is installed.
# Change working directory to the original path.
import sys
sys::chdir(INVOKE_PATH)
Apply{Slot{prim, load}, List{"boot.ab"}}

if ARGV.empty? {
    stderr.puts("Usage: amber --compile <file>")
    exit(1)
}

# Detect input and output languages.
languages := Table{
    ("ab", "amber"),
    ("c",  "CAST")
}

filename_to_lang(f) := {
    idx := f.last_index(".")
    if idx == nil
        return ask("What is the input language? %p", languages.values)
    lang := languages[f[idx+1 .. -1]]
    if lang == nil
        throw `UnsupportedLanguage{!f}
    lang
}


input_lang  := filename_to_lang(ARGV[0])
output_lang := amber.output_file != nil ?
                filename_to_lang(amber.output_file) :
                ask("What is the output language? %p", languages.values)

input_lang  = input_lang.to_sym()
output_lang = output_lang.to_sym()

if input_lang == 'amber
    input_lang = amber
else
    evalfull(`(Import{[!input_lang]}))

# Parse the inputfile as a program of given language.
tree := {
    tree := nil
    fp   := io::open_in(ARGV[0])
    try {
        tree = parser::parse(input_lang, fp)
    } catch e -> {
        fp.close()
        throw e
    }
    fp.close()
    tree
}

# Construct a state object for compilation.
CompileState := `CompileState{} with {
    .tree     := tree
    .language := input_lang
    .infile   := ARGV[0]
    .outfile  := amber.output_file
}

evalfull(`(Import{[!output_lang, compiler]}))
exit(0)
