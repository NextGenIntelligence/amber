" Copyright (C) 2014 nineties "
" $Id: compile.ab 2014-04-16 15:59:38 nineties $ "

" NB: We write comments as string literals until we define comment syntax. "

" Copy important functions from the module `prim' to the global-module. "
Define{load,          Slot{prim, load}}
Define{execfile,      Slot{prim, execfile}}
Define{exit,          Slot{prim, exit}}
Define{create_module, Slot{prim, create_module}}
Define{enter_module,  Slot{prim, enter_module}}
Define{exit_module,   Slot{prim, exit_module}}
Define{fusion,        Slot{prim, fusion_function}}
Define{equal?,        Slot{prim, equal?}}
Define{identical?,    Slot{prim, identical?}}

" Load parser and macros. "
Apply{load, List{"syntax/parse.ab"}}

# Load important functions
load "base.ab"

# Setup trait and class system.
load "object_system.ab"

# Setup module system.
load "module.ab"

# Import standard libraries.
import numeric hiding (INTEGER_WIDTH, INTEGER_MIN, INTEGER_MAX)
import symbol hiding (unique)
import iterable (Iterable, iterator)
import string (*)
import tuple (*)
import list (*)
import array (*)
import table (*)
import io (stdin, stdout, stderr, print, puts, printf, read_char,
        read_line, read_lines, read, str, InputStream, OutputStream,
        InputFileStream, OutputFileStream, BinaryInputFileStream,
        BinaryOutputFileStream, InputStringStream, OutputStringStream)
import function (Function)
import parser (Parser, Syntax, parse)
import syntax::print (pretty, pp)

if (ARGV.empty?) {
    # Start shell

    # Change directory to the ditectory where amber is invoked.
    prim.chdir(amber::INVOKE_PATH)

    # Add `exit` command.
    amber::eval('exit) := exit(0)

    # Enable syntax for shell.
    amber::enable_shell_syntax()
    amber::shell_outputs := Array.new()
    amber::shell_outputs.push(nil)

    PROMPT = "amber"
    p := Parser.new(stdin, amber)

    while true {
        try {
            p.line = amber::shell_outputs.size
            if (p.parse('shell)) {
                tree := p.tree
                v := evalfull(tree)
                puts(pretty(v))
                amber::shell_outputs[0] = v
                amber::shell_outputs.push(v)
            } else {
                stderr.printf("%s Syntax error: %s\n",
                        pretty(LOCATION), p.error_string)
                p.reset!()
            }
        } catch e -> {
            stderr.printf("%s Exception: %s\n",
                    pretty(LOCATION), pretty(e))
            p.reset!()
        }
    }
} else {
    try {
        load(ARGV[0])
    } catch e -> {
        stderr.printf("%s Exception: %s\n",
                pretty(LOCATION), pretty(e))
        exit(1)
    }
    exit(0)
}
