# Copyright (C) 2014 nineties
# $Id: List.ab 2014-03-04 00:18:06 nineties $

import Iterable

#= List =
# A list is a finite sequence of objects. The internal representation of
# lists are singly linked cells.
# Amber's objects are basically heterogeneous, i.e. you can put any kind
# of object into one list.

# `cons(a, [b,c,d,...]) == [a,b,c,d,...]`. O(1)
cons:  Prim.list_cons

# `first([a,b,c,...]) == a`. O(n)
first: Prim.list_first

# `rest([a,b,c,...]) == [b,c,...]`. O(n)
rest:  Prim.list_rest

# Create a new list of length `n` whose `i`-th element is `f(i)`.
# Example:
# ----
# > List.new(x -> x^2, 5)       # => [0, 1, 4, 9, 16]
# ----
new(f @ Function, n @ Int): {
    list: []
    for i in 0..n-1
        list = cons(f(i), list)
    Prim.list_reverse(list)
}

# Create a new list of length `n` by first element `f0` and recurrence
# formula `f`.
# Example:
# ----
# > List.new(x -> x + 1, 0, 5)      # => [0,1,2,3,4]
# ----
new(f @ Function, f0, n @ Int): {
    list: []
    for i in 0..n-1 {
        list = cons(f0, list)
        f0 = f(f0)
    }
    Prim.list_reverse(list)
}

# Create a new list whose elements are obtained from an iterable object
# `container`.
new(container) when container.Iterable? : {
    list: []
    for v in container
        list = cons(v, list)
    Prim.list_reverse(list)
}

# Concatenation of two lists.
# ----
# > [1,2,3] + [4,5]     # => [1,2,3,4,5]
# ----
add = Prim.list_append | add

trait List {
    # The number of elements.
    .length: alias(() -> Prim.list_length(self))
    .size:   alias(() -> Prim.list_length(self))

    # Return true when `self` is an empty list.
    .empty?: alias(() -> self == [])

    # `i`-th element.
    .get(i @ Int): Prim.list_at(self, i)

    # Do nothing. For consistency with other containers.
    .to_list(): self

    # Create a new array that contains all elements of `self` in the same
    # order.
    .to_array(): Prim.list_to_array(self)

    # Create a new list that contains all elements of `self` in the
    # reverse order.
    .reverse(): Prim.list_reverse(self)

    # Create a new list by applying `fun` to each elements of `self`.
    .map(f): Prim.list_map(f, self)

    # Return true when `self` contains `v`.
    .member?(v): Prim.list_member?(self, v)

    # Fold elements of `self` by the binary function `fun` from left to right.
    # Example:
    # ----
    # > [1,2,3,4].foldl((x,y)->x+y, 1)  # => (((1+1)+2)+3)+4
    # > [1,2,3,4].foldl((x,y)->x+y)     # => ((1+2)+3)+4
    # ----
    .foldl(fun, v): Prim.list_foldl(fun, v, self)
    .foldl1(fun):    Prim.list_fold1(fun, self)

    # Fold elements of `self` by the binary function `fun` from right to left.
    # Example:
    # ----
    # > [1,2,3,4].foldr((x,y)->x+y, 1)  # => 1+(2+(3+(4+1)))
    # > [1,2,3,4].foldr((x,y)->x+y)     # => 1+(2+(3+4))
    # ----
    .foldr(fun, v): Prim.list_foldr(fun, self, v)
    .foldr1(fun):   Prim.list_foldr1(fun, self)

    extend 'Iterable

    .each(): {
        list: self
        () -> {
            if (list == [])
                return nil
            v: first(list)
            list = rest(list)
            return v
        }
    }
}

Prim.set_builtin_parent('List, Trait.List)
