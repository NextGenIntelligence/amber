# Copyright (C) 2014 nineties
# $Id: List.ab 2014-03-03 15:14:18 nineties $

import Iterable

#= List =
# A list is a finite sequence of objects. The internal representation of
# lists are singly linked cells.
# Amber's objects are basically heterogeneous, i.e. you can put any kind
# of object into one list.

# `cons(a, [b,c,d,...]) == [a,b,c,d,...]`. O(1)
cons:  Prim.list_cons

# `first([a,b,c,...]) == a`. O(n)
first: Prim.list_first

# `rest([a,b,c,...]) == [b,c,...]`. O(n)
rest:  Prim.list_rest

# List.new(f, n) == [f(0), f(1), ..., f(n-1)]. O(n)
new(f @ Function, n @ Int): {
    list: []
    for (i in 0..n-1) list = cons(f(i), list)
    Prim.list_reverse(list)
}

# List.new(f, f0, n) == [f0, f(f0), f(f(f0)), ..., f(f(...f(f0)...))]. O(n)
new(f @ Function, f0, n @ Int): {
    list: []
    for (i in 0..n-1) {
        list = cons(f0, list)
        f0 = f(f0)
    }
    Prim.list_reverse(list)
}

# Copy elements from an iterable object of finite-length.
new(container) when container.Iterable? : {
    list: []
    it: container.iterator()
    while (not it.end?) {
        list = cons(it.value, list)
        it.next()
    }
    Prim.list_reverse(list)
}

#add = Prim.list_append | add
#
#trait List {
#    .extend 'Collection
#
#    .to_array()    = Prim.list_to_array(self)
#    .to_list()     = self
#    .size          = alias(() -> Prim.list_length(self))
#    .empty?        = alias(() -> self == [])
#    .get(i)        = Prim.list_at(self, i)
#    .set(i, v)     = Prim.list_store(self, i, v)
#    .reverse()     = Prim.list_reverse(self)
#    .map(fun)      = Prim.list_map(fun, self)
#    .member?(v)    = Prim.list_member?(self, v)
#    .foldl(fun, v) = Prim.list_foldl(fun, v, self)
#    .foldl1(fun)   = Prim.list_fold1(fun, self)
#    .foldr(fun, v) = Prim.list_foldr(fun, self, v)
#    .foldr1(fun)   = Prim.list_foldr1(fun, self)
#
#    .extend 'Iterable
#
#    .Iterator = Trait.new(\ListIterator) with {
#        .extend ForwardIterator
#        .extend MutableIterator
#
#        .list   = alias(0)
#        .next?  = alias(() -> .list != [])
#        .next() = {
#            v: car(.list)
#            .list = cdr(.list)
#            v
#        }
#
#        .value = alias(() -> .list[0], (v) -> {.list[0] = v})
#    }
#
#    .iterator() = `Iterator{!self} with .parent = Trait.List.Iterator
#}
#
#Prim.set_builtin_parent(\List, Trait.List)
#
#export cons car cdr
