# Copyright (C) 2014 nineties
# $Id: IO/Printf.ab 2014-03-21 00:24:18 nineties $

import Numeric.Bit (lnot, lor, ltest)
import String.Ascii (is_digit?)

#= Formated output =
# Output arguments according to a format string like C's printf().

# flags.
FMT_PLUS:  0x01
FMT_MINUS: 0x02
FMT_SHARP: 0x04
FMT_SPACE: 0x08
FMT_ZERO:  0x10

FLAG_MAP: Table.new([
    ("+",   FMT_PLUS),
    ("-",   FMT_MINUS),
    ("#",   FMT_SHARP),
    (" ",   FMT_SPACE),
    ("0",   FMT_ZERO)
])

# Read flags from input string stream `iss`.
parse_flag(iss): {
    flag: 0
    while true {
        f: FLAG_MAP[Prim.iss_lookahead(iss, false)]
        if (f == nil) return flag
        flag = lor(flag, f)
        Prim.iss_read_char(iss, false)
    }
}

# Read decimal number from input string stream `iss`.
# If `iss` doesn't begin with decimal character return `nil`.
parse_number(iss): {
    if not is_digit?(Prim.iss_lookahead(iss, false))
        return nil
    w: 0
    while true {
        c: Prim.iss_lookahead(iss, false)
        if not is_digit?(c)
            return w
        w = w*10 + c.to_i()
        Prim.iss_read_char(iss, false)
    }
}

# Read precision number from input string stream `iss`.
# If `iss` doesn't begin with '.' return `nil`. If the format string
# is invalid throw `InvalidFormatString` exception.
parse_prec(fmt, iss): {
    if (Prim.iss_lookahead(iss, false) != ".")
        return nil
    Prim.iss_read_char(iss, false)
    if not is_digit?(Prim.iss_lookahead(iss, false))
        throw `InvalidFormatString{!fmt}
    parse_number(iss)
}

print_element(oss,t,...): throw `UnknownFormatType{!t}

# Pretty printing.
print_element(oss,"p",f,w,p,arg): Prim.pretty_print(oss, arg)

# string.
print_element(oss,"s",f,w,p,arg): {
    str: arg.to_s()
    if p != nil and p < str.length
        str = str[0,p]
    if w == nil
        oss.print(str)
    else {
        if ltest(f, FMT_MINUS)
            oss.print(str.ljust(w))
        else
            oss.print(str.rjust(w))
    }
}

# Decimal integer.
print_element(oss,"d" or "i",f,w,p,arg): {
    num: arg.to_i()
    sign: num < 0
    num = |num|
    str: num.to_s(precision=p)
    prefix: ""
    if sign
        prefix = "-"
    else {
        if ltest(f, FMT_PLUS)
            prefix = "+"
        else if ltest(f, FMT_SPACE)
            prefix = " "
    }
    if w == nil
        return oss.print(prefix + str)
    else {
        if ltest(f, FMT_MINUS)
            oss.print(prefix + str.ljust(w - prefix.size))
        else if ltest(f, FMT_ZERO)
            oss.print(prefix + str.rjust(w - prefix.size, "0"))
        else
            oss.print((prefix + str).rjust(w))
    }
}

# Unsignd binary integer.
print_element(oss,t@("b" or "B"),f,w,p,arg): {
    num: arg.to_i()
    sign: num < 0
    str: num.to_s(base=2,precision=p,unsigned=true)
    prefix: ""
    if sign
        prefix = "..1"
    if ltest(f, FMT_SHARP)
        prefix = "0" + t + prefix

    if w == nil
        return oss.print(prefix + str)
    else {
        if ltest(f, FMT_MINUS)
            oss.print(prefix + str.ljust(w - prefix.size))
        else if ltest(f, FMT_ZERO)
            oss.print(prefix + str.rjust(w - prefix.size, sign ? "1" : "0"))
        else
            oss.print((prefix + str).rjust(w))
    }
}

# Unsigned hexadecimal integer.
print_element(oss,t@("x" or "X"),f,w,p,arg): {
    num: arg.to_i()
    sign: num < 0
    str: num.to_s(base=16,precision=p,upper=(t=="X"),unsigned=true)
    forF: ((t == "x") ? "f" : "F")
    prefix: ""
    if sign
        prefix = ".." + forF
    if ltest(f, FMT_SHARP)
        prefix = "0" + t + prefix

    if w == nil
        return oss.print(prefix + str)
    else {
        if ltest(f, FMT_MINUS)
            oss.print(prefix + str.ljust(w - prefix.size))
        else if ltest(f, FMT_ZERO)
            oss.print(prefix + str.rjust(w - prefix.size, sign ? forF : "0"))
        else
            oss.print((prefix + str).rjust(w))
    }
}

printf(oss, fmt @ String, args...) when oss.OutputStream?: {
    # Create an input string stream.
    iss: Prim.iss_new(fmt, false)
    while true {
        c: Prim.iss_read_char(iss, false)
        if (c == nil) break
        if (c != "%")
            oss.write(c)
        else {
            f: parse_flag(iss)
            w: parse_number(iss)
            p: parse_prec(fmt, iss)
            t: Prim.iss_read_char(iss, false)
            if args == []
                throw `MissingArgument{"argument for %d is missing"}
            print_element(oss, t,f,w,p,first(args))
            args = rest(args)
        }
    }
    if args != []
        throw `InvalidArgument{"Number of arguments doesn't match", !args}
    nil
}
