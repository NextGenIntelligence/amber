# Copyright (C) 2014 nineties
# $Id: Numeric.ab 2014-02-05 19:25:23 nineties $

# Numerical types have partial ordering.
# a < b  <=> a and b are different types and a can be converted to b
compare_numeric_type(a, b): undef
compare_numeric_type(a, a): 0
compare_numeric_type(\Int, \Float): -1
compare_numeric_type(\Float, \Int): 1

upcast(a @ Int, \Float): a.to_f()

perform_binary_operation(a, b, fun, op): {
    case (compare_numeric_type(a.head, b.head)) of
          undef -> {
              throw `LogicError{!LOCATION,
                  "Operands are incompatible", operator{!op}, args{[!a, !b]}}
          }
        | 0 -> {
              throw `LogicError{!LOCATION,
                  "Operands are incompatible", operator{!op}, args{[!a, !b]}}
          }
        | -1 -> { a = upcast(a, b.head) }
        |  1 -> { b = upcast(b, a.head) }
    fun(a, b)
}

add(a, b): perform_binary_operation(a, b, add, \add)
sub(a, b): perform_binary_operation(a, b, sub, \sub)
mul(a, b): perform_binary_operation(a, b, mul, \mul)
div(a, b): perform_binary_operation(a, b, div, \div)
mod(a, b): perform_binary_operation(a, b, mod, \mod)
pow(a, b): perform_binary_operation(a, b, pow, \pow)
divmod(a, b): (div(a, b), mod(a, b))
powmod(a, b, c): mod(pow(a, b), c)

compare(a, b): perform_binary_operation(a, b, compare, \compare)
less_than?(a, b):     compare(a, b) < 0
greater_than?(a, b):  compare(a, b) > 0
less_equal?(a, b):    compare(a, b) <= 0
greater_equal?(a, b): compare(a, b) >= 0
less_than? = Prim.int_less_than? | less_than?
greater_than? = Prim.int_greater_than? | greater_than?
less_equal? = Prim.int_less_equal? | less_equal?
greater_equal? = Prim.int_greater_equal? | greater_equal?

abs(a): a >= 0 ? a : -a
uplus(a): a
uminus(a): -1 * a

# Integer and Floating-point
INTEGER_MIN: Prim.INTEGER_MIN
INTEGER_MAX: Prim.INTEGER_MAX

abs = Prim.int_abs | Prim.float_abs | abs
uplus = Prim.int_uplus | Prim.float_uplus | uplus
uminus = Prim.int_uminus | Prim.float_uminus | uminus
add = Prim.int_add | Prim.float_add | add
sub = Prim.int_sub | Prim.float_sub | sub
mul = Prim.int_mul | Prim.float_mul | mul
div = Prim.int_div | Prim.float_div | div
mod = Prim.int_mod | mod
pow = Prim.int_pow | Prim.float_pow | pow
powmod = Prim.int_powmod | powmod
shiftL: Prim.int_shiftL
shiftR: Prim.int_shiftR

compare = Prim.int_compare | Prim.float_compare | compare
equal?  = Prim.float_equal? | equal?

infinity: Prim.infinity

export abs uplus uminus add sub mul div mod divmod pow powmod
export shiftL shiftR
export compare less_than? greater_than? less_equal? greater_equal? equal?
export INTEGER_MIN INTEGER_MAX
export infinity

# traits
NumericTrait: `Trait{Numeric}
IntegerTrait: `Trait{Integer}

IntTrait: Prim.IntTrait
FloatTrait: Prim.FloatTrait

IntegerTrait.parent = NumericTrait
IntTrait.parent = IntegerTrait
FloatTrait.parent = NumericTrait

IntTrait.to_i(): self
IntTrait.to_f(): Prim.int_to_float(self)
IntTrait.to_s(): Prim.int_to_string(self)

FloatTrait.to_i(): Prim.float_to_int(self)
FloatTrait.to_f(): self
FloatTrait.to_s(): Prim.float_to_string(self)

export NumericTrait IntegerTrait IntTrait FloatTrait

min(a, b): a < b ? a : b
max(a, b): a < b ? b : a

export min max

