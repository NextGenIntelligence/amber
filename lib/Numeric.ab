# Copyright (C) 2014 nineties
# $Id: Numeric.ab 2014-02-11 14:33:54 nineties $

join_numeric_type(a, b): undef
join_numeric_type(a, a): a
join_numeric_type(\Int, \Float): \Float
join_numeric_type(\Float, \Int): \Float

upcast(a, h) when a.head == h: a
upcast(a, \Float): a.to_f()

perform_binary_operation(a, b, fun, op): {
    h: join_numeric_type(a.head, b.head)
    if (h == undef)
          throw `LogicError{!LOCATION,
              "Operands are incompatible.", operator{!op}, args{[!a, !b]}}
    if (h == a.head and h == b.head)
          throw `LogicError{!LOCATION,
              "Undefined binary operation.", operator{!op}, args{[!a, !b]}}
    fun(upcast(a, h), upcast(b, h))
}

add(a, b): perform_binary_operation(a, b, add, \add)
sub(a, b): perform_binary_operation(a, b, sub, \sub)
mul(a, b): perform_binary_operation(a, b, mul, \mul)
div(a, b): perform_binary_operation(a, b, div, \div)
mod(a, b): perform_binary_operation(a, b, mod, \mod)
pow(a, b): perform_binary_operation(a, b, pow, \pow)
divmod(a, b): (div(a, b), mod(a, b))
powmod(a, b, c): {
    h: join_numeric_type(a.head, join_numeric_type(b.head, c.head))
    if (h == undef)
          throw `LogicError{!LOCATION,
              "Operands are incompatible.",
              operator{powmod}, args{[!a, !b, !c]}}
    if (h == a.head and h == b.head and h == c.head)
          throw `LogicError{!LOCATION,
              "Undefined ternary operation.",
              operator{powmod}, args{[!a, !b, !c]}}
    powmod(upcast(a, h), upcast(b, h), upcast(c, h))
}

compare(a, b): perform_binary_operation(a, b, compare, \compare)
less_than?(a, b):     compare(a, b) < 0
greater_than?(a, b):  compare(a, b) > 0
less_equal?(a, b):    compare(a, b) <= 0
greater_equal?(a, b): compare(a, b) >= 0
less_than? = Prim.int_less_than? | less_than?
greater_than? = Prim.int_greater_than? | greater_than?
less_equal? = Prim.int_less_equal? | less_equal?
greater_equal? = Prim.int_greater_equal? | greater_equal?

abs(a): a >= 0 ? a : -a
uminus(a): -1 * a

add!: add
sub!: sub
mul!: mul
pow!: pow
div!: div
mod!: mod

# Integer and Floating-point
INTEGER_MIN: Prim.INTEGER_MIN
INTEGER_MAX: Prim.INTEGER_MAX

uplus: Prim.int_uplus | Prim.float_uplus
uminus = Prim.int_uminus | Prim.float_uminus | uminus
abs = Prim.int_abs | Prim.float_abs | abs
add = Prim.int_add | Prim.float_add | add
sub = Prim.int_sub | Prim.float_sub | sub
mul = Prim.int_mul | Prim.float_mul | mul
div = Prim.int_div | Prim.float_div | div
mod = Prim.int_mod | mod
pow = Prim.int_pow | Prim.float_pow | pow
powmod = Prim.int_powmod | powmod
shiftL: Prim.int_shiftL
shiftR: Prim.int_shiftR

compare = Prim.int_compare | Prim.float_compare | compare
equal?  = Prim.float_equal? | equal?

min(a, b): a < b ? a : b
max(a, b): a < b ? b : a
minmax(a, b): a < b ? (a, b) : (b, a)

infinity: Prim.infinity

export abs uplus uminus add sub mul div mod divmod pow powmod
export add! sub! mul! div! mod! pow!
export shiftL shiftR
export compare less_than? greater_than? less_equal? greater_equal? equal?
export min max minmax
export INTEGER_MIN INTEGER_MAX
export infinity

# traits
NumericTrait: `Trait{Numeric}
IntegerTrait: `Trait{Integer}  with parent = NumericTrait

IntTrait: Prim.IntTrait with {
    parent = IntegerTrait
    to_i() = self
    to_f() = Prim.int_to_float(self)
    to_s() = Prim.int_to_string(self)
}
FloatTrait: Prim.FloatTrait with {
    parent = NumericTrait
    to_i() = Prim.float_to_int(self)
    to_f() = self
    to_s() = Prim.float_to_string(self)
}

export NumericTrait IntegerTrait IntTrait FloatTrait


