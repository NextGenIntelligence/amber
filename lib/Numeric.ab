# Copyright (C) 2014 nineties
# $Id: Numeric.ab 2014-03-12 09:17:42 nineties $

#= Fixed-length integers and floating-point numbers. =
# This module defines numerical operations for fixed-length integers and
# floating-point numbers. The head of fixed-length integers is `Int`
# and of floating-point numbers is `Float.
#
# The representation of fixed-length integer is {{INTEGER_WIDTH}} bits of
# two's complement. The range of them is [{{INTEGER_MIN}}, {{INTEGER_MAX}}].
# Integer overflow is not detected by default and results are truncated to
# {{INTEGER_WIDTH}} bits. If you want multi-precision integers, import
# `Numeric.BigInt` module.
#
# The representation of floating-point numbers is IEEE754 double.

INTEGER_WIDTH: Prim.INTEGER_WIDTH
INTEGER_MIN:   Prim.INTEGER_MIN
INTEGER_MAX:   Prim.INTEGER_MAX
infinity: Prim.infinity

#== Implicit type conversion ==
# Type conversions between objects and integers or floating-point numbers
# are done by methods `to_i` and `to_f`. When you implement these methods,
# `to_i` must returns `Int` type values and `to_f` must returns `Float` types.
# We extend `typejoin` by `typejoin('Int, 'Float) == 'Float` and
# `typejoin('Float, 'Int) == 'Int`.

typecast(a, 'Int) =   a.to_i()
typecast(a, 'Float) = a.to_f()
typejoin('Int, 'Float) = 'Float
typejoin('Float, 'Int) = 'Float

#== Addition, Subtraction and Multiplication ==
# These are very usual ones. We probably need no explanation.

uplus  = Prim.int_uplus | Prim.float_uplus | uplus
uminus = Prim.int_uminus | Prim.float_uminus | uminus
abs    = Prim.int_abs | Prim.float_abs | abs
add    = Prim.int_add | Prim.float_add | add
sub    = Prim.int_sub | Prim.float_sub | sub
mul    = Prim.int_mul | Prim.float_mul | mul

#== Division ==
# Amber distinguishes two kinds of arithmetic division.
# A division with remainder (Euclidean division) and a division with
# no remainder.
#
# The functions `div` (operator = `//`) and `mod` (operator = `%`) are for
# the former and defined as follows:
# * For any integer a and b (b != 0), there exist unique integers q and r
#   such that a = bq + r (0 <= r < |b|).
# * Then `div(a, b) == q` and `mod(a, b) == r`.
# Examples:
# ----
# > 7 // 3      # => 2
# > 7 // -3     # => -2
# > -7 // 3     # => -3
# > -7 // -3    # => 3
# > 7 % 3       # => 1
# > 7 % -3      # => 1
# > -7 % 3      # => 2
# > -7 % -3     # => 2
# ----
# Note that `mod(a, b)` is always positive. It follows usual definition of
# Euclidian division in mathematics. But this behavior is differ from many
# other programming languages.
#
# The function `divmod` computes both.
# ----
# > divmod(7, 3)    # => (2, 1)
# ----
#
# Exceptions:
#   DivisionByZero: When the divisor is 0.
#
# The function `quo` is for the latter.
# Examples:
# ----
# > 3 / 2       # => 1.5
# > 5.3 / 2.5   # => 2.12
# ----
#
# Exceptions:
#   DivisionByZero: When the divisor is 0.
# Note that when the divisor is `0.0` or `-0.0` the result is `infinity`
# with appropriate sign and no exceptions are thrown. This is because we
# should think that `0.0` means approximately zero.
# ----
# > 1.0/0           # => Error DivisionByZero
# > 1.0/0.0         # => infinity
# > 1.0/-0.0        # => -infinity
# > -1.0/0.0        # => -infinity
# > -1.0/-0.0       # => infinity
# ----

div    = Prim.int_div | div
mod    = Prim.int_mod | mod

divmod(a, b): perform_binary_operation(a, b, divmod, 'divmod)
divmod(a, b) when a.head == b.head: (div(a, b), mod(a, b))

quo    = Prim.int_quo | Prim.float_quo | quo

#== Power operation ==
# `pow(a, b)` (operator = '^') is equal to `a` to the power of `b`.
# Examples:
# ----
# > 2^3         # => 8
# > 2^(1/2)     # => 1.414213562373095
# > 2^(-3)      # => 0.125
# ----

pow    = Prim.int_pow | Prim.float_pow | pow

# `powmod(a, b, c)` for integer `a` and natural numbers `b` and `c`,
# is basically equal to `(a ^ b) % c`. The difference is that
# `(a ^ b) % c` may overflow when `a` or `b` is too big but
# `powmod(a, b, c)` never overflow if `c^2` doesn't overflow.
#
# Exceptions:
#   * InvalidArgument: When b < 0 or c < 0.
#
# We uses the binary method for both functions.
# See: http://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method
#
# Example:
# ----
# powmod(7, 160, 10)    # => 1
# ----

powmod(a, b, c): perform_ternary_operation(a, b, c, powmod, 'powmod)
powmod = Prim.int_powmod | powmod

# We use specialized comparison methods for integers for speed,
# and use `compare` for floating-point numbers.
less_than?     = Prim.int_less_than?     | less_than?
greater_than?  = Prim.int_greater_than?  | greater_than?
less_equal?    = Prim.int_less_equal?    | less_equal?
greater_equal? = Prim.int_greater_equal? | greater_equal?
compare = Prim.int_compare | Prim.float_compare | compare

# Several other functions.
abs(a) = a >= 0 ? a : -a
uminus(a) =  -1 * a
min(a, b): a < b ? a : b
max(a, b): a < b ? b : a
minmax(a, b): a < b ? (a, b) : (b, a)

# Traits.
trait Int {
    .to_i(): self
    .to_f(): Prim.int_to_float(self)
    .to_s(base=10, precision=nil, upper=false, unsigned=false):
        Prim.int_to_string(self, base, precision, upper, unsigned)
}

trait Float {
    .to_i(): Prim.float_to_int(self)
    .to_f(): self
    .to_s(): Prim.float_to_string(self)
}

Prim.set_builtin_parent('Int, Trait.Int)
Prim.set_builtin_parent('Float, Trait.Float)
