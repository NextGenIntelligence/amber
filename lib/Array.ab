# Copyright (C) 2014 nineties
# $Id: Array.ab 2014-03-11 16:18:57 nineties $

#= Array =
# Dynamic and mutable array.
# Amber's objects are basically heterogeneous, i.e. you can put any kind
# of object into one array.

# Create an empty array.
new(): Prim.array_new_empty()

# Create an array of length `n` whose `i`-th element is `f(i)` 
new(f @ Function, n @ Int): Prim.array_new(f, n)

# Create an array of length `n` by first element `f0` and recurrence
# formula `f`.
new(f @ Function, f0, n @ Int): {
    ary: Array.new()
    for i in 1..n {
        ary.push(f0)
        f0 = f(f0)
    }
    ary
}

# Create an array whose elements are obtained from an iterable object
# `container`.
new(container) when container.Iterable? : {
    ary: Array.new()
    for v in container
        ary.push(v)
    ary
}

# Concatenation of two arrays.
add = Prim.array_append | add

# Difference of two arrays.
sub = Prim.array_diff | sub

trait Array {
    # The number of elements.
    .length: alias(() -> Prim.array_length(self))
    .size:   alias(() -> Prim.array_length(self))

    # Return true when `self` is an empty array.
    .empty?: alias(() -> Prim.array_length(self) == 0)

    # `i`-th element.
    .get(i @ Int): Prim.array_at(self, i)

    # Store `v` to the `i`-th position. When the length of array is
    # insufficient, it will be resized by length `i+1`. Newly allocated
    # positions are initialized by `nil`.
    .set(i @ Int, v): Prim.array_store(self, i, v)

    # Add new element `v` to the last of the array.
    .push(v): Prim.array_push(self, v)

    # Pop the last element. When `self` is empty, throw `LogicError` exception.
    .pop(): Prim.array_pop(self)

    # Do nothing. For consistency with other containers.
    .to_array(): self

    # Create a new list that contains all elements of `self` in the same order.
    .to_list(): Prim.array_to_list(self)

    # Return `true` when the array includes the value `v`.
    .include?(v): Prim.array_include?(self, v)

    # Reverse the order of `self`.
    .reverse():  Prim.array_reverse(self)
    .reverse!(): Prim.array_reverse!(self)

    # Apply `f` to each element of `self`.
    .map(f):  Prim.array_map(f, self)
    .map!(f): Prim.array_map!(f, self)

    # Append `other` to the last of `self` destructively.
    .add!(other)   = Prim.array_append!(self, other)

    # Remove elements in `other` from `self` destructively.
    .sub!(other)   = Prim.array_diff!(self, other)

    # Fold elements of `self` by the binary function `f` from left to right.
    .foldl(f, v): Prim.array_foldl(f, v, self)
    .foldl(f):    Prim.array_foldl1(f, self)

    # Fold elements of `self` by the binary function `f` from right to left.
    .foldr(f, v): Prim.array_foldr(f, self, v)
    .foldr(f):    Prim.array_foldr1(f, self)

    # Inplace sort.
    .sort!(cmp @ Function): Prim.array_sort!(self, cmp)
    .sort!(): Prim.array_sort!(self, compare)

    extend 'Iterable
    .each(): {
        ary: self
        idx: 0

        iterator () -> {
            if (idx >= ary.size)
                return nil
            idx += 1
            ary[idx-1]
        }
    }
}

Prim.set_builtin_parent('Array, Trait.Array)
