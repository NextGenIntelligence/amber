# Copyright (C) 2010 nineties
#
# $Id: lib/rowl/syntax.ab 2012-02-01 22:40:43 nineties $

# Syntax definition of rowl language

module (Qualified{std,syntax}) {

command Include "include"
command Import "import"

infixr Qualified    "::" 1
prefix Unquote      "!"  3
prefix Quote        "\\" 3
prefix QuasiQuote   "`"  3
infixl Domain       "@"  13
infixr Define       ":"  19
infixr Rewrite      "=>" 20
infixr Lambda       "->" 14
infixr Bind         "|"  15
infixr Seq          ";"  21

prefix UnaryPlus    "+"  5
prefix UnaryMinus   "-"  5
prefix Not          "not"5
infixl Times        "*"  6
infixl Divide       "/"  6
infixl Mod          "%"  6
infixl Plus         "+"  7
infixl Minus        "-"  7
infixl LessThan     "<"  9 
infixl GreaterThan  ">"  9
infixl LessEqual    "<=" 9
infixl GreaterEqual ">=" 9
infixl Equal        "==" 10
infixl NotEqual     "!=" 10
infixl LogicalAnd   "&&" 11
infixl LogicalOr    "||" 12
infixl Where        "where" 13
infixr Assign       "="  17
infixr PlusAssign   "+=" 17
infixr MinusAssign  "-=" 17
infixr TimesAssign  "*=" 17
infixr DivideAssign "/=" 17
infixr ModAssign    "%=" 17
constr If           "if"
constr While        "while"
constr For          "for"
command Return      "return"
infixl Else         "else" 18

Rewrite = (x => y) -> `(Rewrite = (!x -> Rewrite(!y)) | Rewrite)
        | Rewrite

Apply{f@Symbol, args@List}: body
    => `DefineFunction{!f, !MakeExpression{\Tuple,args} -> !body}

`(Apply{!(f@Symbol), !(args@List)} where !cond): body
    => `DefineFunction{!f, Where{!MakeExpression{\Tuple,args}, !cond} -> !body}

x@Symbol: value
    => `DefineVariable{!x, !value}

true: \true
false: \false

+x       => `UnaryPlus(!x)
-x       => `UnaryMinus(!x)
# evaluate literals beforehand
+(x@Int) => UnaryPlus(x)
-(x@Int) => UnaryMinus(x)
not x    => `Not(!x)
x * y    => `Times(!x, !y)
x / y    => `Divide(!x, !y)
x % y    => `Mod(!x, !y)
x + y    => `Plus(!x, !y)
x - y    => `Minus(!x, !y)
x < y    => `LessThan(!x, !y)
x > y    => `GreaterThan(!x, !y)
x >= y   => `GreaterEqual(!x, !y)
x <= y   => `LessEqual(!x, !y)
x += y   => `(!x = !x + !y)
x -= y   => `(!x = !x - !y)
x *= y   => `(!x = !x * !y)
x /= y   => `(!x = !x / !y)
x %= y   => `(!x = !x % !y)
x[y]     => `Subscript(!x, !y)

}
