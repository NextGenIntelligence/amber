DefineSyntax{
    comment,
    List{Tuple{List{"#", Many{List{Not{"\n"}, any}}}, Quote{nil}}},
    space_sensitive
}

DefineSyntax{
    blank,
    List{Tuple{List{comment}, Quote{nil}}}
}

# Copyright (C) 2010 nineties
#
# $Id: syntax.ab 2012-06-13 08:29:55 nineties $

# Syntax definition of the Amber language.
# This file will be loaded first.


### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping

## Amber's unique syntax elements
# aligned(p)       : sequence of p where every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol}, node0},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeExpr{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node0}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node0}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_action,
    List{
        Tuple{List{"{", statement, "}"},
            MakeExpr{Quote{Block}, List{node1}}}
    }
}

DefineSyntax{
    syntax,
    List{
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{syntax, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{
    statement,
    List{Tuple{List{syntax_declaration}, QuasiQuote{Located{Unquote{loc0}, Unquote{node0}}}}}
}

### Expressions
primary_expr
    ::= item
      | "(" expr ")"                  { node1 } 
      | "[" delimited(expr, ",") "]"  { node1 } # List literal
      | "(" delimited2(expr, ",") ")" 
        { MakeExpr{Quote{Tuple}, node1} } # Tuple literal

postfix_expr
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { QuasiQuote{Apply{Unquote{node0}, Unquote{node2}}} } # Function Application
      | postfix_expr "[" delimited(expr, ",") "]"
        { QuasiQuote{Subscript{Unquote{node0}, Unquote{node2}}} } # Subscription
      | primary_expr

quote_expr
    ::= "\\" quote_expr
        { MakeExpr{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeExpr{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeExpr{Quote{Unquote}, List{node1}} }
      | postfix_expr

# enable use of quotation expressions for following definitions.
expr ::= quote_expr

multiplicative_expr
    ::= multiplicative_expr '*' quote_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' quote_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' quote_expr { `Mod{!node0, !node2} }
      | quote_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

lambda_expr
    ::= primary_expr "->" lambda_expr  { `Lambda{!node0, !node2} }
      | additive_expr

assign_expr
    ::= symbol ":" assign_expr
        { `DefineVariable{!node0, !node2} }
      | symbol primary_expr ":" assign_expr
        { `DefineFunction{!node0, Lambda{!node1, !node3}} }
      | primary_expr "=" assign_expr { `Assign{!node0, !node2} }
      | lambda_expr

expr ::= assign_expr
