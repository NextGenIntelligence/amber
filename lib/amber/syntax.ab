Assign{Qualified{Syntax,comment}, Qualified{Syntax,shell_style_comment}}

# Copyright (C) 2010 nineties
#
# $Id: syntax.ab 2013-03-25 14:09:21 nineties $

# Syntax definition of the Amber language.
# This file will be loaded first.


### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p when every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)
# located(p)       : parse p with location
# parsewith(p)     : do parse using p (p can refer previous tokens)
# nospace(p)       : parse p without parsing spaces between tokens

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{'\\', any}, List{Not{"]"}, any}}}},
        Apply{input_text, List{parser,begin,end}}}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol}, node0},
        Tuple{List{"(", syntax_element, ")"}, node1},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeObject{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"located", "(", syntax_element, ")"},
            QuasiQuote{Located{Unquote{node2}}}, multiline},
        Tuple{List{"parsewith", "(", symbol, ")"},
            QuasiQuote{ParseWith{Unquote{node2}}}, multiline},
        Tuple{List{"nospace", "(", syntax_element, ")"},
            QuasiQuote{NoSpace{Unquote{node2}}}, multiline},
        Tuple{List{"nospace", "(", Many1{syntax_element}, ")"},
            QuasiQuote{NoSpace{Unquote{node2}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"<<", Many1{Choice{object,symbol}}, ">>"},
            node1, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{"{", Aligned{statement}, "}"},
        QuasiQuote{Block{Unquote{node1}}}, multiline}
        }
}

DefineSyntax{
    parser_entry,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{parser_option, syntax_element},
            QuasiQuote{Tuple{Unquote{List{node1}}, node1, Unquote{node0}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{parser_entry, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{
    statement,
    List{Tuple{List{syntax_declaration}, node0}}
}

### Expressions
qualified_symbol
    ::= qualified_symbol "::" symbol
        { MakeObject{Quote{Qualified}, List{node0, node2}} }
      | symbol

block_body ::= aligned(located(statement))
                { QuasiQuote{Block{Unquote{node0}}} }
primary_block
    ::= <<multiline>> "{" block_body "}" { node1 }
        # Block with module imports

block ::= primary_block
        | block_body

primary_expr
    ::= primary_block

      | <<multiline>> "<" qualified_symbol ">" "{" parsewith(node1) "}"
        { node4 }

      | <<multiline>> "(" expr ")"                  { node1 } 
      | <<multiline>> "(" statement ")"             { node1 }
      | <<multiline>> "[" delimited(expr, ",") "]"  { node1 } # List literal

      # Tuple literal
      | <<multiline>> "(" delimited2(expr, ",") ")"
        { MakeObject{Quote{Tuple}, node1} }

      | qualified_symbol
      | atom
      | "..."   { Quote{Ellipsis{nil}} }

postfix_expr
        # Function Application
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Apply}, List{node0, node2}} }

        # Subscription
      | postfix_expr "[" delimited(expr, ",") "]"
        { MakeObject{Quote{Subscript}, List{node0, node2}} }

      | # Ellipsis Pattern
        postfix_expr "..."
        { MakeObject{Quote{Ellipsis}, List{node0}} }

        # Domain Pattern
      | primary_expr "@" postfix_expr
        { MakeObject{Quote{Domain}, List{node0, node2}} }

      | postfix_expr "." symbol "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Slot}, List{node0, node2, node4}} }
      | postfix_expr "." symbol
        { MakeObject{Quote{Slot}, List{node0, node2}} }

      | primary_expr "^" postfix_expr
        { MakeObject{Quote{Power}, List{node0, node2}} }

      | object

      | primary_expr

quote_expr
    ::= "\\" quote_expr
        { MakeObject{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeObject{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeObject{Quote{Unquote}, List{node1}} }
      | postfix_expr

pattern ::= quote_expr
term    ::= quote_expr

## enable use of quotation expressions for following definitions.
Assign{Qualified{Syntax,expr}, Qualified{Syntax,quote_expr}}

prefix_expr
    ::= "+"          quote_expr { `UnaryPlus{!node1} }
      | "-" !decimal quote_expr { `UnaryMinus{!node2} }
      | "not" quote_expr        { `Not{!node1} }

      | <<multiline>> "make" symbol "{" delimited(expr, ",") "}"
        { `MakeObject{\!node1, !node3} }

      | quote_expr

multiplicative_expr
    ::= multiplicative_expr '*' prefix_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' prefix_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' prefix_expr { `Mod{!node0, !node2} }
      | prefix_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

shift_expr
    ::= shift_expr "<<" additive_expr    { `ShiftL{!node0, !node2} }
      | shift_expr ">>" additive_expr    { `ShiftR{!node0, !node2} }
      | additive_expr

range_expr
    ::= shift_expr ".." shift_expr { `Range{!node0, !node2} }
      | "range" "[" shift_expr "," shift_expr "]"
        { `Range{!node2, !node4} }
      | "range" "(" shift_expr "," shift_expr ")"
        { `Range{!node2, !node4, \Open} }
      | "range" "(" shift_expr "," shift_expr "]"
        { `Range{!node2, !node4, \LeftOpen} }
      | "range" "[" shift_expr "," shift_expr ")"
        { `Range{!node2, !node4, \RightOpen} }
      | shift_expr

rel_expr
    ::= range_expr "<"  range_expr { `LessThan{!node0, !node2} }
      | range_expr "<=" range_expr { `LessEqual{!node0, !node2} }
      | range_expr ">"  range_expr { `GreaterThan{!node0, !node2} }
      | range_expr ">=" range_expr { `GreaterEqual{!node0, !node2} }
      | range_expr "==" range_expr { `Equal{!node0, !node2} }
      | range_expr "!=" range_expr { `NotEqual{!node0, !node2} }
      | range_expr "is" range_expr { `Identical{!node0, !node2} }
      | range_expr "is" "not" range_expr { `NotIdentical{!node0, !node3} }
      | range_expr

seqand_expr
    ::= rel_expr "and" seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr "or" seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" ternary_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_expr ::= ternary_expr

argument_list
    ::= "(" delimited(pattern, ",") ")" "when" guard_expr
        { `When{!node1, !node4} }
      | "(" delimited(pattern, ",") ")"
        { node1 }
      | !"{" pattern "when" guard_expr
        { `When{List{!node1}, !node3} }
      | !"{" pattern
        { List{node1} }

lambda_expr
    ::= argument_list "->" ternary_expr
        { `Lambda{!node0, !node2} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Fusion{!node0, !node2} }
      | lambda_expr

assign_expr
    ::= pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `ModAssign{!node0, !node2} }
      | pattern "<<=" assign_expr { `ShiftLAssign{!node0, !node2} }
      | pattern ">>=" assign_expr { `ShiftRAssign{!node0, !node2} }
      | multi_lambda_expr

Assign{Syntax::expr, Syntax::assign_expr}

### Statements
package ::= string
          | delimited1(symbol, ".")

statement
    ::= statement ";" statement
        { `Seq{[!node0, !node2]} }

      | statement ";"
        { `Seq{[!node0, nil]} }

      | "open" qualified_symbol
        { `Open{!node1} }
      | "import" package
        { `Import{!node1} }

      | <<multiline>> "if" term statement "else" statement
        { `IfElse{!node1, !node2, !node4} }
      | <<multiline>> "if" term statement
        { `If{!node1, !node2} }

      | <<multiline>> "case" term "of" multi_lambda_expr
        { `Apply{!node3, [!node1]} }

      | <<multiline>> "while" term block
        { `While{!node1, !node2} }
      | <<multiline>> "for" "(" pattern "in" expr ")" block
        { `For{!node2, !node4, !node6} }
      | <<multiline>> "reverse_for" "(" pattern "in" expr ")" block
        { `RevFor{!node2, !node4, !node6} }
      | "continue"
        { `Continue{} }
      | "break"
        { `Break{} }

      | "return" expr
        { `Return{!node1} }
      | "return"
        { `Return{nil} }

      | "throw" expr
        { `Throw{!node1} }
      | <<multiline>> "try" block "catch" multi_lambda_expr
        { `Try{!node1, !node3} }

      | symbol argument_list ":" block
        { `DefineFunction{!node0, Lambda{!node1, !node3}} }
      | pattern ":" expr
        { `DefineVariable{!node0, !node2} }

      | expr "=>" statement
        { `DefineFunction{rewrite, Lambda{!node0, !node2}} }

### Reserved Keywords
ReserveSymbol{not, and, or, when, open, if, else, case, of,
    while, for, reverse_for, in, continue, break, return,
    throw, try, catch, scope
}

## Syntax Sugars

rewrite_operator_assign(lhs, rhs, op): {
    split: (Subscript{lhs, args}) -> {
                stmt: []
                new_args: []
                new_lhs: lhs

                for (a in args) {
                    if (head(a) != \Symbol) {
                        t: genSym()
                        stmt = cons(`DefineVariable{!t, !a}, stmt)
                        new_args = cons(t, new_args)
                    } else
                        new_args = cons(a, new_args)
                }
                new_args = reverse(new_args)

                if (head(lhs) != \Symbol) {
                    t: genSym()
                    stmt = cons(`DefineVariable{!t, !lhs}, stmt)
                    new_lhs = t
                }

                (`Subscript{!new_lhs, !new_args}, `Seq{!stmt})
            }
        | x -> (x, nil)

    (x, s): split(lhs)
    `{
        !s
        !x = (!op)(!x, !rhs)
    }
}

+x      => `uplus(!x)
-x      => `uminus(!x)
x + y   => `add(!x, !y)
x - y   => `sub(!x, !y)
x * y   => `mul(!x, !y)
x ^ y   => `pow(!x, !y)
x / y   => `div(!x, !y)
x % y   => `mod(!x, !y)
x << y  => `shiftL(!x, !y)
x >> y  => `shiftR(!x, !y)
x += y  => rewrite_operator_assign(x, y, \add)
x -= y  => rewrite_operator_assign(x, y, \sub)
x *= y  => rewrite_operator_assign(x, y, \mul)
x ^= y  => rewrite_operator_assign(x, y, \pow)
x /= y  => rewrite_operator_assign(x, y, \div)
x %= y  => rewrite_operator_assign(x, y, \mod)
x <<= y => rewrite_operator_assign(x, y, \shiftL)
x >>= y => rewrite_operator_assign(x, y, \shiftR)
x < y   => `lt(!x, !y)
x > y   => `gt(!x, !y)
x <= y  => `le(!x, !y)
x >= y  => `ge(!x, !y)
x == y  => `equal(!x, !y)
x != y  => `(not equal(!x, !y))
x is y  => `identical(!x, !y)
x is not y => `(not identical(!x, !y))

module Syntax {
    ### Extend primary_expr so as to enable use $... to refer nodes
    # of syntax-tree only in parser_action.
    module Action {
        primary_expr ::= "$" decimal { ("node" + node1).to_sym }
                       | "$input"    { \input_text(parser,begin,end) }
    }

    # FIXME: This is temporary dirty hack.
    primary_expr_act : primary_expr | Action::Syntax::primary_expr
    parser_action_old: parser_action
    parser_action = parser -> {
        save_primary_expr: primary_expr
        primary_expr = primary_expr_act
        r: parser_action_old(parser)
        primary_expr = save_primary_expr
        r
    }

    ### Syntax definitions which are effective only in shell-mode.
    module Shell {
        primary_expr ::= "%" nospace(decimal) { `shell_outputs[!$1] }
                       | "%"                  { `shell_outputs[0] }
    }

    enable_shell_syntax(): {
        primary_expr = primary_expr | Shell::Syntax::primary_expr
    }
}
