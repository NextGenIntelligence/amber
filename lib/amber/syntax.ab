ReplaceSyntax{comment, shell_style_comment}

# Copyright (C) 2010 nineties
#
# $Id: syntax.ab 2013-02-19 21:33:42 nineties $

# Syntax definition of the Amber language.
# This file will be loaded first.


### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p where every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)
# located(p)       : parse p with location
# scoped(m, p)     : parse p within module m
# parsewith(p)     : do parse using p (p can refer previous tokens)
# nospace(p)       : parse p without parsing spaces between tokens
# withblank(p)     : parse p with more than one banks between tokens

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{'\\', any}, List{Not{"]"}, any}}}},
        Apply{input_text, List{parser,begin,end}}}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol}, node0},
        Tuple{List{"(", syntax_element, ")"}, node1},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeObject{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"located", "(", syntax_element, ")"},
            QuasiQuote{Located{Unquote{node2}}}, multiline},
        Tuple{List{"scoped", "(", expr, ",", syntax_element, ")"},
            QuasiQuote{Scoped{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"parsewith", "(", symbol, ")"},
            QuasiQuote{ParseWith{Unquote{node2}}}, multiline},
        Tuple{List{"nospace", "(", syntax_element, ")"},
            QuasiQuote{NoSpace{Unquote{node2}}}, multiline},
        Tuple{List{"nospace", "(", Many1{syntax_element}, ")"},
            QuasiQuote{NoSpace{Unquote{node2}}}, multiline},
        Tuple{List{"withblank", "(", syntax_element, ")"},
            QuasiQuote{WithBlank{Unquote{node2}}}, multiline},
        Tuple{List{"withblank", "(", Many1{syntax_element}, ")"},
            QuasiQuote{WithBlank{Unquote{node2}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"[", Many1{symbol}, "]"},
            node1, multiline}
    }
}

BeginModule{parser}
EndModule{}

DefineSyntax{
    parser_action_body,
    List{
        Tuple{List{"{", Aligned{statement}, "}"},
            QuasiQuote{Block{Unquote{node1}}}, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{Scoped{Quote{parser}, parser_action_body}}, node0}}
}

DefineSyntax{
    syntax,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{parser_option, syntax_element},
            QuasiQuote{Tuple{Unquote{List{node1}}, node0, Unquote{node0}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{syntax, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{
    statement,
    List{Tuple{List{syntax_declaration}, node0}}
}

## Expressions
qualified_symbol
    ::= qualified_symbol "::" symbol
        { MakeObject{Quote{Qualified}, List{node0, node2}} }
      | symbol

block_body ::= aligned(located(statement))
                { QuasiQuote{Block{Unquote{node0}}} }
primary_block
    ::= [multiline] "{" block_body "}" { node1 }
        # Block with module imports

      | [multiline] "seq" "{" aligned(located(statement)) "}"
        { MakeObject{Quote{Seq}, List{node2}} }

block ::= primary_block
        | block_body

primary_expr
    ::= primary_block

      | [multiline] "<" qualified_symbol ">" "{" parsewith(node1) "}"
        { node4 }

      | [multiline] "(" expr ")"                  { node1 } 
      | [multiline] "(" statement ")"             { node1 }
      | [multiline] "[" delimited(expr, ",") "]"  { node1 } # List literal

      # Tuple literal
      | [multiline] "(" delimited2(expr, ",") ")"
        { MakeObject{Quote{Tuple}, node1} }

      | qualified_symbol
      | atom
      | "..."   { Quote{Ellipsis{nil}} }

postfix_expr
        # Function Application
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Apply}, List{node0, node2}} }

        # Subscription
      | postfix_expr "[" delimited(expr, ",") "]"
        { MakeObject{Quote{Subscript}, List{node0, node2}} }

      | # Ellipsis Pattern
        postfix_expr "..."
        { MakeObject{Quote{Ellipsis}, List{node0}} }

        # Domain Pattern
      | primary_expr "@" postfix_expr
        { MakeObject{Quote{Domain}, List{node0, node2}} }

      | postfix_expr "." symbol "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Slot}, List{node0, node2, node4}} }
      | postfix_expr "." symbol
        { MakeObject{Quote{Slot}, List{node0, node2}} }

      | primary_expr "^" postfix_expr
        { MakeObject{Quote{Power}, List{node0, node2}} }

      | node

      | primary_expr

quote_expr
    ::= "\\" quote_expr
        { MakeObject{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeObject{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeObject{Quote{Unquote}, List{node1}} }
      | postfix_expr

pattern ::= quote_expr
term    ::= primary_expr

# enable use of quotation expressions for following definitions.
ReplaceSyntax{expr, quote_expr}

prefix_expr
    ::= "+"          quote_expr { `UnaryPlus{!node1} }
      | "-" !decimal quote_expr { `UnaryMinus{!node2} }
      | "not" quote_expr        { `Not{!node1} }

      | [multiline] "make" symbol "{" delimited(expr, ",") "}"
        { `MakeObject{\!node1, !node3} }

      | quote_expr

multiplicative_expr
    ::= multiplicative_expr '*' prefix_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' prefix_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' prefix_expr { `Mod{!node0, !node2} }
      | prefix_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

shift_expr
    ::= shift_expr "<<" additive_expr    { `ShiftL{!node0, !node2} }
      | shift_expr ">>" additive_expr    { `ShiftR{!node0, !node2} }
      | additive_expr

range_expr
    ::= shift_expr ".." shift_expr { `Range{!node0, !node2} }
      | shift_expr

rel_expr
    ::= range_expr "<"  range_expr { `LessThan{!node0, !node2} }
      | range_expr "<=" range_expr { `LessEqual{!node0, !node2} }
      | range_expr ">"  range_expr { `GreaterThan{!node0, !node2} }
      | range_expr ">=" range_expr { `GreaterEqual{!node0, !node2} }
      | range_expr "==" range_expr { `Equal{!node0, !node2} }
      | range_expr "!=" range_expr { `NotEqual{!node0, !node2} }
      | range_expr "is" range_expr { `Identical{!node0, !node2} }
      | range_expr "is" "not" range_expr { `NotIdentical{!node0, !node3} }
      | range_expr

seqand_expr
    ::= rel_expr "and" seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr "or" seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" ternary_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_expr ::= ternary_expr

arguments
    ::= "(" delimited(pattern, ",") ")" "where" guard_expr
        { `Where{!node1, !node4} }
      | "(" delimited(pattern, ",") ")"
        { node1 }
      | !"{" pattern "where" guard_expr
        { `Where{List{!node1}, !node3} }
      | !"{" pattern
        { List{node1} }

lambda_expr
    ::= arguments "->" block
        { `Lambda{!node0, !node2} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Fusion{!node0, !node2} }
      | lambda_expr

assign_expr
    ::= pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `ModAssign{!node0, !node2} }
      | pattern "<<=" assign_expr { `ShiftLAssign{!node0, !node2} }
      | pattern ">>=" assign_expr { `ShiftRAssign{!node0, !node2} }
      | multi_lambda_expr

ReplaceSyntax{expr, assign_expr}

### Statements
package ::= string
          | delimited1(symbol, ".")

statement
    ::= statement ";" statement
        { `Seq{[!node0, !node2]} }

      | statement ";"
        { `Seq{[!node0, nil]} }

      | "open" qualified_symbol
        { `Open{!node1} }
      | "import" package
        { `Import{!node1} }

      | [multiline] "if" term statement "else" statement
        { `IfElse{!node1, !node2, !node4} }
      | [multiline] "if" term statement
        { `If{!node1, !node2} }

      | [multiline] "case" term "of" multi_lambda_expr
        { `Apply{!node3, [!node1]} }

      | [multiline] "while" term block
        { `While{!node1, !node2} }
      | [multiline] "for" "(" pattern "in" expr ")" block
        { `For{!node2, !node4, !node6} }
      | [multiline] "reverse_for" "(" pattern "in" expr ")" block
        { `RevFor{!node2, !node4, !node6} }
      | "continue"
        { `Continue{} }
      | "break"
        { `Break{} }

      | "return" expr
        { `Return{!node1} }
      | "return"
        { `Return{nil} }

      | "throw" expr
        { `Throw{!node1} }
      | [multiline] "try" block "catch" multi_lambda_expr
        { `Try{!node1, !node3} }

      | symbol arguments ":" block
        { `DefineFunction{!node0, Lambda{!node1, !node3}} }
      | pattern ":" expr
        { `DefineVariable{!node0, !node2} }

      | expr "=>" statement
        { `DefineFunction{rewrite, Lambda{!node0, !node2}} }

## Reserved Keywords
ReserveSymbol{not, and, or, where, open, if, else, case, of,
    while, for, reverse_for, in, continue, break, return,
    throw, try, catch, seq, scope
}

## Syntax Sugars
+x      => `uplus(!x)
-x      => `uminus(!x)
x + y   => `add(!x, !y)
x - y   => `sub(!x, !y)
x * y   => `mul(!x, !y)
x ^ y   => `pow(!x, !y)
x / y   => `div(!x, !y)
x % y   => `mod(!x, !y)
x << y  => `shiftL(!x, !y)
x >> y  => `shiftR(!x, !y)
x += y  => `(!x = add(!x, !y))
x -= y  => `(!x = sub(!x, !y))
x *= y  => `(!x = mul(!x, !y))
x ^= y  => `(!x = pow(!x, !y))
x /= y  => `(!x = div(!x, !y))
x %= y  => `(!x = mod(!x, !y))
x <<= y => `(!x = shiftL(!x, !y))
x >>= y => `(!x = shiftR(!x, !y))
x < y   => `lt(!x, !y)
x > y   => `gt(!x, !y)
x <= y  => `le(!x, !y)
x >= y  => `ge(!x, !y)
x == y  => `equal(!x, !y)
x != y  => `(not equal(!x, !y))
x is y  => `identical(!x, !y)
x is not y => `(not identical(!x, !y))
x[args...]     => `Apply{at, !std::cons(x, args)}
x[args...] = e => `Apply{store, !std::cons(x, std::append(args, [e]))}

module parser {
    primary_expr ::= "$" decimal { ("node" + node1).to_sym }
                   | "$input"    { \input_text(parser,begin,end) }
}

module shell_syntax {
    primary_expr ::= "%" nospace(decimal) { `shell_outputs[!$1] }
                   | "%"                  { `shell_outputs[0] }
}
