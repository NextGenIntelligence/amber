Assign{Slot{Syntax,comment}, Slot{Syntax,shell_style_comment}}

# Copyright (C) 2010 nineties
#
# $Id: syntax.ab 2013-10-16 09:47:05 nineties $

# Syntax definition of the Amber language.
# This file will be loaded first.


### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p when every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)
# located(p)       : parse p with location
# parsewith(p)     : do parse using p (p can refer previous tokens)

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{'\\', any}, List{Not{"]"}, any}}}},
        Apply{Slot{Syntax,input_text}, List{parser,begin,end}}}
    }
}

DefineSyntax{
    qualified_symbol,
    List{
        Tuple{List{qualified_symbol, ".", symbol},
            QuasiQuote{Slot{Unquote{node0}, Unquote{node2}}}},
        Tuple{List{symbol}, node0}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{qualified_symbol}, node0},
        Tuple{List{"(", syntax_element, ")"}, node1},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeObject{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"located", "(", syntax_element, ")"},
            QuasiQuote{Located{Unquote{node2}}}, multiline},
        Tuple{List{"parsewith", "(", symbol, ")"},
            QuasiQuote{ParseWith{Unquote{node2}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"<<", Delimited1{symbol, ","}, ">>"},
            node1, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{"{", Aligned{statement}, "}"},
        QuasiQuote{Block{Unquote{node1}}}, multiline}
        }
}

DefineSyntax{
    parser_entry,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{parser_option, syntax_element},
            QuasiQuote{Tuple{Unquote{List{node1}}, node1, Unquote{node0}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{qualified_symbol, "::=", Delimited1{parser_entry, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{
    statement,
    List{Tuple{List{syntax_declaration}, node0}}
}

### Expressions
block_body ::= aligned(located(statement))
    { QuasiQuote{Block{Unquote{node0}}} }

primary_block
    ::= <<multiline>> "{" block_body "}" { node1 }

block ::= primary_block
        | block_body

primary_expr
    ::= primary_block
      | <<multiline>> "<" qualified_symbol ">" "{" parsewith(node1) "}"
        { node4 }
      | <<multiline>> "(" statement ")"             { node1 }
      # List literal
      | <<multiline>> "[" delimited(expr, ",") "]"  { node1 }
      # Tuple literal
      | <<multiline>> "(" delimited2(expr, ",") ")"
        { MakeObject{Quote{Tuple}, node1} }
      | atom
      | "..."   { Quote{Ellipsis{nil}} }

postfix_expr
        # Function Application
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Apply}, List{node0, node2}} }
        # Subscription
      | postfix_expr "[" delimited(expr, ",") "]"
        { MakeObject{Quote{Subscript}, List{node0, node2}} }
      | # Ellipsis Pattern
        postfix_expr "..."
        { MakeObject{Quote{Ellipsis}, List{node0}} }
        # Domain Pattern
      | primary_expr "@" postfix_expr
        { MakeObject{Quote{Domain}, List{node0, node2}} }
      | postfix_expr "." symbol
        { MakeObject{Quote{Slot}, List{node0, node2}} }
      | primary_expr "^" postfix_expr
        { MakeObject{Quote{Power}, List{node0, node2}} }
      | object
      | primary_expr

quote_expr
    ::= "\\" quote_expr
        { MakeObject{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeObject{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeObject{Quote{Unquote}, List{node1}} }
      | postfix_expr

pattern ::= quote_expr
term    ::= primary_expr

## enable use of quotation expressions for following definitions.
Assign{Slot{Syntax,expr}, Slot{Syntax,quote_expr}}

prefix_expr
    ::= "+"          quote_expr { `UnaryPlus{!node1} }
      | "-" !decimal quote_expr { `UnaryMinus{!node2} }
      | "not" quote_expr        { `Not{!node1} }
      | quote_expr

multiplicative_expr
    ::= multiplicative_expr '*' prefix_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' prefix_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' prefix_expr { `Mod{!node0, !node2} }
      | prefix_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

shift_expr
    ::= shift_expr "<<" additive_expr    { `ShiftL{!node0, !node2} }
      | shift_expr ">>" additive_expr    { `ShiftR{!node0, !node2} }
      | additive_expr

range_expr
    ::= shift_expr ".." shift_expr { `Range{!node0, !node2} }
      | "range" "[" shift_expr "," shift_expr "]"
        { `Range{!node2, !node4} }
      | "range" "(" shift_expr "," shift_expr ")"
        { `Range{!node2, !node4, \Open} }
      | "range" "(" shift_expr "," shift_expr "]"
        { `Range{!node2, !node4, \LeftOpen} }
      | "range" "[" shift_expr "," shift_expr ")"
        { `Range{!node2, !node4, \RightOpen} }
      | shift_expr

rel_expr
    ::= range_expr "<"  range_expr { `LessThan{!node0, !node2} }
      | range_expr "<=" range_expr { `LessEqual{!node0, !node2} }
      | range_expr ">"  range_expr { `GreaterThan{!node0, !node2} }
      | range_expr ">=" range_expr { `GreaterEqual{!node0, !node2} }
      | range_expr "==" range_expr { `Equal{!node0, !node2} }
      | range_expr "!=" range_expr { `NotEqual{!node0, !node2} }
      | range_expr "is" range_expr { `Identical{!node0, !node2} }
      | range_expr "is" "not" range_expr { `NotIdentical{!node0, !node3} }
      | range_expr

seqand_expr
    ::= rel_expr "and" seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr "or" seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" ternary_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_expr ::= ternary_expr

argument_list
    ::= "(" delimited(pattern, ",") ")" "when" guard_expr
        { `When{!node1, !node4} }
      | "(" delimited(pattern, ",") ")"
        { node1 }
      | !"{" pattern "when" guard_expr
        { `When{List{!node1}, !node3} }
      | !"{" pattern
        { List{node1} }

lambda_expr
    ::= argument_list "->" ternary_expr
        { `Lambda{!node0, !node2} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Fusion{!node0, !node2} }
      | lambda_expr

assign_expr
    ::= pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `ModAssign{!node0, !node2} }
      | pattern "<<=" assign_expr { `ShiftLAssign{!node0, !node2} }
      | pattern ">>=" assign_expr { `ShiftRAssign{!node0, !node2} }
      | multi_lambda_expr

Assign{Syntax.expr, Syntax.assign_expr}

### Statements
statement
    ::= statement ";" statement
        { `Seq{[!node0, !node2]} }

      | statement ";"
        { `Seq{[!node0, nil]} }

      | <<multiline>> "if" term statement "else" statement
        { `IfElse{!node1, !node2, !node4} }
      | <<multiline>> "if" term statement
        { `If{!node1, !node2} }

      | <<multiline>> "case" term "of" multi_lambda_expr
        { `Apply{!node3, [!node1]} }

      | <<multiline>> "while" term block
        { `While{!node1, !node2} }
      | <<multiline>> "for" "(" pattern "in" expr ")" block
        { `For{!node2, !node4, !node6} }
      | <<multiline>> "reverse_for" "(" pattern "in" expr ")" block
        { `RevFor{!node2, !node4, !node6} }
      | "continue"
        { `Continue{} }
      | "break"
        { `Break{} }

      | "return" expr
        { `Return{!node1} }
      | "return"
        { `Return{nil} }

      | "throw" expr
        { `Throw{!node1} }
      | <<multiline>> "try" block "catch" multi_lambda_expr
        { `Try{!node1, !node3} }

      | <<multiline>> pattern ":" statement
        { `Define{!node0, !node2} }

### Reserved Keywords
ReserveSymbol{not, and, or, when, open, if, else, case, of,
    while, for, reverse_for, in, continue, break, return,
    throw, try, catch, scope, import, open, extend
}

## Syntax Sugars

rewrite(+x)     = `uplus(!x)
rewrite(-x)     = `uminus(!x)
rewrite(x + y)  = `add(!x, !y)
rewrite(x - y)  = `sub(!x, !y)
rewrite(x * y)  = `mul(!x, !y)
rewrite(x ^ y)  = `pow(!x, !y)
rewrite(x / y)  = `div(!x, !y)
rewrite(x % y)  = `mod(!x, !y)
rewrite(x << y) = `shiftL(!x, !y)
rewrite(x >> y) = `shiftR(!x, !y)
rewrite(x | y)  = `fusion(!x, !y)

{
    rewrite_operator_assign(lhs, rhs, op): {
        split: (Subscript{lhs, args}) -> {
                    stmt: []
                    new_args: []
                    new_lhs: lhs

                    for (a in args) {
                        if (head(a) != \Symbol) {
                            t: genSym()
                            stmt = cons(`Define{!t, !a}, stmt)
                            new_args = cons(t, new_args)
                        } else
                            new_args = cons(a, new_args)
                    }
                    new_args = reverse(new_args)

                    if (head(lhs) != \Symbol) {
                        t: genSym()
                        stmt = cons(`Define{!t, !lhs}, stmt)
                        new_lhs = t
                    }

                    (`Subscript{!new_lhs, !new_args}, `Seq{!stmt})
                }
            | x -> (x, nil)

        (x, s): split(lhs)
        `{
            !s
            !x = (!op)(!x, !rhs)
        }
    }

    rewrite(x += y)     = rewrite_operator_assign(x, y, \add)
    rewrite(x -= y)     = rewrite_operator_assign(x, y, \sub)
    rewrite(x *= y)     = rewrite_operator_assign(x, y, \mul)
    rewrite(x ^= y)     = rewrite_operator_assign(x, y, \pow)
    rewrite(x /= y)     = rewrite_operator_assign(x, y, \div)
    rewrite(x %= y)     = rewrite_operator_assign(x, y, \mod)
    rewrite(x <<= y)    = rewrite_operator_assign(x, y, \shiftL)
    rewrite(x >>= y)    = rewrite_operator_assign(x, y, \shiftR)
    rewrite(x < y)      = `lt(!x, !y)
    rewrite(x > y)      = `gt(!x, !y)
    rewrite(x <= y)     = `le(!x, !y)
    rewrite(x >= y)     = `ge(!x, !y)
    rewrite(x == y)     = `equal(!x, !y)
    rewrite(x != y)     = `(not equal(!x, !y))
    rewrite(x is y)     = `identical(!x, !y)
    rewrite(x is not y) = `(not identical(!x, !y))
}

### Extend primary_expr so as to enable use $... to refer nodes
# of syntax-tree only in parser_action.

Action: `Module{ParserAction}
Action.Syntax: `Module{Syntax}

Action.primary_expr ::= "$" decimal { ("node" + node1).to_sym }
                      | "$input"    { \Syntax.input_text(parser,begin,end) }
##
### FIXME: This is temporary dirty hack.
Syntax.primary_expr_act: Syntax.primary_expr | Action.Syntax.primary_expr
Syntax.parser_action_old: Syntax.parser_action
Syntax.parser_action = parser -> {
    save_primary_expr: Syntax.primary_expr
    Syntax.primary_expr = Syntax.primary_expr_act
    r: TryApply{Syntax.parser_action_old, [parser]}
    Syntax.primary_expr = save_primary_expr
    r
}


### Syntax definitions which are effective only in shell-mode.
Shell: `Module{Shell}
Shell.Syntax: `Module{Syntax}

Shell.primary_expr ::= "%" decimal
                 {
                    if ($1 == 0 or $1 > shell_outputs.size) {
                        throw `Error{!LOCATION, "The argument of % must be a line number"}
                    }
                    `shell_outputs[!$1]
                 }
                     | "%"         { `shell_outputs[0] }

enable_shell_syntax(): {
    Syntax.primary_expr = Syntax.primary_expr | Shell.Syntax.primary_expr
}
