DefineSyntax{
    blank, List{Tuple{List{shell_style_comment}, Quote{nil}}}
}

# Copyright (C) 2010 nineties
#
# $Id: syntax.ab 2012-11-08 11:40:06 nineties $

# Syntax definition of the Amber language.
# This file will be loaded first.


### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p where every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{'\\', any}, List{Not{"]"}, any}}}},
        Apply{GET_INPUT_TEXT, List{}}}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol}, node0},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeExpr{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"scoped", "(", expr, ",", syntax_element, ")"},
            QuasiQuote{Scoped{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"[", Many1{symbol}, "]"},
            node1, multiline}
    }
}

BeginModule{parser}
EndModule{}

DefineSyntax{
    parser_action_body,
    List{
        Tuple{List{"{", Aligned{statement}, "}"},
            QuasiQuote{Block{Unquote{node1}}}, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{Scoped{Quote{parser}, parser_action_body}}, node0}}
}

DefineSyntax{
    syntax,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{syntax, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{
    statement,
    List{Tuple{List{syntax_declaration}, node0}}
}

## Expressions
qualified_symbol
    ::= symbol "::" qualified_symbol
        { MakeExpr{Quote{Qualified}, List{node0, node2}} }
      | symbol

block_body ::= aligned(statement) { QuasiQuote{Block{Unquote{node0}}} }
block ::= [multiline] "{" block_body "}" { node1 }
        # Block with module imports
        | [multiline] "(" qualified_symbol ")" "{" scoped(node1, block_body) "}"
            { node4 }

primary_expr
    ::= block

      | [multiline] "(" expr ")"                  { node1 } 
      | [multiline] "(" statement ")"             { node1 }
      | [multiline] "[" delimited(expr, ",") "]"  { node1 } # List literal

      # Tuple literals
      | [multiline] "(" ")"
        { MakeExpr{Quote{Tuple}, List{}} }
      | [multiline] "(" delimited2(expr, ",") ")"
        { MakeExpr{Quote{Tuple}, node1} }

      | atom
      | "..."   { Quote{Ellipsis{nil}} }

secondary_expr
    ::= qualified_symbol
      | primary_expr

postfix_expr
        # Function Application
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { MakeExpr{Quote{Apply}, List{node0, node2}} }

        # Subscription
      | postfix_expr "[" delimited(expr, ",") "]"
        { MakeExpr{Quote{Subscript}, List{node0, node2}} }

      | # Ellipsis Pattern
        postfix_expr "..."
        { MakeExpr{Quote{Ellipsis}, List{node0}} }

        # Domain Pattern
      | postfix_expr "@" secondary_expr
        { MakeExpr{Quote{Domain}, List{node0, node2}} }

        # Message Passing Style
        # e.s and e.s(a,b,c) are just syntax-sugars of s(e) and s(e,a,b,c)
      | postfix_expr "." symbol "(" delimited(expr, ",") ")"
        { MakeExpr{Quote{Apply}, List{node2,
            Apply{cons, List{node0, node4}}}} }
      | postfix_expr "." symbol
        { MakeExpr{Quote{Apply}, List{node2, List{node0}}} }

      | secondary_expr "^" postfix_expr
        { MakeExpr{Quote{Power}, List{node0, node2}} }

      | node

      | secondary_expr

term
    ::= "\\" term
        { MakeExpr{Quote{Quote}, List{node1}} }
      | "`"  term
        { MakeExpr{Quote{QuasiQuote}, List{node1}} }
      | "!"  term
        { MakeExpr{Quote{Unquote}, List{node1}} }
      | postfix_expr

pattern ::= term

# enable use of quotation expressions for following definitions.
expr ::= term

prefix_expr
    ::= "+"   term    { `UnaryPlus{!node1} }
      | "-"   term    { `UnaryMinus{!node1} }
      | "not" term    { `Not{!node1} }
      | term

multiplicative_expr
    ::= multiplicative_expr '*' prefix_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' prefix_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' prefix_expr { `Mod{!node0, !node2} }
      | prefix_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

shift_expr
    ::= shift_expr "<<" additive_expr    { `ShiftL{!node0, !node2} }
      | shift_expr ">>" additive_expr    { `ShiftR{!node0, !node2} }
      | additive_expr

rel_expr
    ::= shift_expr "<"  shift_expr { `LessThan{!node0, !node2} }
      | shift_expr "<=" shift_expr { `LessEqual{!node0, !node2} }
      | shift_expr ">"  shift_expr { `GreaterThan{!node0, !node2} }
      | shift_expr ">=" shift_expr { `GreaterEqual{!node0, !node2} }
      | shift_expr "==" shift_expr { `Equal{!node0, !node2} }
      | shift_expr "/=" shift_expr { `NotEqual{!node0, !node2} }
      | shift_expr

seqand_expr
    ::= rel_expr "and" seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr "or" seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" seqor_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_expr ::= ternary_expr

lambda_expr
    ::= pattern "->" lambda_expr
        { `Lambda{!node0, !node2} }
      | pattern "where" guard_expr "->" lambda_expr
        { `Lambda{Where{!node0, !node2}, !node4} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Bind{!node0, !node2} }
      | lambda_expr

assign_expr
    ::= pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `ModAssign{!node0, !node2} }
      | pattern "<<=" assign_expr { `ShiftLAssign{!node0, !node2} }
      | pattern ">>=" assign_expr { `ShiftRAssign{!node0, !node2} }
      | multi_lambda_expr

expr ::= assign_expr

### Statements
arguments
    ::= "(" delimited(expr, ",") ")" "where" guard_expr
        { `Where{!MakeExpr{\Tuple, node1}, !node4} }
      | "(" delimited(expr, ",") ")"
        { MakeExpr{\Tuple, node1} }

statement
    ::= "import" qualified_symbol
        { `Import{!node1} }
      | "include" expr
        { `Include{!node1} }

      | [multiline] "if" term statement "else" statement
        { `IfElse{!node1, !node2, !node4} }
      | "if" term statement
        { `If{!node1, !node2} }

      | "while" term statement
        { `While{!node1, !node2} }
      | "continue"
        { `Continue{} }
      | "break"
        { `Break{} }

      | "return" expr
        { `Return{!node1} }
      | "return"
        { `Return{nil} }

      | "throw" expr
        { `Throw{!node1} }
      | [multiline] "try" statement "catch" multi_lambda_expr
        { `Try{!node1, !node3} }

      | symbol arguments ":" statement
        { `DefineFunction{!node0, Lambda{!node1, !node3}} }
      | pattern ":" expr
        { `DefineVariable{!node0, !node2} }

      | expr "=>" statement
        { `DefineFunction{rewrite, Lambda{!node0, !node2}} }

      | statement ";" statement
        { `Seq{[!node0, !node2]} }

## Syntax Sugars
+x      => `uplus(!x)
-x      => `uminus(!x)
x + y   => `add(!x, !y, nil)
x - y   => `sub(!x, !y, nil)
x * y   => `mul(!x, !y, nil)
x ^ y   => `pow(!x, !y, nil)
x / y   => `div(!x, !y, nil)
x % y   => `mod(!x, !y, nil)
x << y  => `shiftL(!x, !y, nil)
x >> y  => `shiftR(!x, !y, nil)
x += y  => `(!x = add(!x, !y, \overwrite))
x -= y  => `(!x = sub(!x, !y, \overwrite))
x *= y  => `(!x = mul(!x, !y, \overwrite))
x ^= y  => `(!x = pow(!x, !y, \overwrite))
x /= y  => `(!x = div(!x, !y, \overwrite))
x %= y  => `(!x = mod(!x, !y, \overwrite))
x <<= y => `(!x = shiftL(!x, !y, \overwrite))
x >>= y => `(!x = shiftR(!x, !y, \overwrite))
x < y   => `lt(!x, !y)
x > y   => `gt(!x, !y)
x <= y  => `le(!x, !y)
x >= y  => `ge(!x, !y)
x == y  => `equal(!x, !y)
x /= y  => `(not equal(!x, !y))
x[args...]     => `Apply{at, !cons(x, args)}
x[args...] = e => `Apply{store, !cons(x, append(args, [e]))}

# XXX: temporal implementation
DefineVariable{Tuple{vs...}, v} => {
    t: newSymbol()
    sz: vs.length
    `Seq{!([`DefineVariable{!t, !v}] + List::create(sz, i -> `DefineVariable{!vs[i], (!t)[!i]}))}
}

module parser {
    primary_expr ::= "$" decimal { ("node" + node1).to_sym }
                   | "$input"    { \GET_INPUT_TEXT() }
}

module shell_syntax {
    primary_expr ::= "%" decimal { `shell_outputs[!$1] }
                   | "%"         { `shell_outputs[0] }
}
