" Copyright (C) 2010 nineties "
" $Id: Syntax.ab 2014-03-17 22:05:20 nineties $ "

" Syntax definition of the Amber language. "

" Enable comments. "
Assign{Slot{Syntax, comment}, Slot{Prim, parse_shell_style_comment}}

### syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# 'sym  : a symbol
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p when every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)
# parsewith(p)     : do parse using p (p can refer previous tokens)

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{"\\", any}, List{Not{"]"}, any}}}},
        Send{Prim, input_text, List{parser,begin,end}}}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol_without_mark}, node0},
        Tuple{List{"(", syntax_element, ")"}, node1},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeObject{Quote{Choice}, node0}},
        Tuple{List{"'", any_symbol},
            QuasiQuote{Word{Unquote{node1}}}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"parsewith", "(", expr, ",", symbol, ")"},
            QuasiQuote{ParseWith{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"nospace", "(", syntax_element, ")"},
            QuasiQuote{NoSpace{Unquote{node2}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"<<", Delimited1{symbol, ","}, ">>"},
            node1, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{"{", Aligned{stmt}, "}"},
        QuasiQuote{Block{Unquote{node1}}}, multiline}
        }
}

DefineSyntax{
    parser_entry,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{parser_option, syntax_element},
            QuasiQuote{Tuple{Unquote{List{node1}}, node1, Unquote{node0}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{parser_entry, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{stmt, List{ Tuple{List{syntax_declaration}, node0}}}

### Reserved Symbols
# The following symbols never been parsed as symbols.

Define{Slot{Syntax, reserved_words}, Array{
    Quote{self}, Quote{not}, Quote{and}, Quote{or}, Quote{when},
    Quote{if}, Quote{else}, Quote{case}, Quote{of}, Quote{while},
    Quote{for}, Quote{in}, Quote{continue}, Quote{break}, Quote{return},
    Quote{throw}, Quote{try}, Quote{catch}, Quote{import}, Quote{hiding},
    Quote{as}, Quote{with}, Quote{reset}, Quote{shift}
}}

### Expressions
block_body ::= aligned(stmt) { QuasiQuote{Block{Unquote{node0}}} }

primary_block ::= <<multiline>> "{" block_body "}" { node1 }

block ::= primary_block
        | block_body

primary_expr
    ::= primary_block
      | <<multiline>> "<" postfix_expr "," symbol ">" "{" parsewith(node1, node3) "}"
        { node6 }
      | <<multiline>> "(" stmt ")"             { node1 }
      # List literal
      | <<multiline>> "[" delimited(expr, ",") "]"  { node1 }
      # Tuple literal
      | <<multiline>> "(" delimited2(expr, ",") ")"
        { MakeObject{Quote{Tuple}, node1} }
      | "|" expr "|"
        { MakeObject{Quote{Abs}, List{node1}} }
      | 'self           { Quote{GetSelf{}} }
      | atom
      | "..."           { Quote{Rest{}} }

argument ::= symbol "=" assign_expr
             { QuasiQuote{Keyword{Unquote{node0}, Unquote{node2}}} }
           | expr

postfix_expr
        # Function Application
    ::= postfix_expr nospace("(") delimited(argument, ",") ")"
        { MakeObject{Quote{Apply}, List{node0, node2}} }
        # Subscription
      | postfix_expr nospace("[") delimited(argument, ",") "]"
        { MakeObject{Quote{Subscript}, List{node0, node2}} }
      | # RestOf Pattern
        postfix_expr "..."
        { MakeObject{Quote{Rest}, List{node0}} }
        # Domain Pattern
      | primary_expr "@" fullform_expr
        { MakeObject{Quote{Domain}, List{node0, node2}} }
      | postfix_expr "." symbol nospace("(") delimited(argument, ",") ")"
        { MakeObject{Quote{Send}, List{node0, node2, node4}} }
      | postfix_expr "." symbol
        { MakeObject{Quote{Slot}, List{node0, node2}} }
      | "." symbol
        { MakeObject{Quote{Slot}, List{Quote{GetSelf{}}, node1}} }
      | primary_expr "^" postfix_expr
        { MakeObject{Quote{Power}, List{node0, node2}} }
      | primary_expr

fullform_expr
    ::= fullform
      | postfix_expr

quote_expr
    ::= "'" quote_expr
        { MakeObject{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeObject{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeObject{Quote{Unquote}, List{node1}} }
      | fullform_expr

pattern ::= quote_expr
term    ::= postfix_expr

## enable use of quoation expressions for following definitions.
Assign{Slot{Syntax, expr}, Slot{Syntax, quote_expr}}

prefix_expr
    ::= "+"          quote_expr { `UnaryPlus{!node1} }
      | "-" !decimal quote_expr { `UnaryMinus{!node2} }
      | 'not quote_expr         { `Not{!node1} }
      | quote_expr

infix_expr
    ::= infix_expr "<" nospace(symbol) nospace(">") prefix_expr
        { `Apply{!node2, List{!node0, !node4}} }
      | prefix_expr

multiplicative_expr
    ::= multiplicative_expr "*" infix_expr  { `Mul{!node0, !node2} }
      | multiplicative_expr "/" infix_expr  { `Div{!node0, !node2} }
      | multiplicative_expr "//" infix_expr { `Quot{!node0, !node2} }
      | multiplicative_expr "%" infix_expr  { `Rem{!node0, !node2} }
      | infix_expr

additive_expr
    ::= additive_expr "+" multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr "-" multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

range_expr
    ::= additive_expr ".." additive_expr { `Range{!node0, !node2} }
      | additive_expr

rel_expr
    ::= range_expr "<"  range_expr  { `LessThan{!node0, !node2} }
      | range_expr "<=" range_expr  { `LessEqual{!node0, !node2} }
      | range_expr ">"  range_expr  { `GreaterThan{!node0, !node2} }
      | range_expr ">=" range_expr  { `GreaterEqual{!node0, !node2} }
      | range_expr "==" range_expr  { `Equal{!node0, !node2} }
      | range_expr "!=" range_expr  { `NotEqual{!node0, !node2} }
      | range_expr "<=>" range_expr { `Compare{!node0, !node2} }
      | range_expr

seqand_expr
    ::= rel_expr 'and seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr 'or seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" ternary_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_clause ::= 'when ternary_expr { node1 }

argument_list
    ::= "(" delimited(argument, ",") ")" guard_clause
        { `When{!node1, !node3} }
      | "(" delimited(argument, ",") ")"
        { node1 }
      | !"{" pattern guard_clause
        { `When{List{!node1}, !node2} }
      | !"{" pattern
        { List{node1} }

lambda_expr
    ::= argument_list "->" ternary_expr
        { `Lambda{!node0, !node2} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Fusion{!node0, !node2} }
      | lambda_expr

slot_assign_stmt ::= stmt

slot_assign
    ::= <<multiline>> "{" aligned(slot_assign_stmt) "}" { node1 }
      | slot_assign_stmt { List{node0} }

continuation_expr
    ::= 'reset multi_lambda_expr { `Reset{!node1} }
      | 'shift multi_lambda_expr { `Shift{!node1} }
      | multi_lambda_expr

assign_expr
    ::= pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "//=" assign_expr { `QuotAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `RemAssign{!node0, !node2} }
      | pattern "|=" assign_expr  { `FusionAssign{!node0, !node2} }
      | pattern 'with slot_assign
        { MakeObject{Quote{WithSlots}, List{node0, node2}} }
      | continuation_expr

Assign{Syntax.expr, Syntax.assign_expr}

### Statements

import_as ::= 'as symbol { node1 }

import_option
    ::= "(" "*" ")"                            { `All }
      | "(" delimited1(symbol, ",") ")"        { node1 }
      | 'hiding "(" delimited1(symbol, ",") ")" { `Hiding{!node2} }

stmt
    ::= stmt ";" stmt
        { `Seq{[!node0, !node2]} }

      | stmt ";"
        { `Seq{[!node0, nil]} }

      | <<multiline>> 'if expr stmt 'else stmt
        { `IfElse{!node1, !node2, !node4} }
      | <<multiline>> 'if expr stmt
        { `If{!node1, !node2} }

      | <<multiline>> 'case expr 'of multi_lambda_expr
        { `Apply{!node3, [!node1]} }

      | <<multiline>> 'while expr block
        { `While{!node1, !node2} }
      | <<multiline>> 'for pattern 'in expr block
        { `For{!node1, !node3, !node4} }
      | 'continue
        { `Continue{} }
      | 'break
        { `Break{} }
      | 'return expr
        { `Return{!node1} }
      | 'return
        { `Return{nil} }
      | 'throw expr
        { `Throw{!node1} }
      | <<multiline>> 'try block 'catch multi_lambda_expr
        { `Try{!node1, !node3} }
      | <<multiline>> pattern guard_clause ":" stmt
        { `Define{!node0, !node3, !node1} }
      | <<multiline>> pattern ":" stmt
        { `Define{!node0, !node2} }
      | 'import delimited1(symbol, ".") import_as? import_option?
        { `Import{!node1, !node2, !node3} }

      | postfix_expr ![+-.] delimited1(argument, ",")
        { MakeObject{Quote{Apply}, List{node0, node2}} }
      | postfix_expr "." symbol ![+-.] delimited1(argument, ",")
        { MakeObject{Quote{Send}, List{node0, node2, node4}} }

# Add new syntax for syntax declaration usinged qualified symbol like
# `Lang.expr ::= ...`.
syntax_declaration ::= pattern "::=" delimited1(parser_entry, "|")
    { `DefineSyntax{!node0, !node2} }

# Entry point or parsers
Syntax.toplevel = Prim.parse_toplevel
Syntax.shell    = Prim.parse_shell

# Extend primary_expr to enable dollar sign ($) in parser action.
primary_expr_act
    ::= "$" decimal
        {
            Prim.string_to_symbol(
                Prim.string_add("node",
                Prim.int_to_string(node1,10,0,false,false)))
        }
      | "$input"    { 'Prim.input_text(parser, begin, end) }

Syntax.primary_expr_act = fusion(Syntax.primary_expr_act, Syntax.primary_expr)

Syntax.parser_action_old: Syntax.parser_action
Syntax.parser_action = parser -> {
    save_primary_expr: Syntax.primary_expr
    Syntax.primary_expr = Syntax.primary_expr_act
    r: Syntax.parser_action_old(parser)
    Syntax.primary_expr = save_primary_expr
    r
}

# Extension of primary_expr to enable percent sign (%) in shell mode.
primary_expr_shell
    ::= "%" decimal
        {
            if (Prim.equal?(node1, 0) or
                Prim.int_greater_than?(node1, Prim.array_size(shell_outputs))) {
                    throw `SyntaxError{"The argument of % must be a line number"}
            }
            `Prim.array_at(shell_outputs, !node1)
        }
      | "%" { `Prim.array_at(shell_outputs, 0) }

Syntax.enable_shell_syntax: () -> {
    Syntax.primary_expr = fusion(Syntax.primary_expr, Syntax.primary_expr_shell)
}

### Macro
macro: e -> e
expand_macro: expr -> {
    expand_macro_iter: (expr, level) -> {
        if (Equal{level, 0}) {
            new_expr: macro(expr)
            while (NotEqual{new_expr, expr}) {
                expr = new_expr
                new_expr = macro(expr)
            }
        }

        head: Prim.head(expr)

        if (Equal{level, 0} and Equal{head, 'QuoteSyntax})
            return Prim.get_arg(expr, 0)
        else if (Equal{head, 'QuasiQuoteSyntax}) {
            level = Prim.int_add(level, 1)
            expr = Prim.get_arg(expr, 0)
        } else if (Equal{head, 'UnquoteSyntax}) {
            level = Prim.int_sub(level, 1)
            expr = Prim.get_arg(expr, 0)
        } else if (Equal{level, 0} and Equal{head, 'Quote})
            return expr
        else if (Equal{head, 'QuasiQuote})
            level = Prim.int_add(level, 1)
        else if (Equal{head, 'Unquote})
            level = Prim.int_sub(level, 1)

        if Prim.int_less_than?(level, 0)
            throw `LogicError{"Unquoation outside quasi-quoation"}

        if Prim.atom?(expr)
            return expr

        head = Prim.head(expr)
        args: Prim.arguments(expr)
        args = Prim.list_map(e -> expand_macro_iter(e, level), args)
        MakeObject{head, args}
    }
    expand_macro_iter(expr, 0)
}

# Expand macros only once before eval.
Amber.before_eval = expand_macro

macro = fusion((Assign{Apply{f, args}, e}) -> `Assign{!f, Lambda{!args, !e}, fusion}, macro)
macro(Define{Apply{f, args}, e})     = `Define{!f, Lambda{!args, !e}, fusion}
macro(Define{Send{obj, f, args}, e}) = `Define{Slot{!obj, !f}, Lambda{!args, !e}, fusion}
macro(Assign{Send{obj, f, args}, e}) = `Assign{Slot{!obj, !f}, Lambda{!args, !e}, fusion}
macro(Define{Apply{f, args}, e, g})     = `Define{!f, Lambda{When{!args, !g}, !e}, fusion}
macro(Assign{Apply{f, args}, e, g})     = `Assign{!f, Lambda{When{!args, !g}, !e}, fusion}
macro(Define{Send{obj, f, args}, e, g}) = `Define{Slot{!obj, !f}, Lambda{When{!args, !g}, !e}, fusion}
macro(Assign{Send{obj, f, args}, e, g}) = `Assign{Slot{!obj, !f}, Lambda{When{!args, !g}, !e}, fusion}

macro(|x|)     = `abs(!x)
macro(+x)      = `uplus(!x)
macro(-x)      = `uminus(!x)
macro(x + y)   = `add(!x, !y)
macro(x - y)   = `sub(!x, !y)
macro(x * y)   = `mul(!x, !y)
macro(x ^ y)   = `pow(!x, !y)
macro(x / y)   = `quo(!x, !y)
macro(x // y)  = `div(!x, !y)
macro(x % y)   = `mod(!x, !y)
macro(x | y)   = `fusion(!x, !y)
macro(x < y)   = `less_than?(!x, !y)
macro(x > y)   = `greater_than?(!x, !y)
macro(x <= y)  = `less_equal?(!x, !y)
macro(x >= y)  = `greater_equal?(!x, !y)
macro(x == y)  = `equal?(!x, !y)
macro(x != y)  = `(not equal?(!x, !y))
macro(x <=> y) = `compare(!x, !y)
macro(x += y)  = `ArithAssign{!x, !y, add!}
macro(x -= y)  = `ArithAssign{!x, !y, sub!}
macro(x *= y)  = `ArithAssign{!x, !y, mul!}
macro(x ^= y)  = `ArithAssign{!x, !y, pow!}
macro(x /= y)  = `ArithAssign{!x, !y, div!}
macro(x //= y) = `ArithAssign{!x, !y, quo!}
macro(x %= y)  = `ArithAssign{!x, !y, mod!}
macro(x |= y)  = `ArithAssign{!x, !y, fusion!}

# Subscript syntax is not built-in. We need macros.
macro(x[idxs...]) = `Send{!x, get, !idxs}
macro(QuoteSyntax{x[idxs...]} = e)
    = `Send{!x, set, !Prim.list_append(idxs, [e])}
macro(ArithAssign{QuoteSyntax{x[idxs...]}, e, op}) = {
    # We have to consider that evaluation of `x' and `idxs' may have
    # side-effects. So, we translate x[a,b] op= e to
    # { y = x; t1 = a; t2 = b; y[t1, t2] = op(y[t1, t2], e) }
    stmt1: `Define{!unique_symbol('x), !x}
    stmt2: Prim.list_map(i -> `Define{!unique_symbol('t), !i}, idxs)
    y: Prim.get_arg(stmt1, 0)
    ts: Prim.list_map(e -> Prim.get_arg(e, 0), stmt2)

    `Block{
        !Prim.list_append(
            Prim.list_cons(stmt1, stmt2),
            [`Assign{Subscript{!y, !ts}, Send{Subscript{!y, !ts}, !op, [!e]}}]
        )
    }
}

# For-statement for containers.
macro(For{i, container, body}) = {
    iter:  Prim.unique_symbol('iter)
    value: Prim.unique_symbol('value)
    `{
        !iter : (!container).each()
        !value: nil
        while ((!value = (!iter)()) != nil) {
            !i: !value
            !body
        }
    }
}

# For-statement for ranges.
macro(QuoteSyntax{For{i, Range{a, b}, body}}) = {
    j: Prim.unique_symbol('j)
    n: Prim.unique_symbol('n)
    `{
        !j: !a
        !n: !b
        if (!j < !n) {
            while (!j < !n) {
                !i: !j
                !body
                !j += 1
            }
        } else {
            !j -= 1
            while (!j >= !n) {
                !i: !j
                !body
                !j -= 1
            }
        }
    }
}

# Syntax sugers for pattern-matching
#
# 1: equal-pattern
# f(...,a,...,a,...): body
# is equivalent to
# f(...,a,...,b,...) when a == b: body
#
#NB: Exceptions are Dont-care pattern '_' and special symbols.
#
# 2: or-pattern
# f(..,pat1 or pat2,...): body
# is equivalent to
# f(...,t,...) when Seq{init; TryAssign{pat1, t} or TryAssign{pat2, t}}:...
#
# pat1 and pat2 must have exactly same set of symbol.

desugar_args(a, _, _, _): a
desugar_args(a, vars, checks, 0): {
    args: Prim.arguments(a)
    if args == []
        return a
    args = desugar_args(args, vars, checks, 0)
    MakeObject{Prim.head(a), args}
}
desugar_args([], _, _, 0): []
desugar_args([a,rest...], vars, checks, 0): {
    a    = desugar_args(a, vars, checks, 0)
    rest = desugar_args(rest, vars, checks, 0)
    Prim.list_cons(a, rest)
}
desugar_args(a @ Symbol, vars, checks, 0): {
    if not Prim.array_include?(vars, a) {
        Prim.array_push(vars, a)
        return a
    }
    t: Prim.unique_symbol(a)
    Prim.array_push(checks, ([], `Equal{!t, !a}))
    t
}
desugar_args('_, _, _, 0): '_
desugar_args(nil, _, _, 0): nil
desugar_args(true, _, _, 0): true
desugar_args(false, _, _, 0): false
desugar_args(a @ Quote, _, _, 0): a
desugar_args(a @ QuasiQuote, vars, checks, level): {
    arg: desugar_args(Prim.get_arg(a, 0), vars, checks, level + 1)
    'QuasiQuote{!arg}
}
desugar_args(a @ Unquote, vars, checks, level): {
    arg: desugar_args(Prim.get_arg(a, 0), vars, checks, level - 1)
    'Unquote{!arg}
}
desugar_args(a @ Domain, vars, checks, 0): {
    v: Prim.get_arg(a, 0)
    pat: Prim.get_arg(a, 1)
    if not Prim.array_include?(vars, v)
        Prim.array_push(vars, v)
    if Prim.head(pat) == 'Symbol
        return a
    pat = desugar_args(pat, vars, checks, 0)
    if Prim.head(pat) == 'Symbol {
        Prim.array_push(checks, ([`Define{!pat, !v}], true))
        v
    } else
        `Domain{!v, !pat}
}

desugar_args(orpat @ SeqOr, vars, checks, 0): {
    # Translate `a or b or ..` to [a,b,..]
    t: Prim.unique_symbol('t)
    to_list(pat): [pat]
    to_list(SeqOr{a, b}): Prim.list_append(to_list(a), to_list(b))
    pats: to_list(orpat)
    n: Prim.array_size(vars)
    orp_vars: Prim.array_new_empty()
    pats = Prim.list_map(p -> {
                Prim.array_resize(vars, n)
                p: desugar_args(p, vars, checks, 0)
                for i in n..Prim.array_size(vars) {
                    if not Prim.array_include?(orp_vars, vars[i])
                        Prim.array_push(orp_vars, vars[i])
                }
                p
            }, pats)
    init: Prim.array_to_list(Prim.array_map(x -> `Define{!x, nil}, orp_vars))
    asgn: Prim.list_foldl1((a,b) -> `(!a or !b),
            Prim.list_map(p -> `TryAssign{!p, !t}, pats))
    Prim.array_push(checks, (init, asgn))
    t
}

desugar_lambda(args, guard, body): {
    vars: Prim.array_new_empty()   # Parameter-variables
    checks: Prim.array_new_empty() # Expresions that is needed to be checked.
    args = desugar_args(args, vars, checks, 0)
    if Prim.array_size(checks) == 0 {
        if guard == nil
            return `Lambda{!args, !body}
        else
            return `Lambda{When{!args, !guard}, !body}
    } else {
        inits: Prim.array_foldr(((a, _), b) -> Prim.list_append(a, b), checks, [])
        checkexpr: Prim.array_foldl1((a, b) -> `(!a and !b),
                Prim.array_map(((_, b)) -> b, checks))
        if guard != nil
            guard = `(!checkexpr and !guard)
        else
            guard = checkexpr
        if inits != []
            guard = `Seq{!Prim.list_append(inits, [guard])}
        return `Lambda{When{!args, !guard}, !body}
    }
}

macro(Lambda{args @ List, body}): desugar_lambda(args, nil, body)
macro(Lambda{When{args, guard}, body}): desugar_lambda(args, guard, body)

# 'with' exprssion
#
# obj with { a = p, b = q, c = r }
#
# is expaned to
#
# { t: obj; t.a = p; t.b = q; t.c = r; t }
#
macro(WithSlots{obj, init}): `Apply{!obj, () -> { Seq{!init}; self }, []}

## Utilities
add_reserved_word(syms...):
    Prim.list_foreach(sym -> Prim.array_push(Syntax.reserved_words, sym), syms)

Syntax.new(case_sensitive=true): {
    if not case_sensitive
        throw `NotImplemented{"Sorry but we haven't implemented case-insensitive syntax"}
    syn: `Syntax{}
    syn.reserved_words: Prim.array_new_empty()
    syn.case_sensitive: case_sensitive
    syn.add_reserved_word(symbols...): {
        for v in symbols
            Prim.array_push(self.reserved_words, v)
    }
    syn
}
