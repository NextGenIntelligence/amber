" Copyright (C) 2010 nineties "
" $Id: Syntax.ab 2014-02-12 17:06:08 nineties $ "

" Syntax definition of the Amber language. "

" Enable DefSyntax{...} expression. "
Define{eval, Lambda{List{Domain{stmt, DefineSyntax}},
    Apply{eval, List{
        Apply{Slot{Prim, compile_define_syntax}, List{stmt}}
    }}},
    incremental
}

" Enable comment syntax. "
Assign{Slot{Syntax, comment}, Slot{Prim, parse_shell_style_comment}}

### Syntax definition
# Amber's parser uses Parsing Expression Grammer (PEG) 

## syntax elements
# .     : any character
# P*    : zero or many
# P+    : one or many
# P..   : sequence
# P / P : choice
# P?    : option
# &P    : and
# !P    : not
# (...) : grouping
# [...] : oneof
# [^..] : noneof

## Amber's unique syntax elements
# aligned(p)       : sequence of p when every p has same indentation
# delimited(p, d)  : sequence of p delimited by d
# delimited1(p, d) : sequence of p delimited by d (one or many)
# delimited2(p, d) : sequence of p delimited by d (two or many)
# located(p)       : parse p with location
# parsewith(p)     : do parse using p (p can refer previous tokens)

DefineSyntax{
    character_set,
    List{Tuple{List{Many1{Choice{List{'\\', any}, List{Not{"]"}, any}}}},
        Apply{input_text, List{parser,begin,end}}}
    }
}

DefineSyntax{
    primary_syntax_element,
    List{
        Tuple{List{"."}, Quote{any}},
        Tuple{List{string}, node0},
        Tuple{List{symbol_without_mark}, node0},
        Tuple{List{reserved_symbol}, node0},
        Tuple{List{"(", syntax_element, ")"}, node1},
        Tuple{List{"(", Many1{syntax_element}, ")"}, node1, multiline},
        Tuple{List{"[", "^", character_set, "]"},
            QuasiQuote{NoneOf{Unquote{node2}}}},
        Tuple{List{"[", character_set, "]"},
            QuasiQuote{OneOf{Unquote{node1}}}}
    }
}

DefineSyntax{
    syntax_element,
    List{
        Tuple{List{primary_syntax_element, "?"},
            QuasiQuote{Option{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "*"},
            QuasiQuote{Many{Unquote{node0}}}},
        Tuple{List{primary_syntax_element, "+"},
            QuasiQuote{Many1{Unquote{node0}}}},
        Tuple{List{Delimited2{primary_syntax_element, "/"}},
            MakeObject{Quote{Choice}, node0}},
        Tuple{List{"&", primary_syntax_element},
            QuasiQuote{And{Unquote{node1}}}},
        Tuple{List{"!", primary_syntax_element},
            QuasiQuote{Not{Unquote{node1}}}},
        Tuple{List{"aligned", "(", syntax_element, ")"},
            QuasiQuote{Aligned{Unquote{node2}}}, multiline},
        Tuple{List{"delimited", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited1", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited1{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"delimited2", "(", syntax_element, ",", syntax_element, ")"},
            QuasiQuote{Delimited2{Unquote{node2}, Unquote{node4}}}, multiline},
        Tuple{List{"located", "(", syntax_element, ")"},
            QuasiQuote{Located{Unquote{node2}}}, multiline},
        Tuple{List{"parsewith", "(", symbol, ")"},
            QuasiQuote{ParseWith{Unquote{node2}}}, multiline},
        Tuple{List{primary_syntax_element}, node0}
    }
}

DefineSyntax{
    parser_option,
    List{
        Tuple{List{"<<", Delimited1{symbol, ","}, ">>"},
            node1, multiline}
    }
}

DefineSyntax{
    parser_action,
    List{Tuple{List{"{", Aligned{stmt}, "}"},
        QuasiQuote{Block{Unquote{node1}}}, multiline}
        }
}

DefineSyntax{
    parser_entry,
    List{
        Tuple{List{parser_option, Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node1}, Unquote{node2}, Unquote{node0}}}
        },
        Tuple{List{Many1{syntax_element}, parser_action},
            QuasiQuote{Tuple{Unquote{node0}, Unquote{node1}}}
        },
        Tuple{List{parser_option, syntax_element},
            QuasiQuote{Tuple{Unquote{List{node1}}, node1, Unquote{node0}}}
        },
        Tuple{List{syntax_element},
            QuasiQuote{Tuple{Unquote{List{node0}}, node0}}
        }
    }
}

DefineSyntax{
    syntax_declaration,
    List{
        Tuple{List{symbol, "::=", Delimited1{parser_entry, "|"}},
            QuasiQuote{DefineSyntax{
                Unquote{node0},
                Unquote{node2}
            }}}
    }
}

### enable the syntax_declaration statement.
DefineSyntax{stmt, List{ Tuple{List{syntax_declaration}, node0}}}

### Reserved Symbols
# The following symbols never been parsed as symbols.

Define{reserved_symbols, List{
    Quote{self}, Quote{not}, Quote{and}, Quote{or}, Quote{when},
    Quote{if}, Quote{else}, Quote{case}, Quote{of}, Quote{while},
    Quote{for}, Quote{in}, Quote{continue}, Quote{break}, Quote{return},
    Quote{throw}, Quote{try}, Quote{catch}, Quote{import}, Quote{as},
    Quote{hiding}, Quote{export}, Quote{with}, Quote{reset}, Quote{shift}
}}

### Expressions
block_body ::= aligned(located(stmt)) { QuasiQuote{Block{Unquote{node0}}} }

primary_block ::= <<multiline>> "{" block_body "}" { node1 }

block ::= primary_block
        | block_body

primary_expr
    ::= primary_block
      | <<multiline>> "<" postfix_expr ">" "{" parsewith(node1) "}"
        { node4 }
      | <<multiline>> "(" stmt ")"             { node1 }
      # List literal
      | <<multiline>> "[" delimited(expr, ",") "]"  { node1 }
      # Tuple literal
      | "(" ")"
        { MakeObject{Quote{Tuple}, List{}} }
      | <<multiline>> "(" delimited2(expr, ",") ")"
        { MakeObject{Quote{Tuple}, node1} }
      | "|" expr "|" 
        { MakeObject{Quote{Abs}, List{node1}} }
      | self            { Quote{GetSelf{}} }
      | atom
      | "..."           { Quote{Rest{}} }

postfix_expr
        # Function Application
    ::= postfix_expr "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Apply}, List{node0, node2}} }
        # Subscription
      | postfix_expr "[" delimited(expr, ",") "]"
        { MakeObject{Quote{Subscript}, List{node0, node2}} }
      | # RestOf Pattern
        postfix_expr "..."
        { MakeObject{Quote{Rest}, List{node0}} }
        # Domain Pattern
      | primary_expr "@" postfix_expr
        { MakeObject{Quote{Domain}, List{node0, node2}} }
      | postfix_expr "." symbol "(" delimited(expr, ",") ")"
        { MakeObject{Quote{Send}, List{node0, node2, node4}} }
      | postfix_expr "." symbol
        { MakeObject{Quote{Slot}, List{node0, node2}} }
      | primary_expr "^" postfix_expr
        { MakeObject{Quote{Power}, List{node0, node2}} }
      | fullform
      | primary_expr

quote_expr
    ::= "\\" quote_expr
        { MakeObject{Quote{Quote}, List{node1}} }
      | "`"  quote_expr
        { MakeObject{Quote{QuasiQuote}, List{node1}} }
      | "!"  quote_expr
        { MakeObject{Quote{Unquote}, List{node1}} }
      | postfix_expr

pattern ::= quote_expr
term    ::= primary_expr

## enable use of quotation expressions for following definitions.
Assign{Slot{Syntax, expr}, Slot{Syntax, quote_expr}}

prefix_expr
    ::= "+"          quote_expr { `UnaryPlus{!node1} }
      | "-" !decimal quote_expr { `UnaryMinus{!node2} }
      | not quote_expr          { `Not{!node1} }
      | quote_expr

multiplicative_expr
    ::= multiplicative_expr '*' prefix_expr { `Mul{!node0, !node2} }
      | multiplicative_expr '/' prefix_expr { `Div{!node0, !node2} }
      | multiplicative_expr '%' prefix_expr { `Mod{!node0, !node2} }
      | prefix_expr

additive_expr
    ::= additive_expr '+' multiplicative_expr { `Add{!node0, !node2} }
      | additive_expr '-' multiplicative_expr { `Sub{!node0, !node2} }
      | multiplicative_expr

range_expr
    ::= additive_expr ".." additive_expr { `Range{!node0, !node2} }
      | additive_expr

rel_expr
    ::= range_expr "<"  range_expr  { `LessThan{!node0, !node2} }
      | range_expr "<=" range_expr  { `LessEqual{!node0, !node2} }
      | range_expr ">"  range_expr  { `GreaterThan{!node0, !node2} }
      | range_expr ">=" range_expr  { `GreaterEqual{!node0, !node2} }
      | range_expr "==" range_expr  { `Equal{!node0, !node2} }
      | range_expr "!=" range_expr  { `NotEqual{!node0, !node2} }
      | range_expr "<=>" range_expr { `Compare{!node0, !node2} }
      | range_expr

seqand_expr
    ::= rel_expr and seqand_expr { `SeqAnd{!node0, !node2} }
      | rel_expr

seqor_expr
    ::= seqand_expr or seqor_expr { `SeqOr{!node0, !node2} }
      | seqand_expr

ternary_expr
    ::= seqor_expr "?" seqor_expr ":" ternary_expr
        { `IfElse{!node0, !node2, !node4} }
      | seqor_expr

guard_clause ::= when ternary_expr { node1 }

argument_list
    ::= "(" delimited(pattern, ",") ")" guard_clause
        { `When{!node1, !node3} }
      | "(" delimited(pattern, ",") ")"
        { node1 }
      | !"{" pattern guard_clause
        { `When{List{!node1}, !node2} }
      | !"{" pattern
        { List{node1} }

lambda_expr
    ::= argument_list "->" ternary_expr
        { `Lambda{!node0, !node2} }
      | ternary_expr

multi_lambda_expr
    ::= lambda_expr "|" multi_lambda_expr
        { `Fusion{!node0, !node2} }
      | lambda_expr

slot_assign
    ::= <<multiline>> "{" delimited1(assign_expr, ",") "}" { node1 }
      | <<multiline>> "{" aligned(assign_expr) "}" { node1 }
      | assign_expr { List{node0} }

continuation_expr
    ::= reset multi_lambda_expr { `Reset{!node1} }
      | shift multi_lambda_expr { `Shift{!node1} }
      | multi_lambda_expr

assign_expr
    ::= pattern guard_clause "=" assign_expr
            { `Assign{!node0, !node3, !node1} }
      | pattern "=" assign_expr   { `Assign{!node0, !node2} }
      | pattern "+=" assign_expr  { `AddAssign{!node0, !node2} }
      | pattern "-=" assign_expr  { `SubAssign{!node0, !node2} }
      | pattern "*=" assign_expr  { `MulAssign{!node0, !node2} }
      | pattern "^=" assign_expr  { `PowAssign{!node0, !node2} }
      | pattern "/=" assign_expr  { `DivAssign{!node0, !node2} }
      | pattern "%=" assign_expr  { `ModAssign{!node0, !node2} }
      | pattern "|=" assign_expr  { `FusionAssign{!node0, !node2} }
      | pattern with slot_assign
        { MakeObject{Quote{InitSlots}, List{node0, node2}} }
      | continuation_expr

Assign{Syntax.expr, Syntax.assign_expr}

### Statements

import_option
    ::= as pattern                             { `As{!node1} }
      |"(" delimited1(symbol, ",") ")"         { node1 }
      | hiding "(" delimited1(symbol, ",") ")" { `Hiding{!node2} }

stmt
    ::= stmt ";" stmt
        { `Seq{[!node0, !node2]} }

      | stmt ";"
        { `Seq{[!node0, nil]} }

      | <<multiline>> if term stmt else stmt
        { `IfElse{!node1, !node2, !node4} }
      | <<multiline>> if term stmt
        { `If{!node1, !node2} }

      | <<multiline>> case term of multi_lambda_expr
        { `Apply{!node3, [!node1]} }

      | <<multiline>> while term block
        { `While{!node1, !node2} }
      | <<multiline>> for "(" pattern in expr ")" block
        { `For{!node2, !node4, !node6} }
      | continue
        { `Continue{} }
      | break
        { `Break{} }
      | return expr
        { `Return{!node1} }
      | return
        { `Return{nil} }
      | throw expr
        { `Throw{!node1} }
      | <<multiline>> try block catch multi_lambda_expr
        { `Try{!node1, !node3} }
      | <<multiline>> pattern guard_clause ":" stmt
        { `Define{!node0, !node3, !node1} }
      | <<multiline>> pattern ":" stmt
        { `Define{!node0, !node2} }
      | import delimited1(symbol, ".") import_option?
        { `Import{!node1, !node2} }
      | export symbol+
        { `Export{!node1} }

# Extend primary_expr to enable dollar sign ($) in parser action.
primary_expr_act
    ::= "$" decimal
        {
            Prim.to_sym(
                Prim.string_add("node",
                Prim.int_to_string(node1)))
        }
      | "$input"    { \input_text(parser, begin, end) }
    
Syntax.primary_expr_act = fusion(Syntax.primary_expr_act, Syntax.primary_expr)

Syntax.parser_action_old: Syntax.parser_action
Syntax.parser_action = parser -> {
    save_primary_expr: Syntax.primary_expr
    Syntax.primary_expr = Syntax.primary_expr_act
    r: Syntax.parser_action_old(parser)
    Syntax.primary_expr = save_primary_expr
    r
}

# Extension of primary_expr to enable percent sign (%) in shell mode.
primary_expr_shell
    ::= "%" decimal
        {
            if (Prim.equal?(node1, 0) or
                Prim.int_greater_than?(node1, array_size(shell_outputs))) {
                    throw `SyntaxError{!LOCATION,
                        "The argument of % must be a line number"}
            }
            `Prim.array_at(shell_outputs, [!node1])
        }
      | "%" { `Prim.array_at(shell_outputs[0]) }

Syntax.enable_shell_syntax: () -> {
    Syntax.primary_expr = fusion(Syntax.primary_expr, Syntax.primary_expr_shell)
}

### Macro
macro: e -> e
expand_macro: expr -> {
    expand_macro_iter: (expr, level) -> {
        if (Equal{level, 0}) {
            new_expr: macro(expr)
            while (NotEqual{new_expr, expr}) {
                expr = new_expr
                new_expr = macro(expr)
            }
        }

        head: Prim.head(expr)

        if (Equal{level, 0} and Equal{head, \QuoteSyntax})
            return Prim.at(expr, 0)
        else if (Equal{head, \QuasiQuoteSyntax}) {
            level = Prim.int_add(level, 1)
            expr = Prim.at(expr, 0)
        } else if (Equal{head, \UnquoteSyntax}) {
            level = Prim.int_sub(level, 1)
            expr = Prim.at(expr, 0)
        } else if (Equal{level, 0} and Equal{head, \Quote})
            return expr
        else if (Equal{head, \QuasiQuote})
            level = Prim.int_add(level, 1)
        else if (Equal{head, \Unquote})
            level = Prim.int_sub(level, 1)

        if (Prim.int_less_than?(level, 0))
            throw `LogicError{!LOCATION, "Unquotation outside quasi-quotation"}

        if (Prim.atom?(expr))
            return expr

        head = Prim.head(expr)
        args: Prim.arguments(expr)
        args = Prim.list_map(e -> expand_macro_iter(e, level), args)
        MakeObject{head, args}
    }
    expand_macro_iter(expr, 0)
} 

# Expand macros only once before eval.
Amber.before_eval = expand_macro

macro = fusion((Assign{Apply{f, args}, e}) -> `Assign{!f, Lambda{!args, !e}, incremental}, macro)
macro(Define{Apply{f, args}, e})     = `Define{!f, Lambda{!args, !e}, incremental}
macro(Define{Send{obj, f, args}, e}) = `Define{Slot{!obj, !f}, Lambda{!args, !e}, incremental}
macro(Assign{Send{obj, f, args}, e}) = `Assign{Slot{!obj, !f}, Lambda{!args, !e}, incremental}
macro(Define{Apply{f, args}, e, g})     = `Define{!f, Lambda{When{!args, !g}, !e}, incremental}
macro(Assign{Apply{f, args}, e, g})     = `Assign{!f, Lambda{When{!args, !g}, !e}, incremental}
macro(Define{Send{obj, f, args}, e, g}) = `Define{Slot{!obj, !f}, Lambda{When{!args, !g}, !e}, incremental}
macro(Assign{Send{obj, f, args}, e, g}) = `Assign{Slot{!obj, !f}, Lambda{When{!args, !g}, !e}, incremental}

macro(|x|)     = `abs(!x)
macro(+x)      = `uplus(!x)
macro(-x)      = `uminus(!x)
macro(x + y)   = `add(!x, !y)
macro(x - y)   = `sub(!x, !y)
macro(x * y)   = `mul(!x, !y)
macro(x ^ y)   = `pow(!x, !y)
macro(x / y)   = `div(!x, !y)
macro(x % y)   = `mod(!x, !y)
macro(x | y)   = `fusion(!x, !y)
macro(x < y)   = `less_than?(!x, !y)
macro(x > y)   = `greater_than?(!x, !y)
macro(x <= y)  = `less_equal?(!x, !y)
macro(x >= y)  = `greater_equal?(!x, !y)
macro(x == y)  = `equal?(!x, !y)
macro(x != y)  = `(not equal?(!x, !y))
macro(x <=> y) = `compare(!x, !y)
macro(x += y)  = `ArithAssign{!x, !y, add!}
macro(x -= y)  = `ArithAssign{!x, !y, sub!}
macro(x *= y)  = `ArithAssign{!x, !y, mul!}
macro(x ^= y)  = `ArithAssign{!x, !y, pow!}
macro(x /= y)  = `ArithAssign{!x, !y, div!}
macro(x %= y)  = `ArithAssign{!x, !y, mod!}
macro(x |= y)  = `ArithAssign{!x, !y, fusion!}

# Subscript syntax is not built-in. We need macros.
macro(x[idxs...]) = `Send{!x, at, !idxs}
macro(QuoteSyntax{x[idxs...]} = e)
    = `Send{!x, store, !Prim.list_append(idxs, [e])}
macro(ArithAssign{QuoteSyntax{x[idxs...]}, e, op}) = {
    # We have to consider that evaluation of `x' and `idxs' may have
    # side-effects. So, we translate x[a,b] op= e to
    # { y = x; t1 = a; t2 = b; y[t1, t2] = op(y[t1, t2], e) }
    stmt1: `Define{!unique_symbol(\x), !x}
    stmt2: Prim.list_map(i -> `Define{!unique_symbol(\t), !i}, idxs)
    y: at(stmt1, 0)
    ts: Prim.list_map(e -> at(e, 0), stmt2)

    `Block{
        !Prim.list_append(
            Prim.cons(stmt1, stmt2),
            [`Assign{Subscript{!y, !ts}, Apply{!op, [Subscript{!y, !ts}, !e]}}]
        )
    }
}

# For-statement for containers. 
macro(For{i, container, body}) = {
    iter:  Prim.unique_symbol(\iter)
    value: Prim.unique_symbol(\value)
    `{
        !iter : (!container).each()
        !value: nil
        while ((!value = (!iter)()) != nil) {
            !i: !value
            !body
        }
    }
}

# For-statement for ranges.
macro(QuoteSyntax{For{i, Range{a, b}, body}}) = {
    j: Prim.unique_symbol(\j)
    n: Prim.unique_symbol(\n)
    `{
        !j: !a
        !n: !b
        while (!j <= !n) {
            !i: !j
            !body
            !j += 1
        }
    }
}

### 'with' exprssion
#
# obj with { a = p, b = q, c = r }
#
# is expaned to
#
# { t: obj; t.a = p; t.b = q; t.c = r; t }
#
macro(InitSlots{obj, slots}): {
    t: Prim.unique_symbol(\t)
    transl(e): case (macro(e)) of
          e @ Assign -> {
              Prim.store(e, 0, `Slot{!t, !Prim.at(e, 0)})
              e
          }
        | e @ Define -> {
              Prim.store(e, 0, `Slot{!t, !Prim.at(e, 0)})
              e
          }
        | e @ ... -> {
              throw `InvalidSyntax{!LOCATION,
                  "Invalid syntax of slot assignment.",
                  !e}
          }
    `{
        !t: !obj
        Seq{!Prim.list_map(transl, slots)}
        !t
    }
}
