# Copyright (C) 2012 nineties
#
# $Id: binio.ab 2013-01-23 22:15:09 nineties $

### Definition ###
#
# foo: binio {
#     name1:    type1
#     name2:    type2
#     ...
# }
#
# Types can be one of
#   char (8bit integer), uchar (unsigned 8bit integer),
#   int16, uint16, int32, uint32, int64, uint64
# or an array of a type like:
#   uchar[16]
#
# The length of the array should be a constant integer or
# reference to one of previous field liker:
#
# foo: binio {
#   len:    uint16
#   ary:    uint32[len]
#   ...
# }
#
### Reading & Writing ###
#
# data: foo.read(io)
# foo.write(io, data)
#

import data.struct

module binio {
    # Types
    char:   \BinIOType{int8}
    int8:   \BinIOType{int8}
    int16:  \BinIOType{int16}
    int32:  \BinIOType{int32}
    uchar:  \BinIOType{uint8}
    uint8:  \BinIOType{uint8}
    uint16: \BinIOType{uint16}
    uint32: \BinIOType{uint32}
    float:  \BinIOType{float}
    string: \BinIOType{string}

    module impl {
        # Reader
        read_funcs: Table {
            \int8   => read_int8,
            \uint8  => read_uint8,
            \int16  => read_int16,
            \uint16 => read_uint16,
            \int32  => read_int32,
            \uint32 => read_uint32,
            \float  => read_float,
            \string => read_string
        }

        read(io, t): {
            f: read_funcs[t]
            if (f == undefined)
                throw `UnknownBinaryFormat{!LOCATION, !t}
            f(io)
        }

        read(io, Array{t, n@Int}): {
            if (n <= 0)
                throw `InvalidBinaryFormat{!LOCATION, Array{!t, !n}}
            ary: Array::new(n)
            for i in 0..n-1
                ary[i] = read(io, t)
            ary
        }

        #Writer
        write_funcs: Table {
            \int8   => write_int8,
            \uint8  => write_uint8,
            \int16  => write_int16,
            \uint16 => write_uint16,
            \int32  => write_int32,
            \uint32 => write_uint32,
            \float  => write_float,
            \string => write_string
        }

        write(io, t, data): {
            f: write_funcs[t]
            if (f == undefined)
                throw `UnknownBinaryFormat{!LOCATION, !t}
            f(io, data)
        }

        write(io, Array{t, len}, data): {
            for i in 0..len-1
                write(io, t, data[i])
        }

        define_binio(name, fields): {
            read_funcs[name] = (io) -> {
                MakeNode{name, fields.map(((_, t)) -> read(io, t))}
            }
            write_funcs[name] = (io, data) -> {
                i: 0
                for (_, t) in fields {
                    write(io, t, data[i])
                    i += 1
                }
            }
        }
    }

    read(io, BinIOType{t}): impl::read(io, t)
    write(io, data): impl::write(io, head(data), data) 
}

### Syntax ###
binio_type
    ::= binio_type "[" expr "]"         { `Array{!$0, !$2} }
      | symbol

binio_field
    ::= symbol ":" binio_type           { ($0, $2) }

binio_fields
    ::= [multiline] "{" aligned(binio_field) "}"    { $1 }

binio_creation
    ::= "binio" binio_fields { `BinIO{!$1} }

binio_definition
    ::= [multiline] "binio" symbol "{" aligned(binio_field) "}"
        { `DefineBinIO{!$1, !$3} }

statement ::= binio_definition

### Semantics ###
DefineBinIO{name, fields} => {
        impl::define_binio(name, fields)
        `seq {
            (!name): \BinIOType{!name}
            !std::impl::gen_struct_decl(name, fields.map(((x,_)) -> `Field{!x, undefined}))
        }
    }
