# Copyright (C) 2012 nineties
#
# $Id: binio.ab 2013-01-23 01:51:28 nineties $

### Definition ###
#
# foo: binio {
#     name1:    type1
#     name2:    type2
#     ...
# }
#
# Types can be one of
#   char (8bit integer), uchar (unsigned 8bit integer),
#   int16, uint16, int32, uint32, int64, uint64
# or an array of a type like:
#   uchar[16]
#
# The length of the array should be a constant integer or
# reference to one of previous field liker:
#
# foo: binio {
#   len:    uint16
#   ary:    uint32[len]
#   ...
# }
#
### Reading & Writing ###
#
# data: foo.read(io)
# foo.write(io, data)
#
module binio {
    # Types
    char:   \BinIOType{int8}
    int8:   \BinIOType{int8}
    int16:  \BinIOType{int16}
    int32:  \BinIOType{int32}
    uchar:  \BinIOType{uint8}
    uint8:  \BinIOType{uint8}
    uint16: \BinIOType{uint16}
    uint32: \BinIOType{uint32}

    module impl {
        read_funcs: Table {
            \int8   => read_int8,
            \uint8  => read_uint8,
            \int16  => read_int16,
            \uint16 => read_uint16,
            \int32  => read_int32,
            \uint32 => read_uint32
        }

        define(name, fields): {
            puts(name)
            puts(fields)
        }
    }

    read(io, BinIOType{t}): {
        f: impl::read_funcs[t]
        if (f == undefined)
            throw `UnknownBinaryFormat{!LOCATION, !t}
        f(io)
    }
}

### Syntax ###
binio_type
    ::= binio_type "[" expr "]"         { `Array{!$0, !$2} }
      | symbol

binio_field
    ::= symbol ":" binio_type           { ($0, `BinIOType{!$2}) }

binio_fields
    ::= [multiline] "{" aligned(binio_field) "}"    { $1 }

binio_creation
    ::= "binio" binio_fields { `BinIO{!$1} }

binio_definition
    ::= [multiline] "binio" symbol "{" aligned(binio_field) "}"
        { `DefineBinIO{!$1, !$3} }

statement ::= binio_definition

### Semantics ###
DefineBinIO{name, fields} => binio::impl::define(name, fields)
