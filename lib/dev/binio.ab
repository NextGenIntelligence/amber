# Copyright (C) 2012 nineties
#
# $Id: binio.ab 2013-01-25 12:05:29 nineties $

### Definition ###
#
# foo: binio {
#     name1:    type1
#     name2:    type2
#     ...
# }
#
# Types can be one of
#   char (8bit integer), uchar (unsigned 8bit integer),
#   int16, uint16, int32, uint32, int64, uint64
# or an array of a type like:
#   uchar[16]
#
# The length of the array should be a constant integer or
# reference to one of previous field liker:
#
# foo: binio {
#   len:    uint16
#   ary:    uint32[len]
#   ...
# }
#
### Reading & Writing ###
#
# data: foo.read(io)
# foo.write(io, data)
#

import data.struct
open bigint

module binio {
    module impl {
        read_address_error(_):
            throw `Error{!LOCATION, "Address width is unspecified. Call binio::set_address_width(n)."}
        write_address_error(_, _):
            throw `Error{!LOCATION, "Address width is unspecified. Call binio::set_address_width(n)."}

        # Reader
        read_funcs: Table {
            \char    => read_int8,
            \uchar   => read_uint8,
            \int8    => read_int8,
            \uint8   => read_uint8,
            \int16   => read_int16,
            \uint16  => read_uint16,
            \int32   => read_int32,
            \uint32  => read_uint32,
            \int64   => read_int64,
            \uint64  => read_uint64,
            \float   => read_float,
            \asciiz  => read_string,
            \address => read_address_error,
            \offset  => read_address_error
        }

        read(io, t): {
            f: read_funcs[t]
            if (f == undef)
                throw `UnknownBinaryFormat{!LOCATION, !t}
            f(io)
        }

        read(io, Array{t, n@Int}): {
            if (n <= 0)
                throw `InvalidBinaryFormat{!LOCATION, Array{!t, !n}}
            ary: Array::new(n)
            for i in 0..n-1
                ary[i] = read(io, t)
            ary
        }

        read(io, Map{t, list@List}): {
            i: read(io, t)
            (i >= list.size) ? i : list[i]
        }

        read(io, Map{t, map@BiTable}): {
            i: read(io, t)
            v: map.right[i]
            (v == undef) ? i : v
        }

        #Writer
        write_funcs: Table {
            \char    => write_int8,
            \uchar   => write_uint8,
            \int8    => write_int8,
            \uint8   => write_uint8,
            \int16   => write_int16,
            \uint16  => write_uint16,
            \int32   => write_int32,
            \uint32  => write_uint32,
            \int64   => write_int64,
            \uint64  => write_uint64,
            \float   => write_float,
            \asciiz  => (io, str) -> {
                write_string(io, str); write_uint8(io, 0)
            },
            \address => write_address_error,
            \offset  => write_address_error
        }

        write(io, t, data): {
            f: write_funcs[t]
            if (f == undef)
                throw `UnknownBinaryFormat{!LOCATION, !t}
            f(io, (data != undef) ? data : 0)
        }

        write(io, Array{t, n@Int}, data): {
            for i in 0..n-1
                write(io, t, (data != undef) ? data[i] : 0)
        }

        write(io, Map{t, list@List}, data): {
            i: index(list, data)
            if (i == undef)
                write(io, t, (data != undef) ? data : 0)
            else
                write(io, t, i)
        }

        write(io, Map{t, map@BiTable}, data): {
            i: map.left[data]
            if (i == undef)
                write(io, t, (data != undef) ? data : 0)
            else
                write(io, t, i)
        }

        define_binio(name, fields): {
            read_funcs[name] = (io) -> {
                MakeNode{name, fields.map(((_, t)) -> read(io, t))}
            }
            write_funcs[name] = (io, data) -> {
                i: 0
                for (_, t) in fields {
                    write(io, t, data[i])
                    i += 1
                }
            }
        }
    }

    read(io, t): impl::read(io, t)
    write(io, data): impl::write(io, head(data), data) 
    write(io, t, data): impl::write(io, t, data) 

    align(io, w): {
        if (w == 0) return
        for i in 1 .. (io.position % w) {
            impl::write(io, \uint8, 0)
        }
    }

    set_address_width(n@Int): {
        if (n == 32) {
            impl::read_funcs[\address]  = read_uint32
            impl::read_funcs[\offset]   = read_uint32
            impl::write_funcs[\address] = write_uint32
            impl::write_funcs[\offset]  = write_uint32
        } else if (n == 64) {
            impl::read_funcs[\address]  = read_uint64
            impl::read_funcs[\offset]   = read_uint64
            impl::write_funcs[\address] = write_uint64
            impl::write_funcs[\offset]  = write_uint64
        } else {
            throw `Error{"Invalid address width", !n}
        }
        nil
    }
}

### Syntax ###
binio_simple_type
    ::= binio_simple_type "[" expr "]"
        { `Array{!$0, !eval($2)} }
      | symbol

binio_type
    ::= binio_simple_type "=>" expr
        { `Map{!$0, !eval($2)} }
      | binio_simple_type

binio_field
    ::= symbol ":" binio_type           { ($0, $2) }

binio_fields
    ::= [multiline] "{" aligned(binio_field) "}"    { $1 }

binio_creation
    ::= "binio" binio_fields { `BinIO{!$1} }

binio_definition
    ::= [multiline] "binio" symbol "{" aligned(binio_field) "}"
        { `DefineBinIO{!$1, !$3} }

statement ::= binio_definition

### Semantics ###
DefineBinIO{name, fields} => {
        binio::impl::define_binio(name, fields)
        `seq {
            !std::impl::gen_struct_decl(name, fields.map(((x,_)) -> `Field{!x, undef}))
        }
    }
