# Copyright (C) 2014 nineties
# $Id: Stack.ab 2014-02-16 18:13:22 nineties $

import Collection

trait Stack {
    extend Trait.Collection

    require push pop top
    export  push_values pop drop clear dup rotate

    # Push values from given Iterable object.
    push_values(seq) = {
        it: seq.iterator()
        while (it.next?) push(it.next())
        self
    }
    push_values(seq, n @ Int) = {
        it: seq.iterator()
        for (i in 1..n) push(it.next())
        self
    }

    # Remove `n' elements and return them as a list.
    pop(n @ Int) = {
        v: pop()
        cons(v, pop(n-1))
    }
    pop(0): []

    # Drop elements.
    drop() = {
        pop()
        self
    }
    drop(n @ Int) = {
        for (i in 1..n) pop()
        self
    }

    # Remove all elements from the stack.
    clear() = {
        while (not empty?) pop()
        self
    }

    # Duplicate `top'.
    dup() = push(top())

    # Duplicate `top' `n' times.
    dup(n @ Int) = {
        for (i in 1..n) dup()
        self
    }

    # Rotate `n` elements by sliding `m' elements.
    rotate(n @ Int, m @Int) = {
        tmp: Array.new(n)
        for (i in 0..n-1) tmp[(i + m) % n] = pop()
        for (i in 1..n) push(tmp[n-i])
        self
    }
}

### Linked list implementation ###
trait ListStack {
    extend Trait.Stack

    list   = alias(0)
    size   = alias(() -> list.size)
    empty? = alias(() -> list.empty?)

    push(v) = {
        list = cons(v, list)
        self
    }
    pop() = {
        v: car(list)
        list = cdr(list)
        v
    }
}

new(\List): `Stack{[]} with parent = Trait.ListStack

trait ArrayStack {
    extend Trait.Stack

    array   = alias(0)
    size    = alias(() -> array.size)
    empty?  = alias(() -> array.empty?)
    push(v) = array.push_back(v)
    pop()   = array.pop_back()
}

new(\Array): `Stack{!Array.new()} with parent = Trait.ArrayStack


